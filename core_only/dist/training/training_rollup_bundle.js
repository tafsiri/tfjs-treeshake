!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("crypto"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Cast"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Pow"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Add"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Min"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Sub"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Sum"),require("@tensorflow/tfjs-backend-cpu/dist/kernels/Reshape"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Cast"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Pow"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Add"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Min"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Sub"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Sum"),require("@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape")):"function"==typeof define&&define.amd?define(["crypto","@tensorflow/tfjs-backend-cpu/dist/kernels/Cast","@tensorflow/tfjs-backend-cpu/dist/kernels/Pow","@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply","@tensorflow/tfjs-backend-cpu/dist/kernels/Add","@tensorflow/tfjs-backend-cpu/dist/kernels/Min","@tensorflow/tfjs-backend-cpu/dist/kernels/Sub","@tensorflow/tfjs-backend-cpu/dist/kernels/Sum","@tensorflow/tfjs-backend-cpu/dist/kernels/Reshape","@tensorflow/tfjs-backend-webgl/dist/kernels/Cast","@tensorflow/tfjs-backend-webgl/dist/kernels/Pow","@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply","@tensorflow/tfjs-backend-webgl/dist/kernels/Add","@tensorflow/tfjs-backend-webgl/dist/kernels/Min","@tensorflow/tfjs-backend-webgl/dist/kernels/Sub","@tensorflow/tfjs-backend-webgl/dist/kernels/Sum","@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).crypto,t.Cast$1,t.Pow$1,t.Multiply$1,t.Add$1,t.Min$1,t.Sub$1,t.Sum$1,t.Reshape$1,t.Cast$2,t.Pow$2,t.Multiply$2,t.Add$2,t.Min$2,t.Sub$2,t.Sum$2,t.Reshape$2)}(this,(function(t,e,n,r,s,a,o,i,l,u,c,h,d,p,f,g,m){"use strict";t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t;class x{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e instanceof Promise)throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);if("tfjsflags"in t){t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}}function v(){return C}let y,C=null;function b(){if(null==y){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}y=t}return y}function w(t,e){const n=function(){const t=b();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const $=w("kernelRegistry",()=>new Map),R=w("gradRegistry",()=>new Map);function I(t){return R.get(t)}function E(t){const e=$.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===t&&n.push(o)}return n}function A(t){const{kernelName:e,backendName:n}=t,r=S(e,n);$.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),$.set(r,t)}function T(t){const{kernelName:e}=t;R.has(e)&&v().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),R.set(e,t)}function S(t,e){return`${e}_${t}`}function k(t){return t%2==0?t:t+1}function N(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function O(t,e,n=""){N(B(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function F(t){N(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function D(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||X(t)&&!n)for(let r=0;r<t.length;++r)D(t[r],e,n);else e.push(t);return e}function _(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function B(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function M(t){return t%1==0}function P(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function L(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function W(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function V(t,e=(t=>0),n){return new Promise((r,s)=>{let a=0;const o=()=>{if(t())return void r();a++;const i=e(a);null!=n&&a>=n?s():setTimeout(o,i)};o()})}function U(t,e){const n=e.length;return N((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+t),N(t.every(t=>M(t)),()=>"All values in axis param must be integers but got axis "+t),t.map(t=>t<0?n+t:t)}function G(t,e){const n=[],r=[],s=null!=e&&Array.isArray(e)&&0===e.length,a=null==e||s?null:U(e,t).sort();let o=0;for(let e=0;e<t.length;++e){if(null!=a){if(a[o]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==a[o]||a[o]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),a[o]<=e&&o++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function z(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function H(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function X(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function j(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function q(t){return"string"==typeof t||t instanceof String}function K(t){return Array.isArray(t)?K(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":"number"==typeof t?"float32":q(t)?"string":function(t){return"boolean"==typeof t}(t)?"bool":"float32"}function Y(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Q(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Z(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function J(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=D(t)),v().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type "+e)}function tt(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return function t(e,n,r){const s=new Array;if(1===n.length){const t=n[0];for(let n=0;n<t;n++)s[n]=r[e+n]}else{const a=n[0],o=n.slice(1),i=o.reduce((t,e)=>t*e);for(let n=0;n<a;n++)s[n]=t(e+n*i,o,r)}return s}(0,t,e)}function et(t,e){const n=nt(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function nt(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function rt(){return v().platform.now()}function st(t){t.forEach(e=>{N(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function at(t,e="utf-8"){return e=e||"utf-8",v().platform.decode(t,e)}function ot(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function it(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}class lt{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ut)}profileKernel(t,e,n){let r;const s=this.backendTimer.time(()=>{r=n()});return r.forEach(n=>{n.data().then(r=>{!function(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}}(r,n.dtype,t),s.then(s=>{let a="";null!=s.getExtraProfileInfo&&(a=s.getExtraProfileInfo()),this.logger.logKernelProfile(t,n,r,s.kernelMs,e,a)})})}),r}}class ut{logKernelProfile(t,e,n,r,s,a){const o="number"==typeof r?W(r+"ms",9):r.error,i=W(t,25),l=e.rank,u=e.size,c=W(e.shape.toString(),14);let h="";for(const t in s){const n=s[t].shape||e.shape,r=n.length;h+=`${t}: ${r}D ${r>0?n:""} `}console.log(`%c${i}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ct(t,e,n,r){const s=Z(e),a=function(t,e,n,r){const s=_(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,l="complex64"===n?pt(t):t;if(i>1)for(let t=0;t<s/a;t++){const e=t*a;for(let t=0;t<a;t++)o[t]=Math.max(o[t],ht(l[e+t],0,n).length)}return o}(t,e,n,s),o=e.length,i=function t(e,n,r,s,a,o=!0){const i="complex64"===r?2:1,l=n[0],u=n.length;if(0===u){if("complex64"===r){return[ht(pt(e)[0],0,r)]}return"bool"===r?[dt(e[0])]:[e[0].toString()]}if(1===u){if(l>20){const t=3*i;let n=Array.from(e.slice(0,t)),s=Array.from(e.slice((l-3)*i,l*i));return"complex64"===r&&(n=pt(n),s=pt(s)),["["+n.map((t,e)=>ht(t,a[e],r)).join(", ")+", ..., "+s.map((t,e)=>ht(t,a[l-3+e],r)).join(", ")+"]"]}return["["+("complex64"===r?pt(e):Array.from(e)).map((t,e)=>ht(t,a[e],r)).join(", ")+"]"]}const c=n.slice(1),h=s.slice(1),d=s[0]*i,p=[];if(l>20){for(let n=0;n<3;n++){const s=n*d,o=s+d;p.push(...t(e.slice(s,o),c,r,h,a,!1))}p.push("...");for(let n=l-3;n<l;n++){const s=n*d,o=s+d;p.push(...t(e.slice(s,o),c,r,h,a,n===l-1))}}else for(let n=0;n<l;n++){const s=n*d,o=s+d;p.push(...t(e.slice(s,o),c,r,h,a,n===l-1))}const f=2===u?",":"";p[0]="["+p[0]+f;for(let t=1;t<p.length-1;t++)p[t]=" "+p[t]+f;let g=",\n";for(let t=2;t<u;t++)g+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":g),p}(t,e,n,s,a),l=["Tensor"];return r&&(l.push("  dtype: "+n),l.push("  rank: "+o),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(t=>"    "+t).join("\n")),l.join("\n")}function ht(t,e,n){let r;return r=Array.isArray(t)?parseFloat(t[0].toFixed(7))+" + "+parseFloat(t[1].toFixed(7))+"j":q(t)?`'${t}'`:"bool"===n?dt(t):parseFloat(t.toFixed(7)).toString(),W(r,e)}function dt(t){return 0===t?"false":"true"}function pt(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class ft{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=_(t),null!=n){const t=n.length;N(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||H(e,this.size),this.strides=Z(t)}set(t,...e){0===e.length&&(e=[0]),N(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=`+this.shape;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return gt().makeTensor(this.values,this.shape,this.dtype)}}let gt=null;class mt{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=_(t),this.strides=Z(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return null.buffer(this.shape,this.dtype,t)}bufferSync(){return null.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return tt(this.shape,t)}arraySync(){return tt(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=gt().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>at(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=gt().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>at(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await gt().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(gt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return null.print(this,t)}clone(){return this.throwIfDisposed(),null.clone(this)}toString(t=!1){return ct(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),null.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),gt().makeVariable(this,t,e,n)}}Object.defineProperty(mt,Symbol.hasInstance,{value:t=>!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype});class xt extends mt{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!B(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);gt().disposeTensor(this),this.dataId=t.dataId,gt().incRef(this,null)}dispose(){gt().disposeVariable(this),this.isDisposedInternal=!0}}var vt,yt,Ct,bt,wt;Object.defineProperty(xt,Symbol.hasInstance,{value:t=>t instanceof mt&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(vt||(vt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(yt||(yt={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Ct||(Ct={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(bt||(bt={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(wt||(wt={}));const $t={float32:bt,int32:yt,bool:Ct,complex64:wt};function Rt(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return $t[t][e]}function It(t){return Rt(t,"int32")}function Et(t,e){if(t.dtype===e.dtype)return[t,e];const n=Rt(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function At(t){const e=[];return function t(e,n,r){if(null==e)return;if(e instanceof mt)return void n.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const a=e;for(const e in a){const s=a[e];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}class Tt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class St{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Tt}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new lt(this.backendInstance),!0}setupRegisteredKernels(){E(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){E(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(Promise.resolve(n)===n){const e=++this.pendingBackendInitId,r=n.then(n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0)).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,s,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return St.nextTensorId++}nextVariableId(){return St.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],t=>({x:()=>t.toFloat()}),[],{}),e}runKernel(t,e,n,r,s){return this.runKernelFunc(null,e,null,t,n,r,s)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach(t=>{s+="complex64"===t.dtype?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-e-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,s,a,o){let i,l=[];const u=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const c=this.state.numBytes,h=this.state.numTensors;let d;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=function(t,e){const n=S(t,e);return $.get(n)}(r,this.backendName);let f;if(null!=p)d=()=>{const t=this.backend.numDataIds();f=p.kernelFunc({inputs:e,attrs:s,backend:this.backend});const n=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const i=n.map(({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n));if(u){let t=this.getTensorsForGradient(r,e,i);if(null==t){null==o&&(o=[]);const e=i.filter((t,e)=>o[e]);t=(a||[]).slice().concat(e)}l=this.saveTensorsForBackwardMode(t)}return i};else{const e=t=>{u&&(l=t.map(t=>this.keep(this.clone(t))))};d=()=>{const n=this.backend.numDataIds();f=this.tidy(()=>t(this.backend,e));const s=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,s),s}}return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{i=this.ENV.getBool("DEBUG")?this.profiler.profileKernel(r,e,()=>d()):d()}),u&&this.addTapeNode(r,e,i,n,l,s),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-c,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(t=>e[t].shape),outputShapes:i.map(t=>t.shape)}),Array.isArray(f)?i:i[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const r=I(t);if(null!=r){const t=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(N(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(t=>e[t])):a=t.map(t=>e[t]);const o=n.filter((t,e)=>s[e]);return a.concat(o)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=t;"string"===n&&q(t[0])&&(s=t.map(t=>function(t,e="utf-8"){return e=e||"utf-8",v().platform.encode(t,e)}(t)));const a=r.write(s,e,n),o=new mt(e,n,a,this.nextTensorId());if(this.incRef(o,r),"string"===n){const t=this.state.tensorInfo.get(a),e=function(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}(s);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const s=new mt(e,n=n||"float32",t,this.nextTensorId());return this.incRef(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new xt(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*j(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof xt||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;return this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,s,a){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},i=I(t);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],r=nt(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t}),r(t.length>1?t:t[0],s,a))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=At(t),n=new Set(e.map(t=>t.id));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==r.id||this.track(t)})}gradients(t,e,n,r=!1){if(N(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));N(s instanceof mt,()=>"The result y returned by f() must be a tensor.");const a=function(t,e,n){const r={},s={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const a=t[n],o=a.inputs;for(const t in o){const n=o[t];let i=!1;for(let t=0;t<e.length;t++)if(r[n.id]){a.outputs.forEach(t=>r[t.id]=!0),i=!0,s[a.id]=!0;break}if(i)break}}const a={};a[n.id]=!0;const o={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(a[n.outputs[t].id]){for(const t in r)a[r[t].id]=!0,o[n.id]=!0;break}}const i=[];for(let e=0;e<t.length;e++){const n=t[e];if(s[n.id]&&o[n.id]){const t={};for(const e in n.inputs){const s=n.inputs[e];r[s.id]&&(t[e]=s)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,i.push(e)}}return i}(this.state.activeTape,e,s);if(!r&&0===a.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[s.id]=null==n?function(t){const e=et(_(t),"float32");return kt.makeTensor(e,t,"float32")}(s.shape):n,function(t,e,n){for(let r=e.length-1;r>=0;r--){const s=e[r],a=[];if(s.outputs.forEach(e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const e in s.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[e]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${r.dtype}'`);const a=s.inputs[e];if(!B(r.shape,a.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${r.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=r;else{const e=t[a.id];t[a.id]=e.add(r),e.dispose()}}}}(t,a,t=>this.tidy(t));const r=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(t){return N(Y(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;N(e.every(t=>t instanceof mt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return e.forEach((t,e)=>{r[e]=t}),this.runKernelFunc((r,s)=>(n=t(...e,s),N(n.value instanceof mt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),N(Y(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),r,(t,r)=>{const s=n.gradFunc(t,r),a=Array.isArray(s)?s:[s];N(a.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),N(a.every(t=>t instanceof mt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return a.forEach((t,e)=>{o[e]=()=>t}),o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=rt(),n=await this.backend.time(t);return n.wallMs=rt()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Tt;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}St.nextTensorId=0,St.nextVariableId=0;const kt=function(){const t=b();if(null==t._tfengine){const e=new x(t);t._tfengine=new St(e)}var e;return e=t._tfengine.ENV,C=e,gt=()=>t._tfengine,t._tfengine}();function Nt(t,e){let n=t;if(X(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||X(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&v().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){if(r=r||[],!Array.isArray(e)&&!X(e))return void N(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);N(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${e.length} elements`),N(e.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${e.length} elements`);const s=n.slice(1);for(let n=0;n<e.length;++n)t(e[n],s,r.concat(n))}(t,r,[]),r}function Ot(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function Ft(t,e,n,r="numeric"){if(t instanceof mt)return Ot(r,t.dtype,e,n),t;let s=K(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ot(r,s,e,n),null==t||!X(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Nt(t,s);X(t)||Array.isArray(t)||(t=[t]);const o="string"!==s?J(t,s):D(t,[],!0);return kt.makeTensor(o,a,s)}function Dt(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>Ft(t,`${e}[${r}]`,n),r)}function _t(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));const s=(...t)=>{kt.startScope(n);try{const e=r(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),kt.endScope(e),e}catch(t){throw kt.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Bt=_t({pow_:function(t,e){let n=Ft(t,"base","pow"),r=Ft(e,"exp","pow");[n,r]=Et(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.pow(n,r);return e([n,r,s]),s},s,null,"Pow")}});mt.prototype.pow=function(t){return this.throwIfDisposed(),Bt(this,t)};const Mt=_t({add_:function(t,e){let n=Ft(t,"a","add"),r=Ft(e,"b","add");[n,r]=Et(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.add(n,r);return e([n,r]),s},s,null,"Add")}});mt.prototype.add=function(t){return this.throwIfDisposed(),Mt(this,t)};const Pt=_t({mul_:function(t,e){let n=Ft(t,"a","mul"),r=Ft(e,"b","mul");[n,r]=Et(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.multiply(n,r);return e([n,r]),s},s,null,"Multiply")}});mt.prototype.mul=function(t){return this.throwIfDisposed(),Pt(this,t)};const Lt=_t({sub_:function(t,e){let n=Ft(t,"a","sub"),r=Ft(e,"b","sub");[n,r]=Et(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.subtract(n,r);return e([n,r]),s},s,null,"Sub")}});function Wt(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Vt(t,e,n){const r=t.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?s.push(t[a++]):s.push(e[o++]);return s}function Ut(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map(e=>t[e])]}function Gt(t,e){return Vt(t,e.map(t=>1),e)}function zt(t,e,n){N(Wt(e,n),()=>t+" supports only inner-most axes for now. "+`Got axes ${e} and rank-${n} input.`)}function Ht(t,e){if(Wt(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(t=>n.push(t)),n}function Xt(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function jt(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}mt.prototype.sub=function(t){return this.throwIfDisposed(),Lt(this,t)};const qt=_t({reshape_:function(t,e){const n=Ft(t,"x","reshape",null);e=function(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}(e,n.size),N(n.size===_(e),()=>"new shape and old shape must have the same number of elements.");const r={x:n},s={shape:e};return kt.runKernelFunc((t,r)=>(r([n]),t.reshape(n,e)),r,null,"Reshape",s)}});const Kt=_t({transpose_:function(t,e){const n=Ft(t,"x","transpose");if(null==e&&(e=n.shape.map((t,e)=>e).reverse()),N(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{N(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e)}),n.rank<=1)return n.clone();const r={x:n},s={perm:e};return kt.runKernelFunc(t=>t.transpose(n,e),r,null,"Transpose",s)}});const Yt=_t({min_:function(t,e=null,n=!1){const r=Ft(t,"x","min"),s={x:r},a={axis:e,keepDims:n};return kt.runKernelFunc((t,s)=>{const a=U(e,r.shape);let o=a;const i=Ht(o,r.rank);let l=r;null!=i&&(l=Kt(r,i),o=jt(o.length,r.rank));const u=t.min(l,o);null!=i&&l.dispose();let c=u;if(n){const t=Gt(c.shape,a);c=qt(u,t),u.dispose()}return s([r,c]),c},s,null,"Min",a)}});mt.prototype.min=function(t,e){return this.throwIfDisposed(),Yt(this,t,e)};const Qt=_t({max_:function(t,e=null,n=!1){const r=Ft(t,"x","max"),s={x:r},a={reductionIndices:e,keepDims:n};return kt.runKernelFunc((t,s)=>{let a=U(e,r.shape);const o=Ht(a,r.rank);let i=r;null!=o&&(i=Kt(r,o),a=jt(a.length,i.rank));const l=t.max(i,a);null!=o&&i.dispose();let u=l;if(n){const t=Gt(u.shape,U(e,r.shape));u=qt(u,t),l.dispose()}return s([r,u]),u},s,null,"Max",a)}});mt.prototype.max=function(t,e){return this.throwIfDisposed(),Qt(this,t,e)};const Zt=_t({cast_:function(t,e){const n=Ft(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error("Failed to cast to unknown dtype "+e);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return kt.runKernelFunc(t=>t.cast(n,e),r,null,"Cast",s)}});function Jt(t,e,n,r,s,a,o=!1,i="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,h]=t;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);[l,h,u,c]=t}const[d,p,,f]=e,[g,m]=ne(n),[x,v]=ne(r),y=se(d,x),C=se(p,v),{padInfo:b,outHeight:w,outWidth:$}=function(t,e,n,r,s,a,o,i,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=ee(t,e,n));const a=t[0],o=t[1],i=ae((a-e+2*r)/n+1,s);N(M(i),()=>`The output # of rows (${i}) must be an integer. Change the stride and/or zero pad parameters`);const l=ae((o-e+2*r)/n+1,s);return N(M(l),()=>`The output # of columns (${l}) must be an integer. Change the stride and/or zero pad parameters`),[i,l]}([e,n],a,r,t,i);c=s[0],h=s[1]}else if("same"===t){c=Math.ceil(e/r),h=Math.ceil(n/s);const t=Math.max(0,(c-1)*r+a-e),i=Math.max(0,(h-1)*s+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(i/2);u={top:l,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),h=Math.ceil((n-o+1)/s);else{if("object"!=typeof t)throw Error("Unknown padding parameter: "+t);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=ae((e-a+d+p)/r+1,i),h=ae((n-o+f+g)/s+1,i)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,g,m,y,C,a,i),R=o?f*h:f;let I;return"channelsFirst"===i?I=[l,R,w,$]:"channelsLast"===i&&(I=[l,w,$,R]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:h,outHeight:w,outWidth:$,outChannels:R,padInfo:b,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:C,dilationHeight:x,dilationWidth:v,inShape:t,outShape:I,filterShape:e}}function te(t,e,n,r,s,a=!1,o="channelsLast",i){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);[l,d,u,c,h]=t}const[p,f,g,,m]=e,[x,v,y]=re(n),[C,b,w]=re(r),$=se(p,C),R=se(f,b),I=se(g,w),{padInfo:E,outDepth:A,outHeight:T,outWidth:S}=function(t,e,n,r,s,a,o,i,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const a=function(t,e,n,r,s,a){null==s&&(s=ee(t,e,r));const o=t[0],i=t[1],l=t[2],u=ae((o-e+2*s)/r+1,a);N(M(u),()=>`The output # of depths (${u}) must be an integer. Change the stride and/or zero pad parameters`);const c=ae((i-e+2*s)/r+1,a);N(M(c),()=>`The output # of rows (${c}) must be an integer. Change the stride and/or zero pad parameters`);const h=ae((l-e+2*s)/r+1,a);return N(M(h),()=>`The output # of columns (${h}) must be an integer. Change the stride and/or zero pad parameters`),[u,c,h,n]}([e,n,r,1],i,1,s,t,c);d=a[0],p=a[1],f=a[2]}else if("same"===t){d=Math.ceil(e/s),p=Math.ceil(n/a),f=Math.ceil(r/o);const t=(d-1)*s+i-e,c=(p-1)*a+l-n,g=(f-1)*o+u-r,m=Math.floor(t/2),x=t-m,v=Math.floor(c/2),y=c-v,C=Math.floor(g/2);h={top:v,bottom:y,left:C,right:g-C,front:m,back:x,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-i+1)/s),p=Math.ceil((n-l+1)/a),f=Math.ceil((r-u+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,x,v,y,$,R,I,i),k=a?m*d:m;let O;return"channelsFirst"===o?O=[l,k,A,T,S]:"channelsLast"===o&&(O=[l,A,T,S,k]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:A,outHeight:T,outWidth:S,outChannels:k,padInfo:E,strideDepth:x,strideHeight:v,strideWidth:y,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:$,effectiveFilterHeight:R,effectiveFilterWidth:I,dilationDepth:C,dilationHeight:b,dilationWidth:w,inShape:t,outShape:O,filterShape:e}}function ee(t,e,n,r=1){const s=se(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function ne(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function re(t){return"number"==typeof t?[t,t,t]:t}function se(t,e){return e<=1?t:t+(t-1)*(e-1)}function ae(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function oe(t){const[e,n,r]=ne(t);return 1===e&&1===n&&1===r}function ie(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat "+t)}function le(){return kt}function ue(t,e){return kt.tidy(t,e)}function ce(t){At(t).forEach(t=>t.dispose())}function he(t,e,n=1){return kt.registerBackend(t,e,n)}function de(t,e){const n=t[0].length;t.forEach((t,e)=>{N(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),N(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((t,s)=>{for(let a=0;a<n;a++)N(a===e||t[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function pe(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}function fe(t,e,n,r){if(null==r&&(r=K(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!X(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){st(e);const t=_(e),r=_(n);N(t===r,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`);for(let t=0;t<n.length;++t){const r=n[t],s=t!==n.length-1||r!==_(e.slice(t));N(n[t]===e[t]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return X(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?J(t,r):D(t,[],!0),kt.makeTensor(t,e,r)}function ge(t,e,n){return fe(t,e,Nt(t,n),n)}const me=_t({concat_:function(t,e=0){N(t.length>=1,()=>"Pass at least one tensor to concat");let n=Dt(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)});const r=U(e,n[0].shape)[0],s=pe(n.map(t=>t.shape),r);if(0===_(s))return ge([],s);if(n=n.filter(t=>t.size>0),1===n.length)return n[0];de(n.map(t=>t.shape),r);const a=n,o={axis:e};return kt.runKernelFunc((t,e)=>{const s=t.concat(n,r);return e(n),s},a,null,"Concat",o)}});function xe(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function ve(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function ye(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Ce(t,e="float32",n){return e=e||"float32",st(t),new ft(t,e,n)}const be=_t({complex_:function(t,e){const n=Ft(t,"real","complex"),r=Ft(e,"imag","complex");O(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return kt.runKernelFunc(t=>t.complex(n,r),s,null,"Complex")}});const we=_t({floorDiv_:function(t,e){let n=Ft(t,"a","floorDiv"),r=Ft(e,"b","floorDiv");[n,r]=Et(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.floorDiv(n,r);return e([n,r]),s},s,null,"FloorDiv")}});const $e=_t({div_:function(t,e){let n=Ft(t,"a","div"),r=Ft(e,"b","div");if([n,r]=Et(n,r),"int32"===n.dtype&&"int32"===r.dtype)return we(n,r);const s={a:n,b:r};return kt.runKernelFunc((t,e)=>{const s=t.realDivide(n,r);return e([n,r]),s},s,null,"Div",{})}});function Re(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,o=t[a]||1;(e[e.length-1-s]||1)>1&&1===o&&r.unshift(a)}return r}function Ie(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],a=e.length-r-1,o=e[a];(null==s||1===s&&o>1)&&n.unshift(a)}return n}function Ee(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let a=e[e.length-s-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(r)}}return n}const Ae=_t({where_:function(t,e,n){const r=Ft(e,"a","where"),s=Ft(n,"b","where"),a=Ft(t,"condition","where","bool"),o=Ee(r.shape,s.shape),i=r.broadcastTo(o),l=s.broadcastTo(o);1===a.rank&&N(a.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==a.rank&&O(a.shape,l.shape,"Error in where: ");const u={condition:a,t:i,e:l};return kt.runKernelFunc((t,e)=>{const n=t.select(a,i,l);return e([a]),n},u,null,"SelectV2")}});const Te=_t({zerosLike_:function(t){const e=Ft(t,"x","zerosLike"),n={x:e};return kt.runKernelFunc(t=>t.zerosLike(e),n,null,"ZerosLike")}});const Se=_t({elu_:function(t){const e=Ft(t,"x","elu"),n={x:e};return kt.runKernelFunc((t,n)=>{const r=t.elu(e);return n([r]),r},n,null,"Elu")}});const ke=_t({equal_:function(t,e){let n=Ft(t,"a","equal"),r=Ft(e,"b","equal");[n,r]=Et(n,r),Ee(n.shape,r.shape);const s={a:n,b:r};return kt.runKernelFunc(t=>t.equal(n,r),s,null,"Equal")}});const Ne=_t({expandDims_:function(t,e=0){const n=Ft(t,"x","expandDims",null);N(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r=n.shape.slice();return e<0&&(N(-(n.rank+1)<=e,()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`),e=n.rank+e+1),r.splice(e,0,1),qt(n,r)}});function Oe(t){return t<=30?t:Q(t,Math.floor(Math.sqrt(t)))}var Fe=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:function(t,e){let n,r=!1;for(t<=30?(n=t,r=!0):n=Q(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=Q(t,n+1);return n},computeOutShape:function(t,e,n){const r=[],s=t.length;for(let a=0;a<s;a++)a!==e?r.push(t[a]):r.push(n);return r},collectGatherOpShapeInfo:function(t,e,n){const r=t.shape[n],s=[];let a=1,o=1;for(let e=0;e<n;e++)s.push(t.shape[e]),a*=t.shape[e];for(let t=0;t<e.rank;t++)s.push(e.shape[t]);for(let e=n+1;e<t.rank;e++)s.push(t.shape[e]),o*=t.shape[e];return{batchSize:a,sliceSize:o,dimSize:r,outputShape:s}}});const De=_t({greater_:function(t,e){let n=Ft(t,"a","greater"),r=Ft(e,"b","greater");[n,r]=Et(n,r),Ee(n.shape,r.shape);const s={a:n,b:r};return kt.runKernelFunc(t=>t.greater(n,r),s,null,"Greater")}});const _e=_t({imag_:function(t){const e=Ft(t,"input","imag"),n={input:e};return kt.runKernelFunc(t=>t.imag(e),n,null,"Imag")}});const Be=_t({real_:function(t){const e=Ft(t,"input","real"),n={input:e};return kt.runKernelFunc(t=>t.real(e),n,null,"Real")}});function Me(t,e){if((X(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&X(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return fe(t,[],[],e)}const Pe=_t({log_:function(t){const e=Ft(t,"x","log"),n={x:e};return kt.runKernelFunc((t,n)=>{const r=t.log(e);return n([e]),r},n,null,"Log")}});const Le=_t({neg_:function(t){const e=Ft(t,"x","neg"),n={x:e};return kt.runKernelFunc(t=>t.neg(e),n,null,"Negate")}});const We=_t({sum_:function(t,e=null,n=!1){let r=Ft(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());const s={x:r},a={axis:e,keepDims:n};return kt.runKernelFunc((t,s)=>{s([r]);const a=U(e,r.shape),o=Ht(a,r.rank);let i=a,l=r;null!=o&&(l=r.transpose(o),i=jt(i.length,r.rank));let u=t.sum(l,i);if(n){const t=Gt(u.shape,a);u=u.reshape(t)}return u},s,null,"Sum",a)}});function Ve(t,e="float32"){if("complex64"===e){const e=Ve(t,"float32"),n=Ve(t,"float32");return be(e,n)}const n=nt(_(t),e);return kt.makeTensor(n,t,e)}function Ue(t,e="float32"){if("complex64"===e){const e=Ue(t,"float32"),n=Ve(t,"float32");return be(e,n)}const n=et(_(t),e);return kt.makeTensor(n,t,e)}const Ge=_t({mean_:function(t,e=null,n=!1){const r=Ft(t,"x","mean"),s=U(e,r.shape),a=_(Ut(r.shape,s)[1]);var o;return(o=t=>{const r=Me(a),o=r.dtype===t.dtype?t:Zt(t,r.dtype),i=$e(o,r);return{value:We(i,e,n),gradFunc:e=>{const n=t.shape.slice();s.forEach(t=>{n[t]=1});const r=qt(e,n);return $e(Pt(r,Ue(t.shape,"float32")),a)}}},kt.customGrad(o))(r)}});const ze=_t({square_:function(t){const e=Ft(t,"x","square"),n=[e];return kt.runKernelFunc((t,n)=>(n([e]),t.square(e)),{x:e},null,"Square",{},n,[])}});const He=_t({prelu_:function(t,e){const n=Ft(t,"x","prelu"),r=Ft(e,"alpha","prelu"),s={x:n,alpha:r};return kt.runKernelFunc((t,e)=>{const s=t.prelu(n,r);return e([n,r]),s},s,null,"Prelu")}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Xe(t,e,n){return t(n={path:e,exports:{},require:function(t,e){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==e&&n.path)}},n.exports),n.exports}var je=Xe((function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function s(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,a&&("object"==typeof a&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.alea=a}(0,t,!1)})),qe=Xe((function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function s(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,a&&("object"==typeof a&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor128=a}(0,t,!1)})),Ke=Xe((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function s(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,a&&("object"==typeof a&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorwow=a}(0,t,!1)})),Ye=Xe((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function s(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,a&&(a.x&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xorshift7=a}(0,t,!1)})),Qe=Xe((function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,a=e.i;return e.w=r=r+1640531527|0,n=s[a+34&127],t=s[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,s,a,o,i=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,a=-32;a<l;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(o=o+1640531527|0,s=0==(n=i[127&a]^=r+o)?s+1:0);for(s>=128&&(i[127&(e&&e.length||0)]=-1),s=127,a=512;a>0;--a)r=i[s+34&127],n=i[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[s]=r^n;t.w=o,t.X=i,t.i=s}(e,t)}function s(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,a&&(a.X&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.xor4096=a}(0,t,!1)})),Ze=Xe((function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function s(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=n.next,o.quick=o,a&&("object"==typeof a&&s(a,n),o.state=function(){return s(n,{})}),o}e&&e.exports?e.exports=a:n&&n.amd?n((function(){return a})):this.tychei=a}(0,t,!1)})),Je=Xe((function(e){!function(n,r){var s,a=this,o=r.pow(256,6),i=r.pow(2,52),l=2*i;function u(t,e,u){var f=[],g=d(function t(e,n){var r,s=[],a=typeof e;if(n&&"object"==a)for(r in e)try{s.push(t(e[r],n-1))}catch(t){}return s.length?s:"string"==a?e:e+"\0"}((e=1==e?{entropy:!0}:e||{}).entropy?[t,p(n)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(256):(t=new Uint8Array(256),(a.crypto||a.msCrypto).getRandomValues(t)),p(t)}catch(t){var e=a.navigator,r=e&&e.plugins;return[+new Date,a,r,a.screen,p(n)]}}():t,3),f),m=new c(f),x=function(){for(var t=m.g(6),e=o,n=0;t<i;)t=256*(t+n),e*=256,n=m.g(1);for(;t>=l;)t/=2,e/=2,n>>>=1;return(t+n)/e};return x.int32=function(){return 0|m.g(4)},x.quick=function(){return m.g(4)/4294967296},x.double=x,d(p(m.S),n),(e.pass||u||function(t,e,n,s){return s&&(s.S&&h(s,m),t.state=function(){return h(m,{})}),n?(r.random=t,e):t})(x,g,"global"in e?e.global:this==r,e.state)}function c(t){var e,n=t.length,r=this,s=0,a=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);s<256;)o[s]=s++;for(s=0;s<256;s++)o[s]=o[a=255&a+t[s%n]+(e=o[s])],o[a]=e;(r.g=function(t){for(var e,n=0,s=r.i,a=r.j,o=r.S;t--;)e=o[s=255&s+1],n=256*n+o[255&(o[s]=o[a=255&a+e])+(o[a]=e)];return r.i=s,r.j=a,n})(256)}function h(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function d(t,e){for(var n,r=t+"",s=0;s<r.length;)e[255&s]=255&(n^=19*e[255&s])+r.charCodeAt(s++);return p(e)}function p(t){return String.fromCharCode.apply(0,t)}if(r.seedrandom=u,d(r.random(),n),e.exports){e.exports=u;try{s=t}catch(t){}}}([],Math)}));Je.alea=je,Je.xor128=qe,Je.xorwow=Ke,Je.xorshift7=Ye,Je.xor4096=Qe,Je.tychei=Ze;var tn=Je;class en{constructor(t,e,n,r,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=tn.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const o=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*s*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class nn{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=tn.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const rn=_t({randomNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);const a=new en(e,n,r,!1,s),o=Ce(t,r);for(let t=0;t<o.values.length;t++)o.values[t]=a.nextValue();return o.toTensor()}});const sn=_t({randomUniform_:function(t,e=0,n=1,r="float32",s){const a=Ce(t,r),o=new nn(e,n,null,s);for(let t=0;t<a.values.length;t++)a.values[t]=o.nextValue();return a.toTensor()}});function an(t,e){F(t);const n=Nt(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return fe(t,null,n,e)}const on=_t({relu_:function(t){const e=Ft(t,"x","relu"),n={x:e};return kt.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?e.toInt():t.relu(e)),n,null,"Relu")}});const ln=_t({relu6_:function(t){const e=Ft(t,"x","relu6"),n={x:e};return kt.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?Zt(e,"int32"):t.relu6(e)),n,null,"Relu6")}});const un=_t({softmax_:function(t,e=-1){const n=Ft(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return kt.runKernelFunc((t,r)=>{const s=t.softmax(n,e);return r([s]),s},r,null,"Softmax",s)}});const cn=_t({stack_:function(t,e=0){const n=Dt(t,"tensors","stack");if(N(n.length>=1,()=>"Pass at least one tensor to tf.stack"),1===n.length)return Ne(n[0],e);const r=n[0].rank,s=n[0].shape,a=n[0].dtype;N(e<=r,()=>"Axis must be <= rank of the tensor"),n.forEach(t=>{O(s,t.shape,"All tensors passed to stack must have matching shapes"),N(a===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=n.map(t=>Ne(t,e));return me(o,e)}});function hn(t,e,n){if(F(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Nt(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return fe(t,e,r,n)}function dn(t,e=!0,n,r){return kt.makeVariable(t,e,n,r)}function pn(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=Ce(t,"int32"),s=Ce([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const a=r.indexToLoc(n[e]),o=e*t.length;s.values.set(a,o)}return s.toTensor()}function fn(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${e.shape}, shape: ${t}`+`, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(a+" Output shape length < "+(r+(n.rank-s)));if(n.rank!==s+t.length-r)throw new Error(a+" update.rank != "+(s+t.length-r));for(let t=0;t<s;++t)if(n.shape[t]!==e.shape[t])throw new Error(a+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-s;++e)if(n.shape[e+s]!==t[e+r])throw new Error(a+` updates.shape[${e+s}] (${n.shape[e+s]}) != shape[${e+s}] (${t[e+s]})`)}function gn(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=n.length;let o=1;for(let t=s;t<a;++t)o*=n[t];const i=s<1?1:s;return{sliceRank:s,numUpdates:_(e.shape)/i,sliceSize:o,strides:[...Z(n.slice(0,s)),1],outputSize:_(n)}}function mn(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=n(e,t[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}(t,e,n||xn)}(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function xn(t,e){return t>e?1:t<e?-1:0}function vn(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(i-a)*(l-o),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(a,u),m=Math.max(o,c),x=Math.min(i,h),v=Math.min(l,d),y=Math.max(x-g,0)*Math.max(v-m,0);return y/(p+f-y)}function yn(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Cn(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}function bn(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let s=1;for(let t=0;t<n.length-1;++t)s*=n[t];const a=t.shape,o=n.slice();o.pop();let i=1;for(let e=r;e<t.rank;++e)i*=a[e],o.push(a[e]);const l=[...Z(t.shape).map(t=>t/i),1].slice(0,r);return[o,s,i,l]}mt.prototype.cast=function(t){return this.throwIfDisposed(),Zt(this,t)},mt.prototype.square=function(){return this.throwIfDisposed(),ze(this)},mt.prototype.div=function(t){return this.throwIfDisposed(),$e(this,t)},mt.prototype.mean=function(t,e){return this.throwIfDisposed(),Ge(this,t,e)},mt.prototype.toFloat=function(){return this.throwIfDisposed(),Zt(this,"float32")},mt.prototype.reshape=function(t){return this.throwIfDisposed(),qt(this,t)},mt.prototype.sum=function(t,e){return this.throwIfDisposed(),We(this,t,e)};class wn{constructor(){this.classNameMap={}}static getMap(){return null==wn.instance&&(wn.instance=new wn),wn.instance}static register(t){wn.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function $n(t){N(null!=t.className,()=>"Class being registered does not have the static className property defined."),N("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),N(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),wn.register(t)}class Rn extends class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}{minimize(t,e=!1,n){const{value:r,grads:s}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:s[t.name]}));this.applyGradients(t)}else this.applyGradients(s);return ce(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){N(Y(t),()=>"The f passed in variableGrads(f) must be a function"),N(null==e||Array.isArray(e)&&e.every(t=>t instanceof xt),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in kt.registeredVariables)e.push(kt.registeredVariables[t])}const r=n?e.filter(t=>!t.trainable):null,s=e.length;N((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:a,grads:o}=kt.gradients(t,e,null,!0);N(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),N(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const i={};return e.forEach((t,e)=>{null!=o[e]&&(i[t.name]=o[e])}),null!=r&&r.forEach(t=>i[t.name]=null),{value:a,grads:i}}(t,e)}dispose(){null!=this.iterations_&&ce(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Rn,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class In extends Rn{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=kt.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=kt.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:e+"/accum_grad",variable:ue(()=>Te(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:e+"/accum_var",variable:ue(()=>Te(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const a=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ue(()=>{const t=a.mul(this.rho).add(s.square().mul(1-this.rho)),e=o.add(this.epsilon).sqrt().div(a.add(this.epsilon).sqrt()).mul(s),n=o.mul(this.rho).add(e.square().mul(1-this.rho));a.assign(t),o.assign(n);const i=e.mul(-this.learningRate).add(r);r.assign(i)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ce(this.accumulatedGrads.map(t=>t.variable)),ce(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}In.className="Adadelta",$n(In);class En extends Rn{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=kt.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:e+"/accumulator",variable:ue(()=>function(t,e,n){const r={shape:t,value:e,dtype:n};return kt.runKernelFunc(r=>r.fill(t,e,n),{},null,"Fill",r)}(r.shape,this.initialAccumulatorValue).variable(t))}}const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const a=this.accumulatedGrads[n].variable;ue(()=>{const t=a.add(s.square());a.assign(t);const e=s.div(t.add(kt.backend.epsilon()).sqrt()).mul(-this.learningRate).add(r);r.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ce(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}En.className="Adagrad",$n(En);class An extends Rn{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ue(()=>{this.accBeta1=Me(e).variable(),this.accBeta2=Me(n).variable()}),null==r&&(this.epsilon=kt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);ue(()=>{const n=Lt(1,this.accBeta1),r=Lt(1,this.accBeta2);e.forEach((e,s)=>{const a=kt.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:ue(()=>Te(a).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:e+"/v",variable:ue(()=>Te(a).variable(!1))});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=i.mul(this.beta1).add(o.mul(1-this.beta1)),c=l.mul(this.beta2).add(o.square().mul(1-this.beta2)),h=u.div(n),d=c.div(r);i.assign(u),l.assign(c);const p=h.div(d.sqrt().add(this.epsilon)).mul(-this.learningRate).add(a);a.assign(p)}),this.accBeta1.assign(this.accBeta1.mul(this.beta1)),this.accBeta2.assign(this.accBeta2.mul(this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ce(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&ce(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),ue(()=>{this.accBeta1.assign(Bt(this.beta1,this.iterations_+1)),this.accBeta2.assign(Bt(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}An.className="Adam",$n(An);class Tn extends Rn{constructor(t,e,n,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ue(()=>{this.iteration=Me(0).variable(),this.accBeta1=Me(e).variable()}),null==r&&(this.epsilon=kt.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);ue(()=>{const n=Lt(1,this.accBeta1),r=$e(-this.learningRate,this.iteration.mul(this.decay).add(1));e.forEach((e,s)=>{const a=kt.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:Te(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:e+"/v",variable:Te(a).variable(!1)});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const i=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=i.mul(this.beta1).add(o.mul(1-this.beta1)),c=l.mul(this.beta2),h=o.abs(),d=c.maximum(h);i.assign(u),l.assign(d);const p=r.div(n).mul(u.div(d.add(this.epsilon))).add(a);a.assign(p)}),this.iteration.assign(this.iteration.add(1)),this.accBeta1.assign(this.accBeta1.mul(this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ce(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&ce(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Tn.className="Adamax",$n(Tn);class Sn extends Rn{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=kt.registeredVariables[e];ue(()=>{const t=this.c.mul(r).add(s);s.assign(t)})}),this.incrementIterations()}setLearningRate(t){var e;this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=(e=Me(-t),kt.keep(e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Sn.className="SGD",$n(Sn);class kn extends Sn{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Me(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=kt.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:e+"/momentum",variable:ue(()=>Te(r).variable(t))}}const s=this.accumulations[n].variable,a=Array.isArray(t)?t[n].tensor:t[e];null!=a&&ue(()=>{let t;const e=this.m.mul(s).add(a);t=this.useNesterov?this.c.mul(a.add(e.mul(this.m))).add(r):this.c.mul(e).add(r),s.assign(e),r.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ce(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}kn.className="Momentum",$n(kn);class Nn extends Rn{constructor(t,e=.9,n=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=kt.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=kt.registeredVariables[e];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:e+"/rms",variable:ue(()=>Te(r).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:e+"/momentum",variable:ue(()=>Te(r).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:e+"/mg",variable:ue(()=>Te(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ue(()=>{const t=a.mul(this.decay).add(s.square().mul(1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,i=e.mul(this.decay).add(s.mul(1-this.decay)),l=o.mul(this.momentum).add(s.mul(this.learningRate).div(t.sub(i.square().add(this.epsilon)).sqrt()));a.assign(t),e.assign(i),o.assign(l);const u=r.sub(l);r.assign(u)}else{const t=a.mul(this.decay).add(s.square().mul(1-this.decay)),e=o.mul(this.momentum).add(s.mul(this.learningRate).div(t.add(this.epsilon).sqrt()));a.assign(t),o.assign(e);const n=r.sub(e);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ce(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ce(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&ce(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Nn.className="RMSProp",$n(Nn);class On{static sgd(t){return new Sn(t)}static momentum(t,e,n=!1){return new kn(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,s=!1){return new Nn(t,e,n,r,s)}static adam(t=.001,e=.9,n=.999,r=null){return new An(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new In(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,s=0){return new Tn(t,e,n,r,s)}static adagrad(t,e=.1){return new En(t,e)}}const Fn={sgd:On.sgd,momentum:On.momentum,adadelta:On.adadelta,adagrad:On.adagrad,rmsprop:On.rmsprop,adamax:On.adamax,adam:On.adam},Dn="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function _n(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)s=s.concat([t[r+1]/e[r],e[r]]);s=s.concat(t.slice(n+1))}return s}function Bn(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function Mn(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?s.push(e[n-1]*t[n]):s.push(t[n]/e[n-1]):s.push(t[n]);return s}function Pn(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function Ln(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}function Wn(...t){v().getBool("IS_TEST")||console.warn(...t)}function Vn(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function Un(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function Gn(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function zn(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function Hn(t,e){return{real:t[2*e],imag:t[2*e+1]}}function Xn(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function jn(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const a=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function qn(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function Kn(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=Ve(t.shape),r=t.toFloat(),s=n.complex(r,e);return e.dispose(),r.dispose(),s}if(r=t.dtype,"complex64"===(s=e)||"float32"===s&&"complex64"!==r||"int32"===s&&"float32"!==r&&"complex64"!==r||"bool"===s&&"bool"===r)return kt.makeTensorFromDataId(t.dataId,t.shape,e);var r,s;if("complex64"===t.dtype){const r=n.real(t),s=r.cast(e);return r.dispose(),s}if("int32"===e)return n.int(t);if("bool"===e){const e=Me(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function Yn(t,e){return kt.makeTensorFromDataId(t.dataId,e,t.dtype)}function Qn(t,e,n){const r=(e-t)/(n-1),s=nt(n,"float32");s[0]=t;for(let t=1;t<s.length;t++)s[t]=s[t-1]+r;return an(s,"float32")}var Zn=Object.freeze({__proto__:null,segment_util:Fe,castTensor:Kn,reshapeTensor:Yn,linspaceImpl:Qn,upcastType:Rt,axesAreInnerMostDims:Wt,combineLocations:Vt,computeOutAndReduceShapes:Ut,expandShapeToKeepDim:Gt,assertAxesAreInnerMostDims:zt,getAxesPermutation:Ht,getUndoAxesPermutation:Xt,getInnerMostAxes:jt,getBroadcastDims:Re,getReductionAxes:Ie,assertAndGetBroadcastShape:Ee,assertParamsConsistent:de,computeOutShape:pe,computeDilation2DInfo:function(t,e,n,r,s="NHWC",a){return Jt(t,[...e,t[3]],n,a,r,null,null,ie(s))},computePool2DInfo:function(t,e,n,r,s,a,o="channelsLast"){const[i,l]=ne(e);let u;if("channelsLast"===o)u=[i,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);u=[i,l,t[1],t[1]]}return Jt(t,u,n,r,s,a,!1,o)},computePool3DInfo:function(t,e,n,r,s,a,o="NDHWC"){const[i,l,u]=re(e);let c,h;if("NDHWC"===o)h="channelsLast",c=[i,l,u,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat "+o);h="channelsFirst",c=[i,l,u,t[1],t[1]]}return te(t,c,n,r,s,!1,h,a)},computeConv2DInfo:Jt,computeConv3DInfo:te,computeDefaultPad:ee,tupleValuesAreOne:oe,eitherStridesOrDilationsAreOne:function(t,e){return oe(t)||oe(e)},convertConv2DDataFormat:ie,getFusedDyActivation:function(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return t.mul(e.step());throw new Error(`Cannot compute gradient for fused activation ${n}.`)},getFusedBiasGradient:function(t,e){let n=e;const r=Ie(t.shape,e.shape);return r.length>0&&(n=n.sum(r)),n.reshape(t.shape)},applyActivation:function(t,e,n){if("linear"===e)return t;if("relu"===e)return on(t);if("elu"===e)return Se(t);if("relu6"===e)return ln(t);if("prelu"===e)return He(t,n);throw new Error(`Unknown fused activation ${e}.`)},shouldFuse:(t,e)=>!(t>0)||"linear"===e,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:Oe,getImageCenter:function(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]},getReshaped:_n,getPermuted:Bn,getReshapedPermuted:Mn,getSliceBeginCoords:Pn,getSliceSize:Ln,prepareAndValidate:bn,validateUpdateShape:fn,validateInput:function(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}fn(n,e,t)},calculateShapes:gn,SELU_SCALEALPHA:1.7580993408473768,SELU_SCALE:1.0507009873554805,ERF_P:.3275911,ERF_A1:.254829592,ERF_A2:-.284496736,ERF_A3:1.421413741,ERF_A4:-1.453152027,ERF_A5:1.061405429,warn:Wn,log:function(...t){v().getBool("IS_TEST")||console.log(...t)},mergeRealAndImagArrays:Vn,splitRealAndImagArrays:Un,complexWithEvenIndex:Gn,complexWithOddIndex:zn,getComplexWithIndex:Hn,assignToTypedArray:Xn,exponents:jn,exponent:qn,prepareSplitSize:function(t,e,n=0){let r=[];if("number"==typeof e)N(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{N(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(-1!==s){const r=e.reduce((t,e)=>e>0?t+e:t);e[s]=t.shape[n]-r}N(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}});function Jn(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function tr(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}function er(t,e,n){const r=new Array(t.rank).fill(0),s=t.shape.slice();return e.map(e=>{const a=[...s];a[n]=e;const o=t.slice(r,a);return r[n]+=e,o})}function nr(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const r=Ce(n,t.dtype);for(let e=0;e<r.values.length;++e){const n=r.indexToLoc(e),s=new Array(t.rank);for(let e=0;e<s.length;e++)s[e]=n[e]%t.shape[e];const a=t.locToIndex(s);r.values[e]=t.values[a]}return r.toTensor()}function rr(t,e,n,r,s){const a=e[e.length-1],[o,i]=[t.length/a,a],l=z(n,o*r),u=z("int32",o*r);for(let e=0;e<o;e++){const n=e*i,s=t.subarray(n,n+i),a=[];for(let t=0;t<s.length;t++)a.push({value:s[t],index:t});a.sort((t,e)=>e.value-t.value);const o=e*r,c=l.subarray(o,o+r),h=u.subarray(o,o+r);for(let t=0;t<r;t++)c[t]=a[t].value,h[t]=a[t].index}const c=e.slice();return c[c.length-1]=r,[ge(l,c,n),ge(u,c,"int32")]}class sr{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class ar{time(t){return or("time")}read(t){return or("read")}readSync(t){return or("readSync")}numDataIds(){return or("numDataIds")}disposeData(t){return or("disposeData")}write(t,e,n){return or("write")}move(t,e,n,r){return or("move")}memory(){return or("memory")}floatPrecision(){return or("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return or("batchMatMul")}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:o}){return or("fusedBatchMatMul")}slice(t,e,n){return or("slice")}stridedSlice(t,e,n,r){return or("stridedSlice")}unstack(t,e){return or("unstack")}reverse(t,e){return or("reverse")}concat(t,e){return or("concat")}neg(t){return or("neg")}add(t,e){return or("add")}addN(t){return or("addN")}subtract(t,e){return or("subtract")}multiply(t,e){return or("multiply")}realDivide(t,e){return or("realDivide")}floorDiv(t,e){return or("floorDiv")}sum(t,e){return or("sum")}prod(t,e){return or("prod")}unsortedSegmentSum(t,e,n){return or("unsortedSegmentSum")}argMin(t,e){return or("argMin")}argMax(t,e){return or("argMax")}equal(t,e){return or("equal")}notEqual(t,e){return or("notEqual")}less(t,e){return or("less")}lessEqual(t,e){return or("lessEqual")}greater(t,e){return or("greater")}greaterEqual(t,e){return or("greaterEqual")}logicalNot(t){return or("logicalNot")}logicalAnd(t,e){return or("logicalAnd")}logicalOr(t,e){return or("logicalOr")}where(t){return or("where")}select(t,e,n){return or("select")}topk(t,e,n){return or("topk")}min(t,e){return or("min")}minimum(t,e){return or("minimum")}mod(t,e){return or("mod")}max(t,e){return or("max")}maximum(t,e){return or("maximum")}all(t,e){return or("all")}any(t,e){return or("any")}squaredDifference(t,e){return or("squaredDifference")}ceil(t){return or("ceil")}floor(t){return or("floor")}round(t){return or("round")}sign(t){return or("sign")}isNaN(t){return or("isNaN")}isInf(t){return or("isInf")}isFinite(t){return or("isFinite")}pow(t,e){return or("pow")}exp(t){return or("exp")}expm1(t){return or("expm1")}softmax(t,e){return or("softmax")}log(t){return or("log")}log1p(t){return or("log1p")}sqrt(t){return or("sqrt")}rsqrt(t){return or("rsqrt")}square(t){return or("square")}reciprocal(t){return or("reciprocal")}relu(t){return or("relu")}relu6(t){return or("relu6")}prelu(t,e){return or("prelu")}elu(t){return or("elu")}eluDer(t,e){return or("eluDer")}selu(t){return or("selu")}int(t){return or("int")}clip(t,e,n){return or("clip")}abs(t){return or("abs")}complexAbs(t){return or("complexAbs")}sigmoid(t){return or("sigmoid")}softplus(t){return or("softplus")}sin(t){return or("sin")}cos(t){return or("cos")}tan(t){return or("tan")}asin(t){return or("asin")}acos(t){return or("acos")}atan(t){return or("atan")}atan2(t,e){return or("atan2")}sinh(t){return or("sinh")}cosh(t){return or("cosh")}tanh(t){return or("tanh")}asinh(t){return or("asinh")}acosh(t){return or("acosh")}atanh(t){return or("atanh")}erf(t){return or("erf")}step(t,e){return or("step")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){return or("fusedConv2d")}conv2d(t,e,n){return or("conv2d")}conv2dDerInput(t,e,n){return or("conv2dDerInput")}conv2dDerFilter(t,e,n){return or("conv2dDerFilter")}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){return or("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return or("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return or("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return or("depthwiseConv2DDerFilter")}conv3d(t,e,n){return or("conv3d")}conv3dDerInput(t,e,n){return or("conv3dDerInput")}conv3dDerFilter(t,e,n){return or("conv3dDerFilter")}maxPool(t,e){return or("maxPool")}maxPoolBackprop(t,e,n,r){return or("maxPoolBackprop")}avgPool(t,e){return or("avgPool")}avgPoolBackprop(t,e,n){return or("avgPoolBackprop")}avgPool3d(t,e){return or("avgPool3d")}avgPool3dBackprop(t,e,n){return or("avgPool3dBackprop")}maxPool3d(t,e){return or("maxPool3d")}maxPool3dBackprop(t,e,n,r){return or("maxPool3dBackprop")}reshape(t,e){return or("reshape")}cast(t,e){return or("cast")}tile(t,e){return or("tile")}pad(t,e,n){return or("pad")}transpose(t,e){return or("transpose")}gather(t,e,n){return or("gather")}gatherND(t,e){return or("gatherND")}scatterND(t,e,n){return or("scatterND")}batchToSpaceND(t,e,n){return or("batchToSpaceND")}spaceToBatchND(t,e,n){return or("spaceToBatchND")}resizeBilinear(t,e,n,r){return or("resizeBilinear")}resizeBilinearBackprop(t,e,n){return or("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return or("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return or("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,s,a){return or("batchNorm")}localResponseNormalization4D(t,e,n,r,s){return or("localResponseNormalization4D")}LRNGrad(t,e,n,r,s,a,o){return or("LRNGrad")}multinomial(t,e,n,r){return or("multinomial")}oneHot(t,e,n,r){return or("oneHot")}cumsum(t,e,n,r){return or("cumsum")}nonMaxSuppression(t,e,n,r,s){return or("nonMaxSuppression")}fft(t){return or("fft")}ifft(t){return or("ifft")}complex(t,e){return or("complex")}real(t){return or("real")}imag(t){return or("imag")}cropAndResize(t,e,n,r,s,a){return or("cropAndResize")}depthToSpace(t,e,n){return or("depthToSpace")}split(t,e,n){return or("split")}sparseToDense(t,e,n,r){return or("sparseToDense")}diag(t){return or("diag")}fill(t,e,n){return or("fill")}onesLike(t){return or("onesLike")}zerosLike(t){return or("zerosLike")}linspace(t,e,n){return or("linspace")}dispose(){return or("dispose")}}function or(t){throw new Error(`'${t}' not yet implemented or not found in the registry. Did you forget to import the kernel?`)}const ir=v();ir.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ir.registerFlag("IS_BROWSER",()=>tr()),ir.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ir.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ir.registerFlag("PROD",()=>!1),ir.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ir.getBool("DEBUG")),ir.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ir.registerFlag("IS_TEST",()=>!1);class lr{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}v().get("IS_BROWSER")&&v().setPlatform("browser",new lr);const ur=()=>require("node-fetch");let cr;class hr{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=v().global.fetch?v().global.fetch(t,e):(null==cr&&(cr=ur()),cr(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}function dr(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&N("complex64"!==t.dtype,()=>e+" does not support complex64 tensors in the CPU backend.")})}function pr(t,e,n,r,s,a){const o=s.strideHeight,i=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Ce(s.outShape,n),m=g.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],y=s.outShape[3];for(let e=0;e<s.batchSize;++e){const n=e*x,g=e*r[0];for(let e=0;e<s.inChannels;++e)for(let x=0;x<s.outHeight;++x){const C=x*o-d,b=Math.max(0,C),w=Math.min(s.inHeight,c+C),$=n+x*v;for(let n=0;n<s.outWidth;++n){const o=n*i-p,c=Math.max(0,o),d=Math.min(s.inWidth,h+o);let x=f,v=0,C=0;for(let n=b;n<w;n+=l){const s=g+n*r[1];for(let n=c;n<d;n+=u){const o=t[s+n*r[2]+e];"max"===a&&o>x?x=o:"avg"===a&&(v+=o,C++)}if(isNaN(x))break}m[$+n*y+e]="avg"===a?v/C:x}}}return g}v().get("IS_NODE")&&v().setPlatform("node",new hr);const fr=function(t,e,n,r,s){return function(t,e,n,r,s,a,o=!1,i=!1,l=!1){const u=[];for(let t=0;t<e.length;t++)e[t]>s&&u.push({score:e[t],boxIndex:t,suppressBeginIndex:0});u.sort(Cn);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:o}=e;if(n<s)break;let i=!1;for(let n=h.length-1;n>=o;--n){const o=vn(t,a,h[n]);if(o>=r){i=!0;break}if(e.score=e.score*yn(r,c,o),e.score<=s)break}e.suppressBeginIndex=h.length,i||(e.score===n?(h.push(a),d.push(e.score)):e.score>s&&mn(u,e,Cn))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:an(h,"int32")};o&&(g.selectedScores=an(d,"float32"));l&&(g.validOutputs=Me(p,"int32"));return g}(t,e,n,r,s,0).selectedIndices},gr=er,mr=nr,xr=rr,vr=pn;function yr(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class Cr extends ar{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new sr(this,le())}write(t,e,n){this.firstUse&&(this.firstUse=!1,v().get("IS_NODE")&&Wn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:t,dtype:n}),r}move(t,e,n,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensors:n}=this.data.get(t);if("complex64"===e){return Vn(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>at(t))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(t.shape,t.dtype,n)}makeOutput(t,e,n){const r=this.write(t,e,n);return le().makeTensorFromDataId(r,e,n,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const e=rt();t();return{kernelMs:rt()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,e){const n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:le().keep(t.clone()),imag:le().keep(e.clone())},n}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){dr(t,"slice");if(ve(t.shape,e,n)){const r=ye(e,t.strides),s=_(n);return ge(this.readSync(t.dataId).subarray(r,r+s),n,t.dtype)}const r=Ce(n,t.dtype),s=this.bufferSync(t);for(let t=0;t<r.size;++t){const n=r.indexToLoc(t).map((t,n)=>t+e[n]);r.values[t]=s.get(...n)}return r.toTensor()}stridedSlice(t,e,n,r){dr(t,"stridedSlice");const s=xe(e,n,r);if(s.some(t=>0===t))return ge([],s);const a=Ce(s,t.dtype),o=this.bufferSync(t);for(let t=0;t<a.size;t++){const n=a.indexToLoc(t),s=new Array(n.length);for(let t=0;t<s.length;t++)s[t]=n[t]*r[t]+e[t];a.set(o.get(...s),...n)}return a.toTensor()}diag(t){const e=this.readSync(t.dataId),n=Ce([t.size,t.size],t.dtype),r=n.values;for(let n=0;n<e.length;n++)r[n*t.size+n]=e[n];return n.toTensor()}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let n=0;n<t.rank;n++)n!==e&&(r[s++]=t.shape[n]);const a=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const i=new Array(n);for(let n=0;n<i.length;n++)a[e]=n,i[n]=this.slice(t,a,o).reshape(r);return i}reverse(t,e){dr(t,"reverse");const n=Ce(t.shape,t.dtype),r=this.bufferSync(t);for(let s=0;s<n.size;s++){const a=n.indexToLoc(s),o=a.slice();e.forEach(e=>o[e]=t.shape[e]-1-o[e]),n.set(r.get(...o),...a)}return n.toTensor()}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Be(t)),r=t.map(t=>_e(t));return be(this.concat(n,e),this.concat(r,e))}const n=t.map(t=>{const n=_(t.shape.slice(e));return t.as2D(-1,n)}),r=pe(n.map(t=>t.shape),1),s=Ce(r,t[0].dtype).values;if(1===n[0].shape[0]){let t=0;n.forEach(e=>{s.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;n.forEach(e=>{const n=this.readSync(e.dataId);let a=0;for(let o=0;o<e.shape[0];++o){const i=o*r[1]+t;for(let t=0;t<e.shape[1];++t)s[i+t]=n[a++]}t+=e.shape[1]})}const a=pe(t.map(t=>t.shape),e);return ge(s,a,t[0].dtype)}neg(t){return dr(t,"neg"),this.multiply(Me(-1),t)}add(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t+n,imag:e+r})):this.broadcastedBinaryOp(t,e,Rt(t.dtype,e.dtype),(t,e)=>t+e)}addN(t){dr(t,"addN");const e=t.map(t=>this.readSync(t.dataId)),n=Ce(t[0].shape,t[0].dtype),r=n.values;for(let n=0;n<t.length;n++){const t=e[n];for(let e=0;e<r.length;e++)r[e]+=t[e]}return n.toTensor()}softmax(t,e){const n=U([e],t.shape),r=Qt(t,n),s=Gt(r.shape,n),a=this.subtract(t,r.reshape(s)),o=this.exp(a),i=this.sum(o,n).reshape(s);return $e(o,i)}subtract(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t-n,imag:e-r})):this.broadcastedBinaryOp(t,e,Rt(t.dtype,e.dtype),(t,e)=>t-e)}pow(t,e){return dr([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,e,n,r){dr([t,e],"matMul");const s=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],o=r?e.shape[1]:e.shape[2],i=t.shape[0],l=this.readSync(t.dataId),u=this.readSync(e.dataId),[c,h,d]=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[p,f,g]=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],m=a*o,x=Ce([i,a,o],t.dtype),v=x.values,y=this.blockSize;for(let t=0;t<i;t++)for(let e=0;e<a;e+=y)for(let n=0;n<o;n+=y)for(let r=0;r<s;r+=y){const i=Math.min(e+y,a),x=Math.min(n+y,o),C=Math.min(r+y,s);for(let s=e;s<i;s++)for(let e=n;e<x;e++){let n=0;for(let a=r;a<C;a++)n+=l[t*c+s*h+a*d]*u[a*p+e*f+t*g];v[t*m+(s*o+e)]+=n}}return x.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:o}){let i=this.batchMatMul(t,e,n,r);return s&&(i=this.add(i,s)),a&&(i=yr(this,i,a,o)),i}multiply(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})):this.broadcastedBinaryOp(t,e,Rt(t.dtype,e.dtype),(t,e)=>t*e)}floorDiv(t,e){dr([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,e){dr(t,"sum"),zt("sum",e,t.rank);const[n,r]=Ut(t.shape,e),s=Ve(n,Rt(t.dtype,"int32")),a=_(r),o=this.readSync(s.dataId),i=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=t*a;let n=0;for(let t=0;t<a;++t)n+=i[e+t];o[t]=n}return s}prod(t,e){dr(t,"sum");const[n,r]=Ut(t.shape,e),s=Ve(n,Rt(t.dtype,"int32")),a=_(r),o=this.readSync(s.dataId),i=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=t*a;let n=1;for(let t=0;t<a;++t)n*=i[e+t];o[t]=n}return s}unsortedSegmentSum(t,e,n){dr(t,"unsortedSegmentSum");const r=[],s=t.rank-e.rank;for(let t=0;t<s;++t)e=e.expandDims(t+1);for(let s=0;s<n;++s){const n=Me(s,"int32"),a=ke(n,e).asType("float32").mul(t).sum(0);r.push(a)}return cn(r)}argMin(t,e){dr(t,"argMin");const n=[e];zt("argMin",n,t.rank);const[r,s]=Ut(t.shape,n),a=Ve(r,"int32"),o=_(s),i=this.readSync(a.dataId),l=this.readSync(t.dataId);for(let t=0;t<i.length;++t){const e=t*o;let n=l[e],r=0;for(let t=0;t<o;++t){const s=l[e+t];s<n&&(n=s,r=t)}i[t]=r}return a}argMax(t,e){dr(t,"argMax");const n=[e];zt("argMax",n,t.rank);const[r,s]=Ut(t.shape,n),a=Ve(r,"int32"),o=_(s),i=this.readSync(a.dataId),l=this.readSync(t.dataId);for(let t=0;t<i.length;++t){const e=t*o;let n=l[e],r=0;for(let t=0;t<o;++t){const s=l[e+t];s>n&&(n=s,r=t)}i[t]=r}return a}cumsum(t,e,n,r){if(dr(t,"cumsum"),e!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=Rt(t.dtype,"int32"),a=Ve(t.shape,s),o=this.readSync(a.dataId),i=this.readSync(t.dataId),l=t.shape[t.rank-1],u=r?(t,e)=>t+l-e-1:(t,e)=>t+e;for(let t=0;t<i.length;t+=l)for(let e=0;e<l;e++){const r=u(t,e);if(0===e)o[r]=n?0:i[r];else{const s=u(t,e-1);o[r]=n?i[s]+o[s]:i[r]+o[s]}}return a}equal(t,e){return dr([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return dr([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return dr([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return dr([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return dr([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return dr([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){dr(t,"logicalNot");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n[t]=e[t]?0:1;return this.makeOutput(n,t.shape,"bool")}logicalAnd(t,e){return dr([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return dr([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,e,n){dr([t,e,n],"select");const r=this.readSync(t.dataId),s=this.readSync(e.dataId),a=this.readSync(n.dataId),o=Ve(e.shape,Rt(e.dtype,n.dtype)),i=this.readSync(o.dataId);let l=0;const u=0===t.rank||t.rank>1||1===e.rank?1:_(e.shape.slice(1));for(let t=0;t<r.length;t++)for(let e=0;e<u;e++)1===r[t]?i[l++]=s[t]:i[l++]=a[t];return o}where(t){dr([t],"where");const e=this.readSync(t.dataId);return vr(t.shape,e)}topk(t,e,n){dr(t,"topk");const r=this.readSync(t.dataId);return xr(r,t.shape,t.dtype,e)}min(t,e){dr(t,"min"),zt("min",e,t.rank);const[n,r]=Ut(t.shape,e),s=Ve(n,t.dtype),a=_(r),o=this.readSync(s.dataId),i=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=t*a;let n=i[e];for(let t=0;t<a;++t){const r=i[e+t];r<n&&(n=r)}o[t]=n}return s}minimum(t,e){return dr([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return dr([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})}maximum(t,e){return dr([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,e){dr(t,"all"),zt("all",e,t.rank);const[n,r]=Ut(t.shape,e),s=Ve(n,t.dtype),a=_(r),o=this.readSync(s.dataId),i=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=t*a;let n=i[e];for(let t=0;t<a;++t){const r=i[e+t];n=n&&r}o[t]=n}return s}any(t,e){dr(t,"any"),zt("any",e,t.rank);const[n,r]=Ut(t.shape,e),s=Ve(n,t.dtype),a=_(r),o=this.readSync(s.dataId),i=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=t*a;let n=i[e];for(let t=0;t<a;++t){const r=i[e+t];n=n||r}o[t]=n}return s}squaredDifference(t,e){return dr([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t-e;return n*n})}ceil(t){dr(t,"ceil");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.ceil(e[t]);return this.makeOutput(n,t.shape,"float32")}floor(t){dr(t,"floor");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.floor(e[t]);return this.makeOutput(n,t.shape,"float32")}sign(t){dr(t,"x");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)e[t]<0?n[t]=-1:e[t]>0?n[t]=1:n[t]=0;return this.makeOutput(n,t.shape,"float32")}isNaN(t){dr(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isNaN(e[t])&&(n[t]=1);return this.makeOutput(n,t.shape,"bool")}isInf(t){dr(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Math.abs(e[t])===1/0&&(n[t]=1);return this.makeOutput(n,t.shape,"bool")}isFinite(t){dr(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isFinite(e[t])&&(n[t]=1);return this.makeOutput(n,t.shape,"bool")}round(t){dr(t,"round");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=Math.floor(e[t]);e[t]-r<.5?n[t]=Math.floor(e[t]):e[t]-r>.5?n[t]=Math.ceil(e[t]):n[t]=r%2==0?r:r+1}return this.makeOutput(n,t.shape,"float32")}exp(t){dr(t,"exp");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.exp(e[t]);return this.makeOutput(n,t.shape,"float32")}expm1(t){dr(t,"expm1");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.expm1(e[t]);return this.makeOutput(n,t.shape,"float32")}log(t){dr(t,"log");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];n[t]=Math.log(r)}return this.makeOutput(n,t.shape,"float32")}log1p(t){dr(t,"log1p");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];n[t]=Math.log1p(r)}return this.makeOutput(n,t.shape,"float32")}sqrt(t){dr(t,"sqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];n[t]=Math.sqrt(r)}return this.makeOutput(n,t.shape,"float32")}rsqrt(t){dr(t,"rsqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];n[t]=1/Math.sqrt(r)}return this.makeOutput(n,t.shape,"float32")}reciprocal(t){dr(t,"reciprocal");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=1/e[t];return this.makeOutput(n,t.shape,"float32")}linear(t){return t}relu(t){dr(t,"relu");const e=Ve(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t)n[t]=Math.max(0,r[t]);return e}relu6(t){dr(t,"relu");const e=Ve(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t)n[t]=Math.min(Math.max(0,r[t]),6);return e}prelu(t,e){return dr([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){dr(t,"elu");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const r=n[t];e[t]=r>=0?r:Math.exp(r)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){dr([t,e],"eluDer");const n=new Float32Array(e.size),r=this.readSync(e.dataId),s=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const e=r[t];n[t]=e>=1?s[t]:s[t]*(e+1)}return this.makeOutput(n,e.shape,"float32")}selu(t){dr(t,"selu");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const r=n[t];e[t]=r>=0?1.0507009873554805*r:1.7580993408473768*(Math.exp(r)-1)}return this.makeOutput(e,t.shape,"float32")}clip(t,e,n){dr(t,"clip");const r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t){const a=s[t];r[t]=a>n?n:a<e?e:a}return this.makeOutput(r,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<t.size;++r){const t=n[2*r],s=n[2*r+1];e[r]=Math.hypot(t,s)}return this.makeOutput(e,t.shape,"float32")}int(t){dr(t,"int");const e=new Int32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=n[t];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){dr(t,"sigmoid");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=1/(1+Math.exp(-n[t]));return this.makeOutput(e,t.shape,"float32")}softplus(t){dr(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const s=r[t]>-e,a=r[t]<e,o=Math.exp(r[t]);let i;i=a?o:s?r[t]:Math.log(1+o),n[t]=i}return this.makeOutput(n,t.shape,"float32")}sin(t){dr(t,"sin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.sin(n[t]);return this.makeOutput(e,t.shape,"float32")}cos(t){dr(t,"cos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.cos(n[t]);return this.makeOutput(e,t.shape,"float32")}tan(t){dr(t,"tan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.tan(n[t]);return this.makeOutput(e,t.shape,"float32")}asin(t){dr(t,"asin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.asin(n[t]);return this.makeOutput(e,t.shape,"float32")}acos(t){dr(t,"acos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.acos(n[t]);return this.makeOutput(e,t.shape,"float32")}atan(t){dr(t,"atan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.atan(n[t]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return dr([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){dr(t,"sinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.sinh(n[t]);return this.makeOutput(e,t.shape,"float32")}cosh(t){dr(t,"cosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.cosh(n[t]);return this.makeOutput(e,t.shape,"float32")}tanh(t){dr(t,"tanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=P(n[t]);return this.makeOutput(e,t.shape,"float32")}asinh(t){dr(t,"asinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.asinh(n[t]);return this.makeOutput(e,t.shape,"float32")}acosh(t){dr(t,"acosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.acosh(n[t]);return this.makeOutput(e,t.shape,"float32")}atanh(t){dr(t,"atanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t)e[t]=Math.atanh(n[t]);return this.makeOutput(e,t.shape,"float32")}erf(t){dr(t,"erf");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let t=0;t<n.length;++t){const r=Math.sign(n[t]),s=Math.abs(n[t]),a=1/(1+.3275911*s);e[t]=r*(1-((((1.061405429*a-1.453152027)*a+1.421413741)*a-.284496736)*a+.254829592)*a*Math.exp(-s*s))}return this.makeOutput(e,t.shape,"float32")}step(t,e=0){dr(t,"step");const n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const s=r[t];isNaN(s)?n[t]=NaN:n[t]=s>0?1:e}return this.makeOutput(n,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){let o=this.conv2d(t,e,n);return r&&(o=this.add(o,r)),s&&(o=yr(this,o,s,a)),o}conv2d(t,e,n){dr([t,e],"conv2d");const r=n.filterHeight,s=n.filterWidth,a=n.dilationHeight,o=n.dilationWidth,i=n.padInfo.left,l=n.padInfo.top,u="channelsLast"===n.dataFormat,c=Ce(n.outShape,t.dtype),h=t.strides[0],d=u?t.strides[1]:t.strides[2],p=u?t.strides[2]:1,f=u?1:t.strides[1],g=c.strides[0],m=u?c.strides[1]:c.strides[2],x=u?c.strides[2]:1,v=u?1:c.strides[1],y=this.readSync(t.dataId),C=this.readSync(e.dataId),b=c.values;for(let t=0;t<n.batchSize;++t){const u=t*h,c=t*g;for(let t=0;t<n.outHeight;++t){const h=c+t*m,g=t*n.strideHeight-l;for(let t=0;t<r;t++){const r=g+t*a;if(r<0||r>=n.inHeight)continue;const l=t*e.strides[0],c=u+r*d;for(let t=0;t<n.outWidth;++t){const r=h+t*x,a=t*n.strideWidth-i;for(let t=0;t<s;t++){const s=a+t*o;if(s<0||s>=n.inWidth)continue;const i=c+s*p;let u=l+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=y[i+t*f];for(let t=0;t<n.outChannels;++t)b[r+t*v]+=e*C[u+t];u+=n.outChannels}}}}}}return c.toTensor()}conv3d(t,e,n){const r=n.filterDepth,s=n.filterHeight,a=n.filterWidth,o=n.dilationDepth,i=n.dilationHeight,l=n.dilationWidth,u=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,d=Ce(n.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(e.dataId),g=d.values;for(let m=0;m<n.batchSize;++m){const x=m*t.strides[0],v=m*d.strides[0];for(let m=0;m<n.outDepth;++m){const y=v+m*d.strides[1],C=m*n.strideDepth-u;for(let u=0;u<r;u++){const r=C+u*o;if(r<0||r>=n.inDepth)continue;const m=u*e.strides[0],v=x+r*t.strides[1];for(let r=0;r<n.outHeight;++r){const o=y+r*d.strides[2],u=r*n.strideHeight-h;for(let r=0;r<s;r++){const s=u+r*i;if(s<0||s>=n.inHeight)continue;const h=m+r*e.strides[1],d=v+s*t.strides[2];for(let t=0;t<n.outWidth;++t){const r=o+t*n.outChannels,s=t*n.strideWidth-c;for(let t=0;t<a;t++){const a=s+t*l;if(a<0||a>=n.inWidth)continue;const o=h+t*e.strides[2],i=d+a*n.inChannels;let u=o;for(let t=0;t<n.inChannels;++t){const e=p[i+t];for(let t=0;t<n.outChannels;++t)g[r+t]+=e*f[u+t];u+=n.outChannels}}}}}}}}return d.toTensor()}conv2dDerInput(t,e,n){dr([t,e],"conv2dDerInput");const r=Ce(n.inShape,"float32"),s=r.values,a=this.readSync(t.dataId),o=this.readSync(e.dataId),[i,l,u]=e.strides,{batchSize:c,filterHeight:h,filterWidth:d,inChannels:p,inHeight:f,inWidth:g,outChannels:m,outHeight:x,outWidth:v,strideHeight:y,strideWidth:C,dataFormat:b}=n,w=h-1-n.padInfo.top,$=d-1-n.padInfo.left,R="channelsLast"===b,I=r.strides[0],E=R?r.strides[1]:r.strides[2],A=R?r.strides[2]:1,T=R?1:r.strides[1],S=t.strides[0],k=R?t.strides[1]:t.strides[2],N=R?t.strides[2]:1,O=R?1:t.strides[1];for(let t=0;t<c;++t)for(let e=0;e<p;++e)for(let n=0;n<f;++n){const r=n-w,c=Math.max(0,Math.ceil(r/y)),p=Math.min(x,(h+r)/y);for(let f=0;f<g;++f){const g=f-$,x=Math.max(0,Math.ceil(g/C)),b=Math.min(v,(d+g)/C);let w=0;for(let n=c;n<p;++n){const s=n*y-r;for(let r=x;r<b;++r){const c=S*t+k*n+N*r,p=i*(h-1-s)+l*(d-1-(r*C-g))+u*e;for(let t=0;t<m;++t){w+=a[c+O*t]*o[p+t]}}}s[I*t+E*n+A*f+T*e]=w}}return r.toTensor()}conv3dDerInput(t,e,n){const r=Ce(n.inShape,"float32"),s=r.values,[a,o,i,l]=r.strides,u=this.readSync(t.dataId),[c,h,d,p]=t.strides,f=this.readSync(e.dataId),[g,m,x,v]=e.strides,{batchSize:y,filterDepth:C,filterHeight:b,filterWidth:w,inChannels:$,inDepth:R,inHeight:I,inWidth:E,outChannels:A,outDepth:T,outHeight:S,outWidth:k,strideDepth:N,strideHeight:O,strideWidth:F}=n,D=C-1-n.padInfo.front,_=b-1-n.padInfo.top,B=w-1-n.padInfo.left;for(let t=0;t<y;++t)for(let e=0;e<$;++e)for(let n=0;n<R;++n){const r=n-D,y=Math.max(0,Math.ceil(r/N)),$=Math.min(T,(C+r)/N);for(let R=0;R<I;++R){const I=R-_,T=Math.max(0,Math.ceil(I/O)),D=Math.min(S,(b+I)/O);for(let S=0;S<E;++S){const E=S-B,_=Math.max(0,Math.ceil(E/F)),M=Math.min(k,(w+E)/F);let P=0;for(let n=y;n<$;++n){const s=n*N-r;for(let r=T;r<D;++r){const a=r*O-I;for(let o=_;o<M;++o){const i=c*t+h*n+d*r+p*o,l=g*(C-1-s)+m*(b-1-a)+x*(w-1-(o*F-E))+v*e;for(let t=0;t<A;++t){P+=u[i+t]*f[l+t]}}}}s[a*t+o*n+i*R+l*S+e]=P}}}return r.toTensor()}conv2dDerFilter(t,e,n){dr([t,e],"conv2dDerFilter");const r=n.strideHeight,s=n.strideWidth,a=n.filterHeight,o=n.filterWidth,i="channelsLast"===n.dataFormat,l=Ce(n.filterShape,"float32"),u=n.padInfo.left,c=n.padInfo.top,h=this.bufferSync(t),d=this.bufferSync(e);for(let t=0;t<a;++t){const e=Math.max(0,Math.ceil((c-t)/r)),a=Math.min(n.outHeight,(n.inHeight+c-t)/r);for(let p=0;p<o;++p){const o=Math.max(0,Math.ceil((u-p)/s)),f=Math.min(n.outWidth,(n.inWidth+u-p)/s);for(let g=0;g<n.inChannels;++g)for(let m=0;m<n.outChannels;++m){let x=0;for(let l=0;l<n.batchSize;++l)for(let n=e;n<a;++n){const e=t+n*r-c;for(let t=o;t<f;++t){const r=p+t*s-u;x+=i?h.get(l,e,r,g)*d.get(l,n,t,m):h.get(l,g,e,r)*d.get(l,m,n,t)}}l.set(x,t,p,g,m)}}}return l.toTensor()}conv3dDerFilter(t,e,n){const r=n.strideDepth,s=n.strideHeight,a=n.strideWidth,o=n.filterDepth,i=n.filterHeight,l=n.filterWidth,u=Ce(n.filterShape,"float32"),c=u.values,[h,d,p,f]=u.strides,g=this.readSync(e.dataId),[m,x,v,y]=e.strides,C=this.readSync(t.dataId),[b,w,$,R]=t.strides,I=n.padInfo.front,E=n.padInfo.left,A=n.padInfo.top;for(let t=0;t<o;++t){const e=Math.max(0,Math.ceil((I-t)/r)),o=Math.min(n.outDepth,(n.inDepth+I-t)/r),u=t*h;for(let h=0;h<i;++h){const i=Math.max(0,Math.ceil((A-h)/s)),T=Math.min(n.outHeight,(n.inHeight+A-h)/s),S=h*d+u;for(let u=0;u<l;++u){const l=Math.max(0,Math.ceil((E-u)/a)),d=Math.min(n.outWidth,(n.inWidth+E-u)/a),k=u*p+S;for(let p=0;p<n.inChannels;++p){const S=p*f+k;for(let f=0;f<n.outChannels;++f){let k=0;for(let c=0;c<n.batchSize;++c){const n=c*b,S=c*m;for(let c=e;c<o;++c){const e=(t+c*r-I)*w+n,o=c*x+S;for(let t=i;t<T;++t){const n=(h+t*s-A)*$+e,r=t*v+o;for(let t=l;t<d;++t){const e=t*y+r;k+=C[(u+t*a-E)*R+n+p]*g[e+f]}}}}c[S+f]=k}}}}}return u.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){let o=this.depthwiseConv2D(t,e,n);return r&&(o=this.add(o,r)),s&&(o=yr(this,o,s,a)),o}depthwiseConv2D(t,e,n){dr([t,e],"depthwiseConv2D");const r=n.filterHeight,s=n.filterWidth,a=n.dilationHeight,o=n.dilationWidth,i=n.padInfo.left,l=n.padInfo.top,u=n.outChannels/n.inChannels,c=Ce(n.outShape,t.dtype),h=this.readSync(t.dataId),d=this.readSync(e.dataId),p=c.values;for(let f=0;f<n.batchSize;++f){const g=f*t.strides[0],m=f*c.strides[0];for(let f=0;f<n.outHeight;++f){const x=m+f*c.strides[1],v=f*n.strideHeight-i;for(let i=0;i<r;++i){const r=v+i*a;if(r<0||r>=n.inHeight)continue;const f=i*e.strides[0],m=g+r*t.strides[1];for(let t=0;t<n.outWidth;++t){const r=x+t*c.strides[2],a=t*n.strideWidth-l;for(let t=0;t<s;++t){const s=a+t*o;if(s<0||s>=n.inWidth)continue;const i=f+t*e.strides[1],l=m+s*n.inChannels;let c=r,g=i;for(let t=0;t<n.inChannels;++t){const e=h[l+t];for(let t=0;t<u;++t)p[c+t]+=e*d[g+t];c+=u,g+=u}}}}}}return c.toTensor()}depthwiseConv2DDerInput(t,e,n){dr([t,e],"depthwiseConv2DDerInput");const r=Ce(n.inShape,"float32"),s=r.values,[a,o,i]=r.strides,l=this.readSync(t.dataId),[u,c,h]=t.strides,d=this.readSync(e.dataId),[p,f,g]=e.strides,{batchSize:m,filterHeight:x,filterWidth:v,inChannels:y,inHeight:C,inWidth:b,outChannels:w,outHeight:$,outWidth:R,strideHeight:I,strideWidth:E}=n,A=x-1-n.padInfo.top,T=v-1-n.padInfo.left,S=w/y;for(let t=0;t<m;++t)for(let e=0;e<y;++e)for(let n=0;n<C;++n){const r=n-A,m=Math.max(0,Math.ceil(r/I)),y=Math.min($,(x+r)/I);for(let C=0;C<b;++C){const b=C-T,w=Math.max(0,Math.ceil(b/E)),$=Math.min(R,(v+b)/E);let A=0;for(let n=m;n<y;++n){const s=n*I-r;for(let r=w;r<$;++r){const a=u*t+c*n+h*r,o=p*(x-1-s)+f*(v-1-(r*E-b))+g*e;for(let t=0;t<S;++t){A+=l[a+(e*S+t)]*d[o+t]}}}s[a*t+o*n+i*C+e]=A}}return r.toTensor()}depthwiseConv2DDerFilter(t,e,n){dr([t,e],"depthwiseConv2DDerFilter");const r=n.strideHeight,s=n.strideWidth,a=n.filterHeight,o=n.filterWidth,i=Ce(n.filterShape,"float32"),l=n.padInfo.left,u=n.padInfo.top,c=n.outChannels/n.inChannels,h=this.bufferSync(t),d=this.bufferSync(e);for(let t=0;t<a;++t){const e=Math.max(0,Math.ceil((u-t)/r)),a=Math.min(n.outHeight,(n.inHeight+u-t)/r);for(let p=0;p<o;++p){const o=Math.max(0,Math.ceil((l-p)/s)),f=Math.min(n.outWidth,(n.inWidth+l-p)/s);for(let g=0;g<n.outChannels;++g){const m=Math.trunc(g/c),x=g%c;let v=0;for(let i=0;i<n.batchSize;++i)for(let n=e;n<a;++n){const e=t+n*r-u;for(let t=o;t<f;++t){const r=p+t*s-l;v+=h.get(i,e,r,m)*d.get(i,n,t,g)}}i.set(v,t,p,m,x)}}}return i.toTensor()}tile(t,e){return dr(t,"tile"),mr(this.bufferSync(t),e)}pad(t,e,n){dr(t,"pad");const r=e.map((e,n)=>e[0]+t.shape[n]+e[1]),s=e.map(t=>t[0]),a=this.bufferSync(t),o=Ce(r,t.dtype);0!==n&&o.values.fill(n);for(let e=0;e<t.size;e++){const t=a.indexToLoc(e),n=t.map((t,e)=>t+s[e]);o.set(a.get(...t),...n)}return o.toTensor()}gather(t,e,n){dr([t,e],"gather");const r=t.shape.slice(),s=this.readSync(e.dataId);r[n]=s.length;const a=Ce(r,t.dtype),o=this.bufferSync(t);for(let t=0;t<a.size;++t){const e=a.indexToLoc(t),r=e.slice();r[n]=s[e[n]];const i=o.locToIndex(r);a.values[t]=o.values[i]}return a.toTensor()}batchToSpaceND(t,e,n){dr([t],"batchToSpaceND");const r=e.reduce((t,e)=>t*e),s=_n(t.shape,e,r),a=Bn(s.length,e.length),o=Mn(t.shape,e,r),i=Pn(n,e.length),l=Ln(o,n,e.length);return Kt(t.reshape(s),a).reshape(o).slice(i,l)}spaceToBatchND(t,e,n){dr([t],"spaceToBatchND");const r=e.reduce((t,e)=>t*e),s=[[0,0]];s.push(...n);for(let n=1+e.length;n<t.shape.length;++n)s.push([0,0]);const a=t.pad(s),o=_n(a.shape,e,r,!1),i=Bn(o.length,e.length,!1),l=Mn(a.shape,e,r,!1),u=Kt(a.reshape(o),i);return qt(u,l)}maxPool(t,e){dr(t,"maxPool");return pr(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,e,n,r){dr([e,n],"maxPoolBackprop");const s=this.readSync(e.dataId),a=Ce(r.outShape,e.dtype,function(t,e,n,r,s=!1,a=!1){const o=Ce(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=Ce(e,n,t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let n=0;n<r.outHeight;++n){const m=n*i-p;let x=m;for(;x<0;)x+=u;const v=Math.min(r.inHeight,h+m);for(let i=0;i<r.outWidth;++i){const h=i*l-f;let p=h;for(;p<0;)p+=c;const y=Math.min(r.inWidth,d+h);let C=Number.NEGATIVE_INFINITY,b=-1;for(let n=x;n<v;n+=u){const o=n-m;for(let i=p;i<y;i+=c){const l=i-h,u=g.get(t,n,i,e);u>C&&(C=u,b=s?a?((t*r.inHeight+n)*r.inWidth+i)*r.inChannels+e:(n*r.inWidth+i)*r.inChannels+e:o*d+l)}}o.set(b,t,n,i,e)}}return o}(s,e.shape,e.dtype,r).values),o=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=h-1-r.padInfo.left,p=c-1-r.padInfo.top,f=Ce(e.shape,"float32"),g=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let n=0;n<r.inHeight;++n)for(let s=0;s<r.inWidth;++s){const m=n-p,x=s-d;let v=0;for(let n=0;n<c;n+=l){const s=(m+n)/o;if(!(s<0||s>=r.outHeight||Math.floor(s)!==s))for(let o=0;o<h;o+=u){const l=(x+o)/i;if(l<0||l>=r.outWidth||Math.floor(l)!==l)continue;const u=c*h-1-a.get(t,s,l,e)===n*h+o?1:0;if(0===u)continue;v+=g.get(t,s,l,e)*u}}f.set(v,t,n,s,e)}return f.toTensor()}avgPoolBackprop(t,e,n){dr([t,e],"avgPoolBackprop");const r=n.strideHeight,s=n.strideWidth,a=n.filterHeight,o=n.filterWidth,i=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,d=u-1-n.padInfo.top,p=Ce(e.shape,"float32"),f=1/(a*o),g=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let a=0;a<n.inHeight;++a)for(let o=0;o<n.inWidth;++o){const m=a-d,x=o-h;let v=0;for(let a=0;a<u;a+=i){const o=(m+a)/r;if(!(o<0||o>=n.outHeight||Math.floor(o)!==o))for(let r=0;r<c;r+=l){const a=(x+r)/s;if(a<0||a>=n.outWidth||Math.floor(a)!==a)continue;v+=g.get(t,o,a,e)}}p.set(v*f,t,a,o,e)}return p.toTensor()}pool3d(t,e,n){dr(t,"pool3d");const r=e.strideDepth,s=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,g="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=this.readSync(t.dataId),x=Ce(e.outShape,t.dtype),v=x.values,y=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],C=e.outShape[2]*e.outShape[3]*e.outShape[4],b=e.outShape[3]*e.outShape[4],w=e.outShape[4];for(let x=0;x<e.batchSize;++x){const $=x*y,R=x*t.strides[0];for(let x=0;x<e.inChannels;++x)for(let y=0;y<e.outDepth;++y){const I=y*r-d;let E=I;for(;E<0;)E+=o;const A=Math.min(e.inDepth,u+I),T=$+y*C;for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=i;const y=Math.min(e.inHeight,c+u),C=T+r*b;for(let r=0;r<e.outWidth;++r){const s=r*a-f;let u=s;for(;u<0;)u+=l;const c=Math.min(e.inWidth,h+s),p=C+r*w;let b=g,$=0,I=0;for(let e=E;e<A;e+=o){const r=R+e*t.strides[1];for(let e=d;e<y;e+=i){const s=r+e*t.strides[2];for(let e=u;e<c;e+=l){const r=m[s+e*t.strides[3]+x];if("max"===n&&r>b?b=r:"avg"===n&&($+=r,I++),isNaN(b))break}if(isNaN(b))break}if(isNaN(b))break}v[p+x]="avg"===n?$/I:b}}}}return x.toTensor()}avgPool3d(t,e){return dr(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,e,n){dr([t,e],"avgPool3dBackprop");const r=n.strideDepth,s=n.strideHeight,a=n.strideWidth,o=n.filterDepth,i=n.filterHeight,l=n.filterWidth,u=n.dilationDepth,c=n.dilationHeight,h=n.dilationWidth,d=n.effectiveFilterDepth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,g=d-1-n.padInfo.front,m=f-1-n.padInfo.left,x=p-1-n.padInfo.top,v=Ce(e.shape,"float32"),y=1/(o*i*l),C=this.bufferSync(t);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let o=0;o<n.inDepth;++o)for(let i=0;i<n.inHeight;++i)for(let l=0;l<n.inWidth;++l){const b=o-g,w=i-x,$=l-m;let R=0;for(let o=0;o<d;o+=u){const i=(b+o)/r;if(!(i<0||i>=n.outDepth||Math.floor(i)!==i))for(let r=0;r<p;r+=c){const o=(w+r)/s;if(!(o<0||o>=n.outHeight||Math.floor(o)!==o))for(let r=0;r<f;r+=h){const s=($+r)/a;if(s<0||s>=n.outWidth||Math.floor(s)!==s)continue;R+=C.get(t,i,o,s,e)}}}v.set(R*y,t,o,i,l,e)}return v.toTensor()}maxPool3d(t,e){return dr(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,e){const n=Ce(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,g=this.bufferSync(t);for(let t=0;t<e.batchSize;++t)for(let m=0;m<e.inChannels;++m)for(let x=0;x<e.outDepth;++x){const v=x*r-d;let y=v;for(;y<0;)y+=o;const C=Math.min(e.inDepth,u+v);for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=i;const b=Math.min(e.inHeight,c+u);for(let s=0;s<e.outWidth;++s){const p=s*a-f;let w=p;for(;w<0;)w+=l;const $=Math.min(e.inWidth,h+p);let R=Number.NEGATIVE_INFINITY,I=-1;for(let e=y;e<C;e+=o){const n=e-v;for(let r=d;r<b;r+=i){const s=r-u;for(let a=w;a<$;a+=l){const o=a-p,i=g.get(t,e,r,a,m);i>=R&&(R=i,I=n*c*h+s*c+o)}}}n.set(I,t,x,r,s,m)}}}return n.toTensor()}maxPool3dBackprop(t,e,n,r){dr([e,n],"maxPool3dBackprop");const s=this.maxPool3dPositions(e,r),a=r.strideDepth,o=r.strideHeight,i=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterDepth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=h-1-r.padInfo.front,g=p-1-r.padInfo.left,m=d-1-r.padInfo.top,x=Ce(e.shape,"float32"),v=this.bufferSync(s),y=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let n=0;n<r.inDepth;++n)for(let s=0;s<r.inHeight;++s)for(let C=0;C<r.inWidth;++C){const b=n-f,w=s-m,$=C-g;let R=0;for(let n=0;n<h;n+=l){const s=(b+n)/a;if(!(s<0||s>=r.outDepth||Math.floor(s)!==s))for(let a=0;a<d;a+=u){const l=(w+a)/o;if(!(l<0||l>=r.outHeight||Math.floor(l)!==l))for(let o=0;o<p;o+=c){const u=($+o)/i;if(u<0||u>=r.outWidth||Math.floor(u)!==u)continue;const c=h*d*p-1-v.get(t,s,l,u,e)===n*d*p+a*p+o?1:0;if(0===c)continue;R+=y.get(t,s,l,u,e)*c}}}x.set(R,t,n,s,C,e)}return x.toTensor()}cast(t,e){return Kn(t,e,this)}reshape(t,e){return Yn(t,e)}avgPool(t,e){dr(t,"avgPool"),dr(t,"maxPool");return pr(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,e,n,r){dr(t,"resizeBilinear");const[s,a,o,i]=t.shape,l=this.readSync(t.dataId),u=new Float32Array(_([s,e,n,i])),c=[r&&e>1?a-1:a,r&&n>1?o-1:o],h=[r&&e>1?e-1:e,r&&n>1?n-1:n];let d=0;const p=c[0]/h[0],f=c[1]/h[1];for(let r=0;r<s;r++)for(let s=0;s<e;s++){const e=p*s,c=Math.floor(e),h=e-c,g=Math.min(a-1,Math.ceil(e)),m=r*t.strides[0]+c*t.strides[1],x=r*t.strides[0]+g*t.strides[1];for(let e=0;e<n;e++){const n=f*e,r=Math.floor(n),s=n-r,a=Math.min(o-1,Math.ceil(n)),c=m+r*t.strides[2],p=x+r*t.strides[2],g=m+a*t.strides[2],v=x+a*t.strides[2];for(let t=0;t<i;t++){const e=l[c+t],n=l[p+t],r=e+(l[g+t]-e)*s,a=r+(n+(l[v+t]-n)*s-r)*h;u[d++]=a}}}return ge(u,[s,e,n,i])}resizeBilinearBackprop(t,e,n){dr([t,e],"resizeBilinearBackprop");const[r,s,a,o]=e.shape,[,i,l]=t.shape,u=new Float32Array(r*s*a*o),c=[n&&i>1?s-1:s,n&&l>1?a-1:a],h=[n&&i>1?i-1:i,n&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],f=this.readSync(t.dataId);let g=0;for(let t=0;t<r;t++){const n=t*e.strides[0];for(let t=0;t<i;t++){const r=t*d,i=Math.floor(r),c=Math.min(Math.ceil(r),s-1),h=n+i*e.strides[1],m=n+c*e.strides[1],x=r-i,v=1-x;for(let t=0;t<l;t++){const n=t*p,r=Math.floor(n),s=Math.min(Math.ceil(n),a-1),i=n-r,l=1-i,c=h+r*e.strides[2],d=h+s*e.strides[2],y=m+r*e.strides[2],C=m+s*e.strides[2],b=v*l,w=v*i,$=x*l,R=x*i;for(let t=0;t<o;t++){const e=f[g++];u[c+t]+=e*b,u[d+t]+=e*w,u[y+t]+=e*$,u[C+t]+=e*R}}}}return hn(u,[r,a,s,o],e.dtype)}resizeNearestNeighbor(t,e,n,r){dr(t,"resizeNearestNeighbor");const[s,a,o,i]=t.shape,l=this.readSync(t.dataId),u=new Float32Array(s*e*n*i),c=[r&&e>1?a-1:a,r&&n>1?o-1:o],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=c[0]/h[0],p=c[1]/h[1];let f=0;for(let c=0;c<s;c++){const s=c*t.strides[0];for(let c=0;c<e;c++){const e=d*c,h=s+Math.min(a-1,r?Math.round(e):Math.floor(e))*t.strides[1];for(let e=0;e<n;e++){const n=p*e,s=h+Math.min(o-1,r?Math.round(n):Math.floor(n))*t.strides[2];for(let t=0;t<i;t++){const e=l[s+t];u[f++]=e}}}}return ge(u,[s,e,n,i],t.dtype)}resizeNearestNeighborBackprop(t,e,n){dr([t,e],"resizeNearestNeighborBackprop");const[r,s,a,o]=e.shape,[,i,l]=t.shape,u=new Float32Array(r*s*a*o),c=this.readSync(t.dataId),h=[n&&i>1?s-1:s,n&&l>1?a-1:a],d=[n&&i>1?i-1:i,n&&l>1?l-1:l],p=h[0]/d[0],f=h[1]/d[1],g=1/p,m=1/f,x=2*Math.ceil(g)+2,v=2*Math.ceil(m)+2;for(let h=0;h<r;h++){const r=h*e.strides[0];for(let h=0;h<s;h++){const d=r+h*e.strides[1],y=Math.floor(h*g),C=Math.floor(y-x/2);for(let g=0;g<a;g++){const y=d+g*e.strides[2],b=Math.floor(g*m),w=Math.floor(b-v/2);for(let e=0;e<o;e++){let o=0;for(let u=0;u<x;u++){const d=u+C;if(d<0||d>=i)continue;const m=r+d*t.strides[1],x=d*p;if(h===Math.min(s-1,n?Math.round(x):Math.floor(x)))for(let r=0;r<v;r++){const s=r+w;if(s<0||s>=l)continue;const i=m+s*t.strides[2],u=s*f;g===Math.min(a-1,n?Math.round(u):Math.floor(u))&&(o+=c[i+e])}}u[y+e]=o}}}}return hn(u,e.shape,e.dtype)}batchNorm(t,e,n,r,s,a){dr([t,e,n,s,r],"batchNorm");const o=this.readSync(t.dataId),i=this.readSync(e.dataId),l=this.readSync(n.dataId),u=s?this.readSync(s.dataId):new Float32Array([1]),c=r?this.readSync(r.dataId):new Float32Array([0]),h=new Float32Array(o.length),d=c.length,p=u.length,f=l.length,g=i.length;let m=0,x=0,v=0,y=0;for(let t=0;t<o.length;++t)h[t]=c[m++]+(o[t]-i[x++])*u[v++]/Math.sqrt(l[y++]+a),m>=d&&(m=0),x>=g&&(x=0),v>=p&&(v=0),y>=f&&(y=0);return hn(h,t.shape)}localResponseNormalization4D(t,e,n,r,s){dr(t,"localResponseNormalization4D");const a=t.shape[3],o=a-1,i=this.readSync(t.dataId),l=t.size,u=new Float32Array(l);function c(t){const n=t%a;let r=t-n+Math.max(0,n-e);const s=t-n+Math.min(n+e,o);let l=0;for(;r<=s;r++){const t=i[r];l+=t*t}return l}for(let t=0;t<l;t++){const e=c(t),a=i[t]*Math.pow(n+r*e,-s);u[t]=a}return hn(u,t.shape)}LRNGrad(t,e,n,r,s,a,o){dr(t,"LRNGrad");const i=t.shape[3],l=this.readSync(t.dataId),u=this.readSync(e.dataId),c=this.readSync(n.dataId),h=new Float32Array(t.size),d=t.size;for(let t=0;t<d;t++){const e=t%i,n=t-e+Math.max(0,e-r),d=t-e+Math.min(i,e+r+1);let p=0;for(let t=n;t<d;t++)p+=Math.pow(u[t],2);p=a*p+s;for(let e=n;e<d;e++){let n=-2*a*o*u[e]*c[t]/p;t===e&&(n+=Math.pow(p,-o)),n*=l[t],h[e]+=n}}return hn(h,t.shape)}multinomial(t,e,n,r){dr(t,"multinomial");const s=e?t:un(t),a=s.shape[0],o=s.shape[1],i=Ve([a,n],"int32"),l=this.readSync(i.dataId),u=this.readSync(s.dataId);for(let t=0;t<a;++t){const e=t*o,s=new Float32Array(o-1);s[0]=u[e];for(let t=1;t<s.length;++t)s[t]=s[t-1]+u[e+t];const a=tn.alea(r.toString()),i=t*n;for(let t=0;t<n;++t){const e=a();l[i+t]=s.length;for(let n=0;n<s.length;n++)if(e<s[n]){l[i+t]=n;break}}}return i}oneHot(t,e,n,r){dr(t,"oneHot");const s=new Float32Array(t.size*e);s.fill(r);const a=this.readSync(t.dataId);for(let r=0;r<t.size;++r)a[r]>=0&&a[r]<e&&(s[r*e+a[r]]=n);return function(t,e,n){if(F(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Nt(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return fe(t,e,r,n)}(s,[t.size,e],"int32")}nonMaxSuppression(t,e,n,r,s){dr(t,"nonMaxSuppression");const a=this.readSync(t.dataId),o=this.readSync(e.dataId);return fr(a,o,n,r,s)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,e){const n=t.shape[0],r=t.shape[1],s=Ce(t.shape,"float32"),a=Ce(t.shape,"float32"),o=Be(t).as2D(n,r),i=_e(t).as2D(n,r);for(let t=0;t<n;t++){const n=o.slice([t,0],[1,r]),l=i.slice([t,0],[1,r]),u=be(n,l),c=this.readSync(this.fftImpl(u,e).dataId);for(let e=0;e<r;e++){const n=Hn(c,e);s.values[t*r+e]=n.real,a.values[t*r+e]=n.imag}}return be(s.toTensor(),a.toTensor()).as2D(n,r)}fftImpl(t,e){const n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){let s=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(s=be(Be(s).div(Me(r)),_e(s).div(Me(r)))),s}{const n=this.readSync(t.dataId),s=Un(this.fourierTransformByMatmul(n,r,e));return be(s.real,s.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,e,n){if(1===e)return t;const r=this.readSync(t.dataId),s=e/2,a=Gn(r);let o=be(a.real,a.imag).as1D();const i=zn(r);let l=be(i.real,i.imag).as1D();o=this.fftRadix2(o,s,n),l=this.fftRadix2(l,s,n);const u=jn(e,n),c=be(u.real,u.imag).mul(l),h=o.add(c),d=o.sub(c),p=Be(h).concat(Be(d)),f=_e(h).concat(_e(d));return be(p,f).as1D()}fourierTransformByMatmul(t,e,n){const r=new Float32Array(2*e);for(let s=0;s<e;s++){let a=0,o=0;for(let r=0;r<e;r++){const i=qn(s*r,e,n),l=Hn(t,r);a+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(a/=e,o/=e),Xn(r,a,o,s)}return r}depthToSpace(t,e,n){N("NHWC"===n,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n),N(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const r=t.shape[0],s=t.shape[1],a=t.shape[2],o=t.shape[3],i=s*e,l=a*e,u=o/(e*e),c=this.readSync(t.dataId),h=new Float32Array(r*i*l*u);let d=0;for(let t=0;t<r;++t)for(let n=0;n<i;++n){const r=Math.floor(n/e),i=n%e;for(let n=0;n<l;++n){const l=Math.floor(n/e),p=(i*e+n%e)*u;for(let e=0;e<u;++e){const n=e+p+o*(l+a*(r+s*t));h[d++]=c[n]}}}return hn(h,[r,i,l,u])}broadcastedBinaryOp(t,e,n,r){const s=Ee(t.shape,e.shape),a=Ce(s,n),o=this.readSync(t.dataId),i=this.readSync(e.dataId),l=Re(t.shape,s),u=Re(e.shape,s),c=a.values;if(l.length+u.length===0)for(let t=0;t<c.length;++t)c[t]=r(o[t%o.length],i[t%i.length]);else{const n=this.bufferSync(t),s=this.bufferSync(e);for(let h=0;h<c.length;++h){const d=a.indexToLoc(h),p=d.slice(-t.rank);l.forEach(t=>p[t]=0);const f=n.locToIndex(p),g=d.slice(-e.rank);u.forEach(t=>g[t]=0);const m=s.locToIndex(g);c[h]=r(o[f],i[m])}}return a.toTensor()}broadcastedBinaryComplexOp(t,e,n){const r=Ee(t.shape,e.shape),s=Ce(r,"float32"),a=Ce(r,"float32"),o=this.readSync(t.dataId),i=this.readSync(e.dataId),l=Re(t.shape,r),u=Re(e.shape,r),c=s.values,h=a.values;if(l.length+u.length===0)for(let t=0;t<c.length;t++){const e=t%o.length,r=t%i.length,s=n(o[2*e],o[2*e+1],i[2*r],i[2*r+1]);c[t]=s.real,h[t]=s.imag}else{const r=this.bufferSync(this.data.get(t.dataId).complexTensors.real),a=this.bufferSync(this.data.get(e.dataId).complexTensors.real);for(let d=0;d<c.length;d++){const p=s.indexToLoc(d),f=p.slice(-t.rank);l.forEach(t=>f[t]=0);const g=r.locToIndex(f),m=p.slice(-e.rank);u.forEach(t=>m[t]=0);const x=a.locToIndex(m),v=n(o[2*g],o[2*g+1],i[2*x],i[2*x+1]);c[d]=v.real,h[d]=v.imag}}return this.complex(s.toTensor(),a.toTensor())}split(t,e,n){return gr(t,e,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,e,n,r,s,a){const[o,i,l,u]=t.shape,c=e.shape[0],[h,d]=r,p=Ce([c,h,d,u],"float32"),f=this.readSync(e.dataId),g=this.readSync(n.dataId),m=this.readSync(t.dataId),x=t.strides,v=p.strides;for(let t=0;t<c;t++){const e=4*t,n=f[e],r=f[e+1],c=f[e+2],y=f[e+3],C=g[t];if(C>=o)continue;const b=h>1?(c-n)*(i-1)/(h-1):0,w=d>1?(y-r)*(l-1)/(d-1):0;for(let e=0;e<h;e++){const o=h>1?n*(i-1)+e*b:.5*(n+c)*(i-1);if(o<0||o>i-1)for(let n=0;n<d;n++)for(let r=0;r<u;r++){const s=r+n*v[2]+e*v[1]+t*v[0];p.values[s]=a}else if("bilinear"===s){const n=Math.floor(o),s=Math.ceil(o),i=o-n;for(let o=0;o<d;o++){const c=d>1?r*(l-1)+o*w:.5*(r+y)*(l-1);if(c<0||c>l-1){for(let n=0;n<u;n++){const r=n+o*v[2]+e*v[1]+t*v[0];p.values[r]=a}continue}const h=Math.floor(c),f=Math.ceil(c),g=c-h;for(let r=0;r<u;r++){let a=r+h*x[2]+n*x[1]+C*x[0];const l=m[a];a=r+f*x[2]+n*x[1]+C*x[0];const u=m[a];a=r+h*x[2]+s*x[1]+C*x[0];const c=m[a];a=r+f*x[2]+s*x[1]+C*x[0];const d=l+(u-l)*g,y=c+(m[a]-c)*g;a=r+o*v[2]+e*v[1]+t*v[0],p.values[a]=d+(y-d)*i}}}else for(let n=0;n<d;++n){const s=d>1?r*(l-1)+n*w:.5*(r+y)*(l-1);if(s<0||s>l-1){for(let r=0;r<u;r++){const s=r+n*v[2]+e*v[1]+t*v[0];p.values[s]=a}continue}const i=Math.round(s),c=Math.round(o);for(let r=0;r<u;r++){const s=r+i*x[2]+c*x[1]+C*x[0],a=r+n*v[2]+e*v[1]+t*v[0];p.values[a]=m[s]}}}}return p.toTensor()}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:a,sliceSize:o,strides:i,outputSize:l}=gn(0,t,n);return this.scatter(t,e,n,l,o,a,s,i,r,!1)}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,a,o,i]=bn(t,e);if(0===a)return ge([],s,t.dtype);const l=new ft([a,o],t.dtype),u=this.readSync(e.dataId),c=this.readSync(t.dataId);for(let e=0;e<a;e++){const n=[];let s=0;for(let t=0;t<r;t++){const a=u[e*r+t];s+=a*i[t],n.push(a)}if(s<0||s>=t.size/o)throw new Error(`Invalid indices: ${n} does not index into ${t.shape}`);for(let t=0;t<o;t++)l.values[e*o+t]=c[s*o+t]}return l.toTensor().reshape(s)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:a,strides:o,outputSize:i}=gn(0,t,n),l=Me(0);return this.scatter(t,e,n,i,a,s,r,o,l,!0)}fill(t,e,n){const r=H(n=n||K(e),_(t));return r.fill(e),le().makeTensor(r,t,n,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const e=H(t.dtype,_(t.shape));return this.makeOutput(e,t.shape,t.dtype)}linspace(t,e,n){return Qn(t,e,n)}scatter(t,e,n,r,s,a,o,i,l,u){const c=[r/s,s],h=this.readSync(t.dataId),d=this.readSync(e.dataId);if(0===r)return ge([],n,e.dtype);const p=new ft(c,e.dtype);p.values.fill(this.readSync(l.dataId)[0]);for(let t=0;t<a;t++){const a=[];let l=0;for(let e=0;e<o;e++){const n=h[t*o+e];a.push(n),l+=n*i[e]}if(l<0||l>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[l*s+n]+=d[t*s+n]:p.values[l*s+n]=0===e.rank?d[0]:d[t*s+n]}return p.toTensor().reshape(n)}}function br(t,e,n,r){const s=z(r,_(n));for(let n=0;n<s.length;++n){const r=n*e;let a=t[r];for(let n=0;n<e;++n){const e=t[r+n];e>a&&(a=e)}s[n]=a}return s}function wr(t,e,n,r,s){const a=e.length,o=_(e),i=Z(e),l=Z(s),u=z(n,_(s));for(let e=0;e<o;++e){const n=it(e,a,i),s=new Array(n.length);for(let t=0;t<s.length;t++)s[t]=n[r[t]];u[ot(s,a,l)]=t[e]}return u}var $r=Object.freeze({__proto__:null,maxImpl:br,transposeImpl:wr});he("cpu",()=>new Cr,1);const Rr={kernelName:"Square",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;dr(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let t=0;t<s.length;++t){const e=s[t];a[t]=e*e}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Ir={kernelName:"Max",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{reductionIndices:s,keepDims:a}=e,o=n;let i=r.shape;const l=i.length,u=U(s,i);let c=u;const h=Ht(c,l);let d=o.data.get(r.dataId).values;if(null!=h){const t=new Array(l);for(let e=0;e<t.length;e++)t[e]=i[h[e]];d=wr(d,i,r.dtype,h,t),c=jt(c.length,l),i=t}dr(r,"max"),zt("max",c,l);const[p,f]=Ut(i,c),g=br(d,_(f),p,r.dtype),m=o.write(g,p,r.dtype);let x=p;if(a){x=Gt(p,u)}return{dataId:m,shape:x,dtype:r.dtype}}};const Er=function(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:n,backend:r})=>{const{a:s,b:a}=n,o=r;dr([s,a],t);const i=o.data.get(s.dataId).values,l=o.data.get(a.dataId).values,[u,c]=e(s.shape,a.shape,i,l,s.dtype);return{dataId:o.write(u,c,s.dtype),shape:c,dtype:s.dtype}}}}("Div",function(t){return(e,n,r,s,a)=>{const o=Ee(e,n),i=o.length,l=Z(o),u=z(a,_(o)),c=e.length,h=n.length,d=Z(e),p=Z(n),f=Re(e,o),g=Re(n,o);if(f.length+g.length===0)for(let e=0;e<u.length;++e)u[e]=t(r[e%r.length],s[e%s.length]);else for(let e=0;e<u.length;++e){const n=it(e,i,l),a=n.slice(-c);f.forEach(t=>a[t]=0);const o=ot(a,c,d),m=n.slice(-h);g.forEach(t=>m[t]=0);const x=ot(m,h,p);u[e]=t(r[o],s[x])}return[u,o]}}((t,e)=>t/e)),Ar={},Tr={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Sr(t){t in Ar||(Ar[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);if(e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete Ar[t]},!1),1===t)return e.getContext("webgl",Tr)||e.getContext("experimental-webgl",Tr);return e.getContext("webgl2",Tr)}(t));const e=Ar[t];return e.isContextLost()?(delete Ar[t],Sr(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ar[t])}var kr,Nr,Or;function Fr(t,e){return[e,t]}function Dr(t){const e=_(t);return L(Math.ceil(e/4))}function _r(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Br(t,e){const n=t;let r,s,a,o,i,l,u,c,h,d;return 2===v().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,o=n.RGBA32F,i=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=t.RGBA,s=t.RGBA,a=t.RGBA,o=n.RGBA,i=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function Mr(t,e){const n=e();return v().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(kr||(kr={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(Nr||(Nr={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Or||(Or={}));function Pr(t){return!!(v().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function Lr(t,e){return qr(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Wr(t,e){const n=qr(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Mr(t,()=>t.shaderSource(n,e)),Mr(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=Vr.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);const r=+n[1],s=t.split("\n"),a=s.length.toString().length+2,o=s.map((t,e)=>W((e+1).toString(),a)+t);let i=0;for(let t=0;t<o.length;t++)i=Math.max(o[t].length,i);const l=o.slice(0,r-1),u=o.slice(r-1,r),c=o.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+W(u[0],i),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Vr=/ERROR: [0-9]+:([0-9]+):/g;function Ur(t,e){if(Mr(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Gr(t,e,n,r,s,a,o){const i=t.getAttribLocation(e,n);return-1!==i&&(Mr(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Mr(t,()=>t.vertexAttribPointer(i,s,t.FLOAT,!1,a,o)),Mr(t,()=>t.enableVertexAttribArray(i)),!0)}function zr(t,e,n){!function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}(t,n),Mr(t,()=>t.activeTexture(t.TEXTURE0+n)),Mr(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function Hr(t,e,n){Mr(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Mr(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function Xr(t,e){Mr(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Mr(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function jr(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}(t,e))}function qr(t,e,n){const r=Mr(t,()=>e());if(null==r)throw new Error(n);return r}function Kr(t,e=2){return _(t.slice(0,t.length-e))}function Yr(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Qr(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[Kr(t),...Yr(t)]),e}function Zr(t){return t%2==0}function Jr(t,e){if(B(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(Zr(n)&&Zr(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&Zr(t[0])&&Zr(e[0])}let ts,es;function ns(t,e){return null!=t.getExtension(e)}function rs(t){try{if(null!=Sr(t))return!0}catch(t){return!1}return!1}function ss(t){if(0===t)return!1;const e=Sr(t);if(1!==t){if(ns(e,"EXT_color_buffer_float"))return as(e);const t="EXT_color_buffer_half_float";if(ns(e,t)){const n=e.getExtension(t);return function(t,e){const n=Br(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),a}(e,n)}return!1}if(!ns(e,"OES_texture_float"))return!1;if(!ns(e,"WEBGL_color_buffer_float"))return!1;return as(e)}function as(t){const e=Br(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),s}const os=v();os.registerFlag("HAS_WEBGL",()=>os.getNumber("WEBGL_VERSION")>0),os.registerFlag("WEBGL_VERSION",()=>rs(2)?2:rs(1)?1:0),os.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),os.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===os.get("WEBGL_VERSION")),os.registerFlag("WEBGL_CPU_FORWARD",()=>!0),os.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),os.registerFlag("WEBGL_PACK",()=>os.getBool("HAS_WEBGL")),os.registerFlag("WEBGL_PACK_NORMALIZATION",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_CLIP",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),os.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_PACK_REDUCE",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_LAZILY_UNPACK",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_CONV_IM2COL",()=>os.getBool("WEBGL_PACK")),os.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==ts){const e=Sr(t);ts=e.getParameter(e.MAX_TEXTURE_SIZE)}return ts}(os.getNumber("WEBGL_VERSION"))),os.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==es){const e=Sr(t);es=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,es)}(os.getNumber("WEBGL_VERSION"))),os.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=os.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=Sr(t);return e=ns(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:ns(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),os.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>os.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Jn()),os.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=Sr(t);if(1===t){if(!ns(e,"OES_texture_float"))return!1}else if(!ns(e,"EXT_color_buffer_float"))return!1;return as(e)}(os.getNumber("WEBGL_VERSION"))),os.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!os.getBool("WEBGL_FORCE_F16_TEXTURES")&&os.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),os.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ss(os.getNumber("WEBGL_VERSION"))),os.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=os.getNumber("WEBGL_VERSION"))&&null!=Sr(t).fenceSync;var t}),os.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>os.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),os.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});class is{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class ls{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class us{constructor(t,e,n){this.variableNames=["A"];const r=t.windowSize,s=t.batchSize,a=t.inSize,o=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const i="max"===e?">":"<",l=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${l};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function cs(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function hs(t,e){return 1===e?[t]:cs(t,e)}function ds(){let t,e,n,r,s,a,o,i,l,u;return 2===v().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",s="texture",a="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function ps(t,e,n="index"){const r=Z(e);return r.map((e,s)=>`${`int ${t[s]} = ${n} / ${e}`}; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${e}`:`index -= ${t[s]} * ${e}`};`).join("")}function fs(t){const e=Z(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const gs="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:ms}=Zn;function xs(t,e,n,r){const s=[];t.forEach(t=>{const e=_(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?s.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(s.push(`uniform sampler2D ${t.name};`),s.push(`uniform int offset${t.name};`))});const a=s.join("\n"),o=t.map(t=>function(t,e,n=!1){let r="";r+=n?ys(t):vs(t);const s=t.shapeInfo.logicalShape,a=e.logicalShape;s.length<=a.length&&(r+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=ms(t.shapeInfo.logicalShape,e.logicalShape),l=As(o),u=o-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":o<2&&i.length>=1?"coords = 0;":i.map(t=>`coords.${h[t+u]} = 0;`).join("\n");let d="";d=o<2&&a>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+h[e+u]).join(", ");let p="return outputValue;";const f=1===_(t.shapeInfo.logicalShape),g=1===_(e.logicalShape);if(1!==a||f||g){if(f&&!g)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const t=a-2,e=a-1;i.indexOf(t)>-1&&i.indexOf(e)>-1?p="return vec4(outputValue.x);":i.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.texShape,o=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&null==t.shapeInfo.flatOffset&&B(o,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=As(l),c=ms(t.shapeInfo.logicalShape,e.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":l<2&&c.length>=1?"coords = 0;":c.map(t=>`coords.${p[t+h]} = 0;`).join("\n");let f="";f=l<2&&i>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+p[e+h]).join(", ");return`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(t,e));return r}(t,e,r)).join("\n"),i=e.texShape,l=ds(),u=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,h,d=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Cs}\n    ${bs}\n    ${ws}\n  `}(l);e.isPacked?(c=function(t,e){switch(t.length){case 0:return Rs();case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(B(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let a=s,o="",i="b, r, c";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],o=`\n      int b${e} = index / ${a};\n      index -= b${e} * ${a};\n    `+o,i=`b${e}, `+i;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${i});\n    }\n  `}(t,e)}}(e.logicalShape,i),h=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(l)):(c=function(t,e){switch(t.length){case 0:return Rs();case 1:return function(t,e){if(1===e[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `;if(1===e[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e);case 2:return function(t,e){if(B(t,e))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;if(1===t[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===t[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=ps(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=ps(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=ps(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=ps(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}}(e.logicalShape,i),h=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),r&&(d+=$s);return[d,u,h,a,c,o,n].join("\n")}function vs(t){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[a,o]=t.shapeInfo.texShape,i=Is(e);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${o}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Es(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],a=r[1];if(1===a&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Is(e);if(1===a)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(1===s)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape;if(null!=s&&B(e,s)){const t=s[0],e=s[1];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${e}.0, ${t}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:a,keptDims:o}=G(e),i=a;if(i.length<e.length){const e=Ts(t,i),n=["row","col"];return`\n      ${vs(e)}\n      float ${r}(int row, int col) {\n        return ${r}(${Ss(n,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Es(t)}\n      }\n    `;const l=s[0],u=s[1],c=Is(n);if(1===u)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;if(1===l)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],a=e[2],{newShape:o,keptDims:i}=G(e),l=o;if(l.length<e.length){const e=Ts(t,l),n=["row","col","depth"];return`\n        ${vs(e)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Ss(n,i)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Es(t)}\n      }\n    `;const u=t.shapeInfo.texShape,c=u[0],h=u[1],d=t.shapeInfo.flatOffset;if(h===s&&null==d)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(h===a&&null==d)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const p=Is(n);return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${p};\n        vec2 uv = uvFromFlat(${c}, ${h}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(t);case 4:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],a=e[2]*s,o=e[1]*a,{newShape:i,keptDims:l}=G(e);if(i.length<e.length){const e=Ts(t,i),n=["row","col","depth","depth2"];return`\n      ${vs(e)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Ss(n,l)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${s}, 1)));\n        ${Es(t)}\n      }\n    `;const u=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,h=c[0],d=c[1];if(d===o&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(d===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const p=Is(n);return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${p});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],a=e[3]*s,o=e[2]*a,i=e[1]*o,{newShape:l,keptDims:u}=G(e);if(l.length<e.length){const e=Ts(t,l),n=["row","col","depth","depth2","depth3"];return`\n      ${vs(e)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Ss(n,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${a}, ${s})) +\n          depth3;\n        ${Es(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=Is(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=G(e);if(s.length<e.length){const e=Ts(t,s),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${vs(e)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Ss(n,a)});\n      }\n    `}const o=e[5],i=e[4]*o,l=e[3]*i,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Es(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const g=Is(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${g};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function ys(t){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ds();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=ds();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `}(t);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,a=s[0],o=s[1],i=ds();if(null!=s&&B(e,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${i.texture2D}(${n}, uv);\n      }\n    `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(e[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(t);case 3:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===e[0]){const n=e.slice(1),s=[1,2],a=Ts(t,n),o=["b","row","col"];return`\n        ${ys(a)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ss(o,s)});\n        }\n      `}const o=a[0],i=a[1],l=Math.ceil(e[2]/2),u=l*Math.ceil(e[1]/2),c=ds();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${i}, ${u}, ${l}, b, row, col);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(t);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],i=o[0],l=o[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let t=2;t<n-1;t++)h=`int b${t}, `+h,c*=e[n-t-1],d=`b${t} * ${c} + `+d;const p=ds();return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${i});\n      return ${p.texture2D}(${r}, uv);\n    }\n  `}(t)}}const Cs="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",bs="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ws="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$s="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Rs(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Is(t){return"offset"+t}function Es(t){const e=t.name,n=_(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function As(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Ts(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Ss(t,e){return e.map(e=>t[e]).join(", ")}class ks{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,N(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=t[t.length-1],a=Math.ceil(s/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=As(i),u=hs("coords",i);let c,h;if(1===a){h=i+1;const t=As(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[i-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[i-2]};`}else h=i,c=`\n        ${l} sourceLocR = coords;\n        ++${u[i-1]};\n        ${l} sourceLocG = coords;\n        ++${u[i-2]};\n        ${l} sourceLocA = coords;\n        --${u[i-1]};\n        ${l} sourceLocB = coords;\n        --${u[i-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),g=hs("sourceLocR",h-1).concat("inIdx.r"),m=hs("sourceLocG",h-1).concat("inIdx.g"),x=hs("sourceLocB",h-1).concat("inIdx.b"),v=hs("sourceLocA",h-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",C=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,b=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${o[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${b};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${C}\n          vec4 candidate = ${b};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class Ns{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=i-1-t.padInfo.top,c=l-1-t.padInfo.left,h=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Os{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,a=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,f=h-1-t.padInfo.top,g=d-1-t.padInfo.left,m=1/(e*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${g});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Fs{constructor(t,e,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Ee(t,e),Ee(t,n);let o="0.0";null!=r&&(Ee(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=s&&(Ee(t,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Ds{constructor(t,e,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ee(t,e),Ee(t,n);let o="vec4(0.0)";null!=r&&(Ee(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=s&&(Ee(t,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const _s="return areal * breal - aimag * bimag;",Bs="return areal * bimag + aimag * breal;";class Ms{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ee(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Ps="return a + b;",Ls="return a - b;",Ws="return a * b;",Vs="return (a < 0.) ? b * a : a;";class Us{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=Ee(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Gs="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class zs{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ee(e,n);const s=this.outputShape.length;let a="";if(r)if(0===s||1===_(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${As(s)} coords = getOutputCoords();\n        `,1===s)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=hs("coords",s);a+=`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}class Hs{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class Xs{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class js{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class qs{constructor(t){this.outputShape=[],this.outputShape=pe(t,1),this.variableNames=t.map((t,e)=>"T"+e);const e=new Array(t.length-1);e[0]=t[0][1];for(let n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<e.length;t++){const r=e[t-1];n.push(`else if (yC < ${e[t]}) setOutput(getT${t}(yR, yC-${r}));`)}const r=e.length,s=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Ks{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=pe(t,e);const n=this.outputShape,r=n.length,s=As(r),a=hs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((t,e)=>"T"+e);const i=new Array(t.length-1);i[0]=t[0][e];for(let n=1;n<i.length;n++)i[n]=i[n-1]+t[n][e];const l=o[e],u=o.slice(-2),c=o.join();let h=`if (${l} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let t=1;t<i.length;t++){const e=i[t-1];h+=`\n        if (${l} < ${i[t]}  && ${l} >= ${i[t-1]}) {\n          return getChannel(\n            getT${t}(${Ys(o,l,e)}),\n            vec2(${Ys(u,l,e)}));\n        }`}const d=i.length,p=i[i.length-1];h+=`\n        return getChannel(\n          getT${d}(${Ys(o,l,p)}),\n          vec2(${Ys(u,l,p)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function Ys(t,e,n){const r=t.indexOf(e);return t.map((t,e)=>e===r?`${t} - ${n}`:t).join()}class Qs{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,a="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${a}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zs{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a="channelsLast"===t.dataFormat,o=e-1-t.padInfo.top,i=n-1-t.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Js{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.padInfo.front,a=t.padInfo.top,o=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${s};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${o};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ta{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,a=t.strideHeight,o=t.strideWidth,i=e-1-t.padInfo.front,l=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ea{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class na{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,a=e-1-t.padInfo.top,o=n-1-t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ra{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4,f="channelsLast"===t.dataFormat,g=f?1:2,m=f?2:3,x=f?3:1;let v="",y="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${m}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${y}\n        setOutput(result);\n      }\n    `}}class sa{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,a=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aa{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.inHeight,a=t.inWidth,o=t.padInfo.top,i=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=t.outChannels/t.inChannels;let g="",m="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,m="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${m}\n        setOutput(result);\n      }\n    `}}class oa{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const s=t.inHeight,a=t.inWidth,o=t.padInfo.top,i=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=p;let g="int xR; int xC; int xCOffset;";for(let t=0;t<d;t++)for(let e=0;e<p;e++)g+=`\n          vec4 xTexelR${t}C${2*e} = vec4(0.);\n          vec4 wR${t}C${e} = vec4(0.);\n          vec4 xR${t}C${e} = vec4(0.);`;for(let t=0;t<d;t++)for(let e=0;e<f;e++){const n=2*e;if(g+=`\n          xR = xRCorner + ${t*c};\n          xC = xCCorner + ${n*h};\n        `,1===u){if(n<p&&(g+=i%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${t}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${t}C${n} = vec4(previous.zw, xTexelR${t}C${n}.xy);\n                } else {\n                  xR${t}C${n} = vec4(0, 0, xTexelR${t}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xR${t}C${n} = xTexelR${t}C${n};\n              `,n+1<p)){const e=i%2==0?k(h):h;h%2==0&&i%2==1||h%2!=0&&i%2!=1?(g+=`\n                  xCOffset = xC + ${i%2} + ${e};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,h>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${t}C${n} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${e};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${t}C${n+1} = xTexelR${t}C${n+2};\n                `}}else n<p&&(g+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,i%2==1?(g+=`\n                xCOffset = xC + 1 - ${u};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n              `,n+1<p&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${u};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${t}C${n+1} = vec4(xTexelR${t}C${n+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${t}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${t}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${u};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${t}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${t}C${n+2} = vec4(0.);\n                }\n\n                xR${t}C${n} = vec4(\n                  xTexelR${t}C${n}.xy, xTexelR${t}C${n+2}.xy);\n              `,n+1<p&&(g+=`\n                  xR${t}C${n+1} = vec4(\n                    xTexelR${t}C${n}.zw, xTexelR${t}C${n+2}.zw);\n                `)),g+="}");n<p&&(g+=`\n            vec4 wTexelR${t}C${n} = getW(${t}, ${n}, d1, q);\n            wR${t}C${n} = vec4(wTexelR${t}C${n}.xz, wTexelR${t}C${n}.xz);\n          `,n+1<p&&(g+=`\n              vec4 wTexelR${t}C${n+1} = getW(${t}, ${n+1}, d1, q);\n              wR${t}C${n+1} =\n                vec4(wTexelR${t}C${n+1}.xz, wTexelR${t}C${n+1}.xz);`))}for(let t=0;t<d;t++)for(let e=0;e<p;e++)g+=`dotProd += xR${t}C${e} * wR${t}C${e};`;let m="",x="";n&&(m=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}}class ia{constructor(t,e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,i,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[o-1+".0",i-1+".0"],[g,m,x]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+p],[v,y,C]=h>1?[""+(i-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${m};\n        float width_scale = ${y};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${C};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class la{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,s=e?"0.0":`getX(${ua(r,"coords")})`,a=t[t.length-1];let o="",i="";e?(o=n?"end != "+(a-1):"end != 0",i=n?"end + 1":"end - 1"):(o=n?"end + pow2 < "+a:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${As(r)} coords = getOutputCoords();\n        int end = ${ca(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${i};\n          ${ca(r,"coords")} = idx;\n          val += getX(${ua(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function ua(t,e){if(1===t)return""+e;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function ca(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class ha{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=kr.DENSE;const e=Dr(t),n=ds();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ps(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class da{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=kr.DENSE;const e=Dr(t),n=ds();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${ps(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class pa{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class fa{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class ga{constructor(t){this.variableNames=["A"],this.outTexUsage=Nr.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`\n      ${gs}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class ma{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Nr.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`\n      ${gs}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class xa{constructor(t,e,n=!1){this.variableNames=["A"];const r=ds(),[s,a]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${fs(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class va{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=ds(),[s,a]=e;this.outputShape=t;let o="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){const i=2*e+n;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${t[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${e} < ${t[1]}) {\n              localCoords[1] += ${e};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${fs(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${r.output} = ${i};\n      }\n    `}}const ya="return real * expR - imag * expI;",Ca="return real * expI + imag * expR;";class ba{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class wa{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class $a{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const s=As(this.rank),a=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let n=0;n<t.length;n++)n===e?s.push(`int(getIndices(${r[n]}))`):s.push(""+r[n]);return s.join()}(t,n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}class Ra{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=As(e.length),s=As(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${a};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function Ia(t){const e=ds();return function(t,e){const n=qr(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Mr(t,()=>t.shaderSource(n,e)),Mr(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Ea(t){return function(t,e){const n=qr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Mr(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Mr(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Aa(t){return function(t,e){const n=qr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Mr(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Mr(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}function Ta(t,e,n,r,s,a){!function(t,e){const n=v().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){throw new Error("Requested texture size "+`[${t}x${e}]`+" is invalid.")}if(t>n||e>n){throw new Error("Requested texture size "+`[${t}x${e}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}(e,n);const o=function(t){return qr(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),i=t.TEXTURE_2D;return Mr(t,()=>t.bindTexture(i,o)),Mr(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Mr(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Mr(t,()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST)),Mr(t,()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST)),Mr(t,()=>t.texImage2D(i,0,r,e,n,0,s,a,null)),Mr(t,()=>t.bindTexture(t.TEXTURE_2D,null)),o}function Sa(t){return t.internalFormatFloat}function ka(t){return t.internalFormatHalfFloat}function Na(t){return t.downloadTextureFormat}function Oa(t){return t.internalFormatPackedFloat}function Fa(t){return t.internalFormatPackedHalfFloat}function Da(t,e,n,r,s,a,o,i){const l=t,u=new Float32Array(function(t,e){const[n,r]=_r(t,e);return n*r*4}(a,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class _a{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=v().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){Ar[t]=e}(e,t)):this.gl=Sr(e);let n="WEBGL_color_buffer_float";if(1===v().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=Lr(this.gl,t),ns(this.gl,e))this.textureHalfFloatExtension=Lr(this.gl,e);else if(v().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ns(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=Lr(this.gl,"EXT_color_buffer_half_float");else if(v().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ns(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!ns(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=Ea(this.gl),this.indexBuffer=Aa(this.gl),this.framebuffer=function(t){return qr(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Br(this.gl,this.textureHalfFloatExtension)}get debug(){return v().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Mr(t,()=>t.finish()),Mr(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Mr(t,()=>t.deleteFramebuffer(this.framebuffer)),Mr(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Mr(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Mr(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,a]=Fr(e,n);return Ta(t,s,a,Sa(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,a]=Fr(e,n);return Ta(t,s,a,ka(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,a]=Fr(e,n);return Ta(t,s,a,Na(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){Mr(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?Mr(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):Mr(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Mr(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,s,a){let o,i,l;Mr(t,()=>t.bindTexture(t.TEXTURE_2D,e)),s instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),i=t.FLOAT,l=a.internalFormatPackedFloat),o.set(s),Mr(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,i,o)),Mr(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,a]=_r(e,n);return Ta(t,s,a,Fa(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,a]=_r(e,n);return Ta(t,s,a,Oa(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Xr(this.gl,this.framebuffer),this.outputTexture=null),Mr(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,r){const[s,a]=Fr(e,n),o=new Uint8Array(e*n*4);return Mr(t,()=>t.readPixels(0,0,s,a,r.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,s,a){return Da(this.gl,t,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const s=t.createBuffer();Mr(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*e*n;return Mr(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Mr(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Mr(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(v().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(s,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=s}else v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const r=new Float32Array(e*n*4);return Mr(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=Wr(e,t),r=Ia(e),s=function(t){return qr(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return Mr(e,()=>e.attachShader(s,r)),Mr(e,()=>e.attachShader(s,n)),function(t,e){if(Mr(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,s),this.debug&&Ur(e,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(t,e,n){return Mr(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Gr(t,e,"clipSpacePos",n,3,20,0)&&Gr(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Mr(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Ur(this.gl,this.program),Mr(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return qr(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Mr(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,r){Mr(t,()=>zr(t,e,r)),Mr(t,()=>t.uniform1i(n,r))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,s]=_r(e,n);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Ur(this.gl,this.program),jr(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),Mr(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Mr(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Lr(this.gl,2===v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await V(()=>this.disposed||this.isQueryAvailable(t,v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||V(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Hr(this.gl,t,this.framebuffer),this.debug&&jr(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Hr(this.gl,this.outputTexture,this.framebuffer),this.debug&&jr(this.gl)):Xr(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;Hr(r,t,this.framebuffer),this.debug&&jr(r),this.outputTexture=t,Mr(r,()=>r.viewport(0,0,e,n)),Mr(r,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),Mr(this.gl,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Ba(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const r=t.logicalShape,s=e[n],a=s.shape;if(!B(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&s.isUniform)return;const o=t.texShape,i=s.isUniform?null:s.texData.texShape;if(!B(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)})}class Ma{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:s,strideWidth:a,strideHeight:o,padInfo:i,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=i,f=s*r,g=ds(),m="channelsLast"===h,x=m?0:1,v=m?1:2;let y="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)y+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[x]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${a}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${m}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${y}\n\n        ${g.output} = result;\n      }\n    `}}class Pa{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=e,o=t[3]-1;let i;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;i=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class La{constructor(t,e,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class Wa{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=e,o=t[3]-1;let i;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;i=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}class Va{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,s=t.effectiveFilterHeight,a=t.effectiveFilterWidth,o=s-1-t.padInfo.top,i=a-1-t.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ua{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.dilationDepth,a=t.dilationHeight,o=t.dilationWidth,i=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=i-1-t.padInfo.front,h=l-1-t.padInfo.top,d=u-1-t.padInfo.left,p=i*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ga{constructor(t,e,n=!1,r=!1,s=!1,a=null,o=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const i=n?t[1]:t[2],l=Math.ceil(i/2),u=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",h=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],d=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let p="",f="";a&&(p=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,f="result = activation(result);");const g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${p}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          vec4 a = getMatrixA(rc.x, ${u});\n          vec4 b = getMatrixB(rc.x, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${d[0]});\n          result += (${h[1]} * ${d[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${f}\n\n        setOutput(result);\n      }\n    `}}class za{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class Ha{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class Xa{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=hs("rc",e),r=As(e),s=function(t,e,n){if(1===t)return"rc > "+e[0];let r="";for(let s=t-2;s<t;s++)r+=`${n[s]} >= ${e[s]}`,s<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<t;n++)a=e[e.length-1-n]+","+a;n.push(a)}return n}(n,e);if(1===n)return`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class ja{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=As(r),a=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class qa{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=As(r),a=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),i=hs("rc",r),l=hs("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[s+" rc = outputLoc;",`${i[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let t=0,e=1===r?2:4;t<e;t++)p+=`\n        ${h[t]}\n        if (${d}) {\n          result[${t}] = float(${n});\n        } else {\n          ${s} source = rc - start;\n          result[${t}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class Ka{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,m=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?g:m:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const y=4*Math.floor(a/4),C=a%4,b=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${b}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${b}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class Ya{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const a=t.filterWidth,o=t.strideDepth,i=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=t.padInfo.front,m=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const v="avg"===e;let y="0.0";if(v||(y="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${l});\n        const ivec3 pads = ivec3(${g}, ${m}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / count");const b=4*Math.floor(a/4),w=a%4,$=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${l});\n      const ivec3 pads = ivec3(${g}, ${m}, ${x});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${b}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${$}\n            }\n\n            int xC = xCCorner + ${b};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${$}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}class Qa{constructor(t,e){this.variableNames=["x"];const n=t.windowSize,r=t.batchSize,s=t.inSize,a=Math.ceil(s/n);this.outputShape=[r,a];let o="0.0",i="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",i="min"):"max"===e&&(o="-1.0 / 1e-20",i="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}class Za{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let t=0;t<4;t++){let e="thisRC = rc;";t%2==1&&(e+="thisRC.z += 1;"),t>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${ps(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${fs(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Ja{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,a,o]=t.shape,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],l=[n&&a>1?a-1:a,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class to{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,a,o,i]=t;this.outputShape=[s,e,n,i];const l=[r&&e>1?a-1:a,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class eo{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,o,i]=t;this.outputShape=[s,e,n,i];const l=[r&&e>1?a-1:a,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]},\n          ${l[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${i-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class no{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,a,o]=t.shape,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],l=[n&&a>1?a-1:a,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class ro{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,a,o,i]=t;this.outputShape=[s,e,n,i];const l=[r&&e>1?a-1:a,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class so{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=As(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class ao{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=hs("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=As(n);function i(n){const r=t.map((r,s)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:""+r[n]}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return i(t)}(r.slice())};\n          if(${s}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",i(t)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",i(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class oo{constructor(t,e,n,r,s,a,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const i=As(s.length),l=As(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`,p=e>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class io{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,s=t.inSize,a=t.numSegments,o=a*Math.ceil(s/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class lo{constructor(t,e,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],o=[];for(let r=0;r<e.length;r++)o.push(""+n[r]),r<t&&a.push(""+n[r]);r=a.join(),s=o.join()}const a=As(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}class uo{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=As(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return co.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${co[e]} = start[${e}] + coords.${co[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const co=["x","y","z","w","u","v"];class ho{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=As(this.rank),n=hs("coords",this.rank),r=hs("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,o=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class po{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=As(n.length),a=As(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class fo{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=mo(e,n),s=xo(t,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=go(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const t=this.freeTextures[s].shift();return this.usedTextures[s].push(t),t}let o;return r===Or.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Or.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Or.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Or.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Or.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const s=mo(n,r),a=xo(e,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=go(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=v().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=o):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[a],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function go(t,e,n,r,s){const a=function(t,e){switch(t){case Or.PACKED_2X2_FLOAT32:return Oa(e);case Or.PACKED_2X2_FLOAT16:return Fa(e);case Or.UNPACKED_FLOAT32:return Sa(e);case Or.UNPACKED_FLOAT16:return ka(e);case Or.PACKED_4X1_UNSIGNED_BYTE:return Na(e);default:throw new Error("Unknown physical texture type "+t)}}(e,r);let o;if(s){const[e,n]=_r(t[0],t[1]);o=e*n}else{const[e,n]=Fr(t[0],t[1]);o=e*n}return o*function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;throw new Error("Unknown internal format "+e)}(n,a)}function mo(t,e){if(t===Nr.UPLOAD)return Or.PACKED_2X2_FLOAT32;if(t===Nr.RENDER||null==t)return function(t){return v().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Or.PACKED_2X2_FLOAT32:Or.UNPACKED_FLOAT32:t?Or.PACKED_2X2_FLOAT16:Or.UNPACKED_FLOAT16}(e);if(t===Nr.DOWNLOAD||t===Nr.PIXELS)return Or.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function xo(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class vo{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;const r=As(this.rank),s=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let e=0;e<t.length;e++)r.push(`imod(${n[e]}, ${t[e]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class yo{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Co="if (isnan(x)) return x;",bo="return abs(x);",wo=Co+"\n  return (x < 0.0) ? 0.0 : x;\n",$o=Co+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Ro="return (x >= 0.0) ? x : (exp(x) - 1.0);";const Io="return -x;",Eo="return ceil(x);",Ao="return floor(x);",To="return exp(x);",So="return exp(x) - 1.0;",ko="return x;",No="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Oo="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Fo="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class Do{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class _o{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=hs("rc",e),r=As(e),s=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),o=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const{segment_util:Bo}=Zn,Mo=er,Po=nr,Lo=rr,Wo=pn,Vo={};function Uo(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?No:wo;if("elu"===t)return e?Fo:Ro;if("relu6"===t)return e?Oo:$o;if("prelu"===t)return e?Gs:Vs;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class Go extends ar{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!v().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=Sr(v().getNumber("WEBGL_VERSION"));this.binaryCache=((e=v().getNumber("WEBGL_VERSION"))in Vo||(Vo[e]={}),Vo[e]),this.gpgpu=new _a(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new fo(this.gpgpu),this.numMBBeforeWarning=null==v().global.screen?1024:v().global.screen.height*v().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new sr(this,le())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((v().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||v().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:Nr.UPLOAD}),r}move(t,e,n,r){if(v().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:Nr.UPLOAD})}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensors:s,slice:a,shape:o,isPacked:i}=e;if(null!=a){let e;e=i?new Do(o,ko):new yo(o,ko);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeData(n.dataId),s}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=rt()),"complex64"===r){c=Vn(s.real.dataSync(),s.imag.dataSync())}else c=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=rt()-u),this.convertAndCacheOnCPU(t,c)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:r,slice:s,dtype:a,complexTensors:o,isPacked:i}=e;if(null!=s){let e;e=i?new Do(r,ko):new yo(r,ko);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeData(n.dataId),s}if(null!=n)return this.convertAndCacheOnCPU(t);if(!v().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===v().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&v().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(e.texture,...Dr(r))}if(this.pendingRead.set(t,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const t=await Promise.all([o.real.data(),o.imag.data()]);u=Vn(t[0],t[1])}else if(null==c)u=this.getValuesFromTexture(t);else{const t=_(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,t)}null!=l&&this.disposeData(l.dataId);const h=this.convertAndCacheOnCPU(t,u),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach(t=>t(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),h}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!Pr(n)){if(v().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),s=_(e);if(v().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...Dr(e)).subarray(0,s);return this.disposeData(n.dataId),a}const a=v().getBool("WEBGL_PACK")&&!0===r,o=a?Qr(e):e,i=a?new ma(o):new ga(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:t}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeData(l.dataId),c}async time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const s=D(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),a=D(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);o.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),o.getExtraProfileInfo=()=>t.map((t,e)=>({name:a[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:rt(),endMs:null}}endTimer(t){return v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=rt(),t)}async getQueryTime(t){if(v().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;this.releaseGPUData(t);const{complexTensors:e}=this.texData.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:s,isPacked:a,slice:o}=this.texData.get(t),i=o&&o.origDataId||t,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,s,a)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return v().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=le().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||v().getBool("IS_TEST")||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every(t=>null==this.texData.get(t.dataId).texture&&_(t.shape)<e)}getGPGPUContext(){return this.gpgpu}complex(t,e){const n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:le().keep(t.clone()),imag:le().keep(e.clone())},n}real(t){return this.texData.get(t.dataId).complexTensors.real.clone()}imag(t){return this.texData.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===_(n))return ge([],n,t.dtype);const{isPacked:r}=this.texData.get(t.dataId),s=ve(t.shape,e,n);if(r||!s){const r=v().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ho(n):new uo(n),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),s=this.makeOutput(n,t.dtype),a=this.texData.get(s.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;let o=ye(e,t.strides);r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||t.dataId};const i=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,i+1),s}stridedSlice(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);const s=xe(e,n,r);if(s.some(t=>0===t))return ge([],s);const a=new po(e,r,s);return this.compileAndRun(a,[t])}reverse(t,e){const n=v().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ao(t.shape,e):new so(t.shape,e);return this.compileAndRun(n,[t])}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Be(t)),r=t.map(t=>_e(t));return be(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>v().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),s=this.concat(t.slice(n),e);return this.concat([r,s],e)}if(v().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){const n=new Ks(t.map(t=>t.shape),e);return this.compileAndRun(n,t)}const n=pe(t.map(t=>t.shape),e),r=t.map(t=>t.as2D(-1,_(t.shape.slice(e)))),s=new qs(r.map(t=>t.shape));return this.compileAndRun(s,r).reshape(n)}neg(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Io,t.dtype);const e=new yo(t.shape,Io);return this.compileAndRun(e,[t])}batchMatMul(t,e,n,r){const s=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],o=n?t.shape[1]:t.shape[2],[i,,]=t.shape;if((1===s||1===a)&&o>1e3){n&&(t=Kt(t,[0,2,1])),r&&(e=Kt(e,[0,2,1]));const s=1===a?t:t.as3D(i,o,1),l=1===a?2:1,u=1===a?e.as3D(i,1,o):e;return this.multiply(s,u).sum(l,!0)}const l=Rt(t.dtype,e.dtype),u=new Ga(t.shape,[i,s,a],n,r);return this.compileAndRun(u,[t,e],l)}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:a,preluActivationWeights:o}){const i=n?t.shape[2]:t.shape[1],l=r?e.shape[1]:e.shape[2],[u,,]=t.shape,c=Rt(t.dtype,e.dtype),h=null!=s,d=null!=o,p=a?Uo(a,!0):null,f=new Ga(t.shape,[u,i,l],n,r,h,p,d),g=[t,e];return s&&g.push(s),o&&g.push(o),this.compileAndRun(f,g,c)}multiply(t,e){if("complex64"===t.dtype){const n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),s=new Ms(_s,t.shape,e.shape),a=new Ms(Bs,t.shape,e.shape),o=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],i=this.compileAndRun(s,o),l=this.compileAndRun(a,o),u=this.complex(i,l);return i.dispose(),l.dispose(),u}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Ws,t.dtype);const n=new Us(Ws,t.shape,e.shape);return this.compileAndRun(n,[t,e],t.dtype)}batchNorm(t,e,n,r,s,a){const o=[t,e,n];let i=null;null!=r&&(i=r.shape,o.push(r));let l=null;if(null!=s&&(l=s.shape,o.push(s)),v().getBool("WEBGL_PACK_NORMALIZATION")){const r=new Ds(t.shape,e.shape,n.shape,i,l,a);return this.compileAndRun(r,o)}const u=new Fs(t.shape,e.shape,n.shape,i,l,a);return this.compileAndRun(u,o)}localResponseNormalization4D(t,e,n,r,s){const a=v().getBool("WEBGL_PACK_NORMALIZATION")?new Wa(t.shape,e,n,r,s):new Pa(t.shape,e,n,r,s);return this.compileAndRun(a,[t])}LRNGrad(t,e,n,r,s,a,o){const i=new La(e.shape,r,s,a,o);return this.compileAndRun(i,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map(t=>at(t)),r=Ce(t.shape,t.dtype,n);return Po(r,e)}const n=new vo(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=v().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qa(t.shape,e,n):new ja(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);const r=new $a(t.shape,e.size,n);return this.compileAndRun(r,[t,e])}batchToSpaceND(t,e,n){N(t.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const r=e.reduce((t,e)=>t*e),s=_n(t.shape,e,r),a=Bn(s.length,e.length),o=Mn(t.shape,e,r),i=Pn(n,e.length),l=Ln(o,n,e.length);return Kt(t.reshape(s),a).reshape(o).slice(i,l)}spaceToBatchND(t,e,n){N(t.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const r=e.reduce((t,e)=>t*e),s=[[0,0]];s.push(...n);for(let n=1+e.length;n<t.shape.length;++n)s.push([0,0]);const a=t.pad(s),o=_n(a.shape,e,r,!1),i=Bn(o.length,e.length,!1),l=Mn(a.shape,e,r,!1),u=Kt(a.reshape(o),i);return qt(u,l)}reduce(t,e,n){const r=t.shape[0],s=t.shape[1],a=Oe(s),o=new Qa({windowSize:a,inSize:s,batchSize:r},e),i=this.compileAndRun(o,[t],n);return 1===i.shape[1]?i:this.reduce(i,e,n)}argReduce(t,e,n=null){let r=t.shape[0],s=t.shape[1];null!=n&&(r=n.shape[0],s=n.shape[1]);const a=Oe(s),o=new us({windowSize:a,inSize:s,batchSize:r},e,null==n),i=[t];null!=n&&i.push(n);const l=this.compileAndRun(o,i,"int32");return 1===l.shape[1]?l:this.argReduce(t,e,l)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,s=Oe(r[r.length-1]),a=new ks(r,s,e,null==n),o=null==n?[t]:[t,n],i=this.compileAndRun(a,o,"int32");return i.rank===t.rank?this.argReducePacked(t,e,i):i}sum(t,e){zt("sum",e,t.rank);const[n,r]=Ut(t.shape,e),s=_(r),a=t.as2D(-1,s),o=It(t.dtype);return this.reduce(a,"sum",o).reshape(n)}prod(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);const[n,r]=Ut(t.shape,e),s=_(r),a=t.as2D(-1,s),o=It(t.dtype);return this.reduce(a,"prod",o).reshape(n)}unsortedSegmentSum(t,e,n){let r=0;const s=Ht([r],t.rank);let a=t;null!=s&&(a=Kt(t,s),r=jt(1,t.rank)[0]);const o=Bo.computeOutShape(a.shape,r,n),i=_([a.shape[r]]),l=a.as2D(-1,i),u=It(t.dtype);let c=this.segOpCompute(l,"unsortedSegmentSum",e,u,n).reshape(o);return null!=s&&(c=Kt(c,Xt(s))),c}segOpCompute(t,e,n,r,s){const a=t.shape[0],o=t.shape[1],i=Bo.segOpComputeOptimalWindowSize(o,s),l=new io({windowSize:i,inSize:o,batchSize:a,numSegments:s},e),u=this.compileAndRun(l,[t,n],r);return u.shape[1]===s?u:(n=function(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return kt.runKernelFunc(()=>{if(t===e||t<e&&n<0||e<t&&n>1)return Ve([0],r);const s=nt(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),s[0]=t;for(let t=1;t<s.length;t++)s[t]=s[t-1]+n;return an(s,r)},{},null,"Range",s)}(0,s).tile([o/i]),this.segOpCompute(u,e,n,r,s))}argMinMaxReduce(t,e,n){const r=[e];if(zt("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!v().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,s]=Ut(t.shape,r),a=_(s),o=t.as2D(-1,a);return this.argReduce(o,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=t.shape[e];let a=t;for(let e=0;e<=Math.ceil(Math.log2(s))-1;e++){const n=new la(t.shape,!1,r),s=n.getCustomSetupFunc(e),o=a;a=this.compileAndRun(n,[a],a.dtype,s),o.dispose()}if(n){const e=new la(t.shape,n,r),s=a;a=this.compileAndRun(e,[a]),s.dispose()}return a}equal(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");const n=new Us("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}notEqual(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");const n=new Us("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}less(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");const n=new Us("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}lessEqual(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new Us("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greater(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");const n=new Us("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greaterEqual(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new Us("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalNot(t){const e=new yo(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new Us("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalOr(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new Us("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}select(t,e,n){const r=new lo(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],Rt(e.dtype,n.dtype))}where(t){Wn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Wo(t.shape,e)}topk(t,e,n){const r=t.dataSync();return Lo(r,t.shape,t.dtype,e)}min(t,e){zt("min",e,t.rank);const[n,r]=Ut(t.shape,e),s=_(r),a=t.as2D(-1,s);return this.reduce(a,"min",a.dtype).reshape(n)}minimum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Us("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}mod(t,e){const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Us("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}maximum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Us("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}all(t,e){zt("all",e,t.rank);const[n,r]=Ut(t.shape,e),s=_(r),a=t.as2D(-1,s);return this.reduce(a,"all",a.dtype).reshape(n)}any(t,e){zt("any",e,t.rank);const[n,r]=Ut(t.shape,e),s=_(r),a=t.as2D(-1,s);return this.reduce(a,"any",a.dtype).reshape(n)}floorDiv(t,e){if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");const n=new Us("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(n,[t,e],"int32")}add(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Ps);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);const n=Rt(t.dtype,e.dtype);if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Ps,n);const r=new Us(Ps,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}packedUnaryOp(t,e,n){const r=new Do(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(t,e,n,r,s=!1){const a=new zs(n,t.shape,e.shape,s);return this.compileAndRun(a,[t,e],r)}complexSeparableBinaryOp(t,e,n){const r=this.texData.get(t.dataId),s=this.texData.get(e.dataId),[a,o]=[[r.complexTensors.real,s.complexTensors.real],[r.complexTensors.imag,s.complexTensors.imag]].map(r=>{const[s,a]=r,o=this.makeComplexComponentTensorInfo(t,s),i=this.makeComplexComponentTensorInfo(e,a),l=new Us(n,t.shape,e.shape);return this.compileAndRun(l,[o,i],Rt(s.dtype,a.dtype))}),i=this.complex(a,o);return a.dispose(),o.dispose(),i}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>v().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map(t=>t.dtype).reduce((t,e)=>Rt(t,e)),n=t.map(t=>t.shape),r=v().getBool("WEBGL_PACK")?new ls(t[0].shape,n):new is(t[0].shape,n);return this.compileAndRun(r,t,e)}subtract(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Ls);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);const n=Rt(t.dtype,e.dtype);if(v().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Ls,t.dtype);const r=new Us(Ls,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}pow(t,e){const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Us("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=Rt(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)}ceil(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Eo,t.dtype);const e=new yo(t.shape,Eo);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Ao,t.dtype);const e=new yo(t.shape,Ao);return this.compileAndRun(e,[t])}sign(t){const e=new yo(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new yo(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new yo(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new yo(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new yo(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,To,t.dtype);const e=new yo(t.shape,To);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,So,t.dtype);const e=new yo(t.shape,So);return this.compileAndRun(e,[t])}softmax(t,e){const n=U([e],t.shape),r=Qt(t,n),s=Gt(r.shape,n),a=this.subtract(t,r.reshape(s)),o=this.exp(a),i=this.sum(o,n).reshape(s);return $e(o,i)}log(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new yo(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new yo(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new yo(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);const e=new yo(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new yo(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=v().getBool("WEBGL_PACK")?new Do(t.shape,No):new yo(t.shape,wo),this.compileAndRun(e,[t])}relu6(t){let e;return e=v().getBool("WEBGL_PACK")?new Do(t.shape,Oo):new yo(t.shape,$o),this.compileAndRun(e,[t])}prelu(t,e){const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs(Gs,t.shape,e.shape):new Us(Vs,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Fo,t.dtype);const e=new yo(t.shape,Ro);return this.compileAndRun(e,[t])}eluDer(t,e){const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Us("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new yo(t.shape,"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n");return this.compileAndRun(e,[t])}int(t){const e=new yo(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")}clip(t,e,n){let r;r=v().getBool("WEBGL_PACK_CLIP")?new Xs(t.shape):new Hs(t.shape);const s=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,s)}abs(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(v().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,bo,t.dtype);const e=new yo(t.shape,bo);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new js(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new yo(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new yo(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}sin(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(e,[t])}cos(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(e,[t])}tan(t){const e=new yo(t.shape,"return tan(x);");return this.compileAndRun(e,[t])}asin(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}atan2(t,e){const n=v().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zs("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Us("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}sinh(t){const e=new yo(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new yo(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new yo(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new yo(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new yo(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new yo(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(e,[t])}step(t,e){const n=new yo(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,e,n,r,s,a){const o=t.shape,i=this.texData.get(t.dataId),l=n.inChannels,u=o[0]*o[1]*o[2],c=n.outChannels,h="channelsLast"===n.dataFormat,d=(1===u||1===c)&&l>1e3,p=o[2]%2!=0&&!!i.isPacked;if(d||!v().getBool("WEBGL_LAZILY_UNPACK")||!v().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!p){const i=h?o[0]*o[1]*o[2]:o[0]*o[2]*o[3],l=this.reshape(t,[1,i,n.inChannels]),u=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:l,b:u,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a}),n.outShape)}const f=h?o[0]*o[1]*(o[2]+1):o[0]*o[2]*(o[3]+1),g={dataId:t.dataId,shape:[1,f,n.inChannels],dtype:t.dtype},m=i.shape;i.shape=i.shape.slice(),i.shape[i.shape.length-2]++,N(Jr(i.shape,g.shape),()=>`packed reshape ${i.shape} to ${g.shape} isn't free`);const x=this.reshape(e,[1,n.inChannels,n.outChannels]),y=this.fusedBatchMatMul({a:g,b:x,transposeA:!1,transposeB:!1,bias:r,activation:s,preluActivationWeights:a}),C=this.texData.get(y.dataId);return N(C.isPacked,()=>"batchMatMul result is expected to be packed"),i.shape=m,C.shape=n.outShape,le().makeTensorFromDataId(y.dataId,n.outShape,y.dtype)}conv2dWithIm2Row(t,e,n,r,s,a){const{filterWidth:o,filterHeight:i,inChannels:l,outWidth:u,outHeight:c,dataFormat:h}=n,d="channelsLast"===h,p=o*i*l,f=c*u,g=[p,f],m=t.squeeze([0]),x=e.reshape([1,p,-1]),v=new Ma(g,m.shape,n),y=this.compileAndRun(v,[m]).reshape([1,g[0],g[1]]),C=null!=r,b=null!=a,w=s?Uo(s,!0):null,$=new Ga(y.shape,[1,f,n.outChannels],!0,!1,C,w,b),R=[y,x];r&&R.push(r),b&&R.push(a);const I=this.compileAndRun($,R);return d?I.reshape([1,c,u,n.outChannels]):I.reshape([1,n.outChannels,c,u])}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n,r,s,a);if(v().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n,r,s,a);const o=null!=r,i=null!=a,l=s?Uo(s,!1):null,u=new ra(n,o,l,i),c=[t,e];return r&&c.push(r),a&&c.push(a),this.compileAndRun(u,c)}conv2d(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(v().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);const r=new ra(n);return this.compileAndRun(r,[t,e])}conv2dDerInput(t,e,n){const r=new Zs(n);return this.compileAndRun(r,[t,e])}conv2dDerFilter(t,e,n){const r=new Qs(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:a}){const o=v().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,i=s?Uo(s,o):null,l=[t,e],u=null!=r,c=null!=a;let h;return u&&l.push(r),c&&l.push(a),o?(h=new oa(n,u,i,c),this.compileAndRun(h,l)):(h=new aa(n,u,i,c),this.compileAndRun(h,l))}depthwiseConv2D(t,e,n){let r;return v().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new oa(n),this.compileAndRun(r,[t,e])):(r=new aa(n),this.compileAndRun(r,[t,e]))}depthwiseConv2DDerInput(t,e,n){const r=new na(n);return this.compileAndRun(r,[t,e])}depthwiseConv2DDerFilter(t,e,n){const r=new ea(n);return this.compileAndRun(r,[t,e])}conv3d(t,e,n){const r=new sa(n);return this.compileAndRun(r,[t,e])}conv3dDerInput(t,e,n){const r=new ta(n);return this.compileAndRun(r,[t,e])}conv3dDerFilter(t,e,n){const r=new Js(n);return this.compileAndRun(r,[t,e])}maxPool(t,e){const n=new Ka(e,"max",!1);return this.compileAndRun(n,[t])}avgPool(t,e){const n=new Ka(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}maxPoolBackprop(t,e,n,r){const s=new Ka(r,"max",!0),a=this.compileAndRun(s,[e]),o=new Va(r),i=this.compileAndRun(o,[t,a],e.dtype);return a.dispose(),i}avgPoolBackprop(t,e,n){const r=new Ns(n);return this.compileAndRun(r,[t],e.dtype)}cast(t,e){return Kn(t,e,this)}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let n=0;n<t.rank;n++)n!==e&&(r[s++]=t.shape[n]);const a=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const i=new Array(n);for(let n=0;n<i.length;n++)a[e]=n,i[n]=this.slice(t,a,o).reshape(r);return i}avgPool3d(t,e){const n=new Ya(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new Os(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new Ya(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const s=new Ya(r,"max",!0),a=this.compileAndRun(s,[e]),o=new Ua(r),i=this.compileAndRun(o,[t,a],e.dtype);return a.dispose(),i}reshape(t,e){const n=this.texData.get(t.dataId);if(n.isPacked&&!Jr(t.shape,e)&&(null===n.texture||!Jr(n.shape,e))){const n=this.packedReshape(t,e);return le().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}return Yn(t,e)}resizeBilinear(t,e,n,r){const s=v().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new eo(t.shape,e,n,r):new to(t.shape,e,n,r);return this.compileAndRun(s,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new Ja(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const s=new ro(t.shape,e,n,r);return this.compileAndRun(s,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new no(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const s=e?t:un(t),a=s.shape[0],o=s.shape[1],i=new za(a,o,n),l=i.getCustomSetupFunc(r);return this.compileAndRun(i,[s],"int32",l)}oneHot(t,e,n,r){const s=new Ha(t.size,e,n,r);return this.compileAndRun(s,[t])}diag(t){const e=new fa(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,n,r,s,a){const o=new ia(t.shape,e.shape,r,s,a);return this.compileAndRun(o,[t,e,n],"float32")}depthToSpace(t,e,n){N(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const r=t.shape[0],s="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],o="NHWC"===n?t.shape[3]:t.shape[1],i=s*e,l=a*e,u=o/(e*e),c=new pa("NHWC"===n?[r,i,l,u]:[r,u,i,l],e,n);return this.compileAndRun(c,[t])}split(t,e,n){return Mo(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:a,strides:o,outputSize:i}=gn(0,t,n),l=[i/a,a],u=t.reshape([s,r]),c=e.reshape([s,a]);if(0===i)return Yn(ge([]),n);const h=Me(0),d=new oo(s,r,u.rank,c.rank,o,l);return this.compileAndRun(d,[c,u,h]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:a,strides:o,outputSize:i}=gn(0,t,n),l=new oo(a,s,t.rank,e.rank,o,[i,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)}fft(t){return this.fftImpl(t,!1)}ifft(t){return this.fftImpl(t,!0)}fftImpl(t,e){const n=this.texData.get(t.dataId),r=new ba(ya,t.shape,e),s=new ba(Ca,t.shape,e),a=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],o=this.compileAndRun(r,a),i=this.compileAndRun(s,a),l=this.complex(o,i).as2D(t.shape[0],t.shape[1]);return o.dispose(),i.dispose(),l}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,a,o,i]=bn(t,e),l=e.reshape([a,r]),u=t.reshape([t.size/o,o]),c=new Ra(r,i,[a,o]);return this.compileAndRun(c,[u,l]).reshape(s)}fill(t,e,n){if("string"===(n=n||K(e))){const r=H(n,_(t));return r.fill(e),le().makeTensor(r,t,n,this)}{const r=new wa(t,e),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,s)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return Qn(t,e,n)}makeTensorInfo(t,e){const n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e){const{dataId:n}=this.makeTensorInfo(t,e);return le().makeTensorFromDataId(n,t,e,this)}unpackTensor(t){const e=new _o(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Xa(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[Kr(t.shape),...Yr(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},s=[Kr(e),...Yr(e)],a=new Za(s,n),o=this.runWebGLProgram(a,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:s}=e,a=Qr(r);let o;o=n?new da(a):new ha(a);return{dtype:s,shape:r,dataId:this.runWebGLProgram(o,[{shape:a,dtype:s,dataId:t}],s,null,!0).dataId}}runWebGLProgram(t,e,n,r,s=!1){const a=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(a.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===kr.DENSE){const e=Dr(t.outputShape);o.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===_(a.shape))return o.values=z(a.dtype,0),a;const i=[],l=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&_(e.shape)<=v().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),i.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!Jr(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),i.push(e),n=this.texData.get(e.dataId),t.shape=r}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const u={shape:a.shape,texData:o,isUniform:!1},c=function(t,e,n){let r="";e.concat(n).forEach(t=>{const e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${n}_${e}`});const s=t.userCode;let a=t.constructor.name;return a+="_"+r+"_"+s,a}(t,l,u),h=this.getAndSaveBinary(c,()=>function(t,e,n,r){const s=e.userCode,a=n.map((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),o=a.map(t=>t.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=xs(a,i,s,e.packedInputs),u=t.createProgram(l);let c=null;const h=t.getUniformLocation(u,"NAN",!1);1===v().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(u,"INFINITY",!1));const d={};for(let n=0;n<e.variableNames.length;n++){const r=e.variableNames[n],s=!1;d[r]=t.getUniformLocation(u,r,s),d["offset"+r]=t.getUniformLocation(u,"offset"+r,s)}return{program:e,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:o,outShapeInfo:i,infLoc:c,nanLoc:h}}(this.gpgpu,t,l,u)),d=null!=this.activeTimers;let p;if(d&&(p=this.startTimer()),function(t,e,n,r,s){Ba(e.inShapeInfos,n),Ba([e.outShapeInfo],[r]);const a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(a,o[0],o[1]):t.setOutputMatrixTexture(a,o[0],o[1]),t.setProgram(e.webGLProgram),1===v().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,r)=>{const s=e.program.variableNames[r],a=e.uniformLocations[s],o=e.uniformLocations["offset"+s];if(null!=a)if(n.isUniform)if(_(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(a,e)}else null!=n.texData.slice&&null!=o&&t.gl.uniform1i(o,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=s&&s(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,h,l,u,r),i.forEach(t=>this.disposeData(t.dataId)),d&&(p=this.endTimer(p),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(p)})),!v().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const t=this.unpackTensor(a);return this.disposeData(a.dataId),t}return a}compileAndRun(t,e,n,r,s=!1){n=n||e[0].dtype;const a=this.runWebGLProgram(t,e,n,r,s);return le().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!v().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=ue(()=>{if(!v().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=v().getBool("DEBUG");v().set("DEBUG",!1);const e=this.abs(Me(1e-8)).dataSync()[0];if(v().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:s,texture:a,usage:o,isPacked:i}=e;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=rt());let c=e.texShape;if(null==c&&(c=function(t,e=!1){let n=v().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?k(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=G(t);t=e.newShape}let r=_(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=Kr(t);let n=2,s=2;return t.length&&([n,s]=Yr(t)),r=e*(n/2)*(s/2),L(r).map(t=>2*t)}return L(r)}(n,i),e.texShape=c),null!=s){const t=Qr(n);let a,o=c[1],h=c[0];const d=s instanceof Uint8Array;i?([o,h]=_r(c[0],c[1]),a=new va(t,[h,o],d)):a=new xa(t,[h,o],d);const p=this.makeTensorInfo([h,o],r);this.texData.get(p.dataId).usage=d?Nr.PIXELS:Nr.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),o,h,s);const f=!0,g=this.runWebGLProgram(a,[p],r,null,f),m=this.texData.get(g.dataId);e.texture=m.texture,e.texShape=m.texShape,e.isPacked=m.isPacked,e.usage=m.usage,this.disposeData(p.dataId),this.texData.delete(g.dataId),e.values=null,l&&(this.uploadWaitMs+=rt()-u)}else{const t=this.acquireTexture(c,o,r,i);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*j(e)}}tr()&&he("webgl",()=>new Go,2);const zo={kernelName:"Square",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new yo(n.shape,"return x * x;");return r.runWebGLProgram(s,[n],n.dtype)}},{maxImpl:Ho,transposeImpl:Xo}=$r;function jo(t,e,n){const r=n.texData.get(t.dataId);return!r.isPacked||Jr(t.shape,e)||null!==r.texture&&Jr(r.shape,e)?{dataId:t.dataId,shape:e,dtype:t.dtype}:function(t,e,n){const r=[Kr(t.shape),...Yr(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Kr(e),...Yr(e)],o=new Za(a,r),i=n.runWebGLProgram(o,[s],t.dtype,null,!0);return{dataId:i.dataId,shape:e,dtype:i.dtype}}(t,e,n)}function qo(t,e,n,r){const s=_(e),a=jo(t,[_(t.shape)/s,s],r),o=function t(e,n,r,s){const[a,o]=e.shape,i=Oe(o),l=new Qa({windowSize:i,inSize:o,batchSize:a},r),u=s.runWebGLProgram(l,[e],n);return 1===u.shape[1]?u:t(u,n,r,s)}(a,t.dtype,"max",r);return a.dataId!==t.dataId&&r.disposeData(a.dataId),jo(o,n,r)}class Ko{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;const r=As(this.rank),s=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let e=0;e<t.length;e++)r[t[e]]=n[e];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class Yo{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=As(this.rank),s=cs("rc",this.rank),a=new Array(this.rank);for(let t=0;t<e.length;t++)a[e[t]]=s[t];const o=`vec2(${a.slice(-2).join()})`,i=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${i}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${i}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}const Qo={kernelName:"Max",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{reductionIndices:s,keepDims:a}=e,o=n,i=r.shape.length,l=U(s,r.shape);let u=l;const c=Ht(u,i),h=null!=c,d=o.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const t=o.texData.get(p.dataId).values,e=new Array(i);for(let t=0;t<e.length;t++)e[t]=r.shape[c[t]];const n=Xo(t,r.shape,r.dtype,c,e);p=o.makeTensorInfo(e,r.dtype);o.texData.get(p.dataId).values=n}else p=function(t,e,n){const r=v().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yo(t.shape,e):new Ko(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}(r,c,o);u=jt(u.length,i)}zt("max",u,i);const[f,g]=Ut(p.shape,u);let m,x=f;if(a&&(x=Gt(f,l)),d){const t=o.texData.get(p.dataId).values,e=Ho(t,_(g),x,r.dtype);m=o.makeTensorInfo(x,r.dtype);o.texData.get(m.dataId).values=e}else m=qo(p,g,x,o);return h&&o.disposeData(p.dataId),m}};const Zo={kernelName:"Div",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t;return function(t,e,n){let r=new Us("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return v().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(r=new zs("\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",t.shape,e.shape,!0)),n.runWebGLProgram(r,[t,e],"float32")}(n,r,e)}},Jo={kernelName:"Cast",gradFunc:t=>({x:()=>t.clone()})},ti={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,a=n,o=r,i=Ee(a.shape,o.shape);return{a:()=>{const e=Zt(o,"float32");let n=Pt(t,Pt(e,Bt(a,Lt(e,Me(1)))));const r=Ie(a.shape,i);return r.length>0&&(n=We(n,r)),qt(n,a.shape)},b:()=>{const e=De(a,0),n=Ae(e,Pe(a),Te(a));let r=Pt(t,Pt(s,n));const l=Ie(o.shape,i);return l.length>0&&(r=We(r,l)),qt(r,o.shape)}}}},ei={kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ee(n.shape,r.shape);return{a:()=>{const e=Pt(t,Zt(r,"float32")),a=Ie(n.shape,s);return a.length>0?qt(We(e,a),n.shape):e},b:()=>{const e=Pt(t,Zt(n,"float32")),a=Ie(r.shape,s);return a.length>0?qt(We(e,a),r.shape):e}}}},ni={kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Pt(t,Pt(n.toFloat(),2))}}},ri={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ee(n.shape,r.shape);return{a:()=>{let e=t;const r=Ie(n.shape,s);return r.length>0&&(e=e.sum(r)),e.reshape(n.shape)},b:()=>{let e=t;const n=Ie(r.shape,s);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)}}}};function si(t,e,n,r,s){return e.rank<n.rank&&(e=qt(e,Gt(e.shape,r))),t.rank<n.rank&&(t=qt(t,Gt(t.shape,r))),{x:()=>{const r=Pt(t,Zt(ke(n,e),t.dtype));return null==s?r:Kt(r,s)}}}const ai={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:s}=r,[a,o]=e,i=U(s,a.shape),l=Ht(i,a.rank),u=si(t,o,a,i,l);return{x:()=>{let t=u.x();return null!=l&&(t=Kt(t)),t}}}},oi={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,[a,o]=e,i=U(s,a.shape),l=Ht(i,a.rank),u=si(t,o,a,i,l);return{x:()=>{let t=u.x();return null!=l&&(t=Kt(t)),t}}}},ii={kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ee(n.shape,r.shape);return{a:()=>{let e=t;const r=Ie(n.shape,s);return r.length>0&&(e=We(e,r)),qt(e,n.shape)},b:()=>{let e=t;const n=Ie(r.shape,s);return n.length>0&&(e=We(e,n)),qt(Le(e),r.shape)}}}},li={kernelName:"Div",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Ee(n.shape,r.shape);return{a:()=>{const e=$e(t,r.toFloat()),a=Ie(n.shape,s);return a.length>0?We(e,a).reshape(n.shape):e},b:()=>{let e=Pt(t,n.toFloat());const a=Ie(r.shape,s);a.length>0&&(e=qt(We(e,a),r.shape));const o=ze(r);return Le($e(e,o.toFloat()))}}}},ui={kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,s=r.shape.slice(),{axis:a}=n;U(a,r.shape).forEach(t=>{s[t]=1});const o=qt(t,s),i=Pt(o,Ue(r.shape,"float32"));return{x:()=>i}}},ci={kernelName:"Reshape",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>qt(t,n.shape)}}};A(e.castConfig),A(n.powConfig),A(r.multiplyConfig),A(Rr),A(s.addConfig),A(a.minConfig),A(Ir),A(o.subConfig),A(Er),A(i.sumConfig),A(l.reshapeConfig),A(u.castConfig),A(c.powConfig),A(h.multiplyConfig),A(zo),A(d.addConfig),A(p.minConfig),A(Qo),A(f.subConfig),A(Zo),A(g.sumConfig),A(m.reshapeConfig),T(Jo),T(ti),T(ei),T(ni),T(ri),T(ai),T(oi),T(ii),T(li),T(ui),T(ci);const hi=dn(Me(Math.random())),di=dn(Me(Math.random())),pi=dn(Me(Math.random())),fi=dn(Me(Math.random())),gi=Fn.sgd(.5);function mi(t){return ue(()=>hi.mul(t.pow(Me(3,"int32"))).add(di.mul(t.square())).add(pi.mul(t)).add(fi))}async function xi(){const t=function(t,e,n=.04){return ue(()=>{const[r,s,a,o]=[Me(e.a),Me(e.b),Me(e.c),Me(e.d)],i=sn([t],-1,1),l=Me(3,"int32"),u=r.mul(i.pow(l)).add(s.mul(i.square())).add(a.mul(i)).add(o).add(rn([t],0,n)),c=u.min(),h=u.max().sub(c);return{xs:i,ys:u.sub(c).div(h)}})}(100,{a:-.8,b:-.2,c:.9,d:.5}),e=mi(t.xs);console.log("Predictions before",e.dataSync()),await async function(t,e,n){for(let r=0;r<n;r++)gi.minimize(()=>{const n=mi(t);return r=e,n.sub(r).square().mean();var r}),await new Promise(t=>Dn(()=>t()))}(t.xs,t.ys,75);const n=mi(t.xs);console.log("Predictions after",n.dataSync()),e.dispose(),n.dispose()}var vi;(vi=async()=>{await xi()},kt.profile(vi)).then(t=>{const e=new Set(t.kernels.map(t=>t.name));console.log(Array.from(e))})}));
//# sourceMappingURL=training_rollup_bundle.js.map
