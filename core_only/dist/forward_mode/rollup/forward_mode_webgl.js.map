{"version":3,"file":"forward_mode_webgl.js","sources":["../../../../../tfjs-core-workspace/tfjs-core/dist/environment.js","../../../../../tfjs-core-workspace/tfjs-core/dist/global_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/kernel_names.js","../../../../../tfjs-core-workspace/tfjs-core/dist/kernel_registry.js","../../../../../tfjs-core-workspace/tfjs-core/dist/util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/profiler.js","../../../../../tfjs-core-workspace/tfjs-core/dist/tensor_format.js","../../../../../tfjs-core-workspace/tfjs-core/dist/tensor.js","../../../../../tfjs-core-workspace/tfjs-core/dist/types.js","../../../../../tfjs-core-workspace/tfjs-core/dist/tensor_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/engine.js","../../../../../tfjs-core-workspace/tfjs-core/dist/tape.js","../../../../../tfjs-core-workspace/tfjs-core/dist/tensor_util_env.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/operation.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/complex.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/tensor_ops_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/tensor.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/cast.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/reshape.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/transpose.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/axis_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/max.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/gather_nd_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/scatter_nd_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/globals.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/floorDiv.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/div.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/mul.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/conv_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/concat_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/slice.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/slice_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/buffer.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/broadcast_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/elu.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/reduce_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/segment_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/imag.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/real.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/scalar.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/sum.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/zeros.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/prelu.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/tensor1d.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/relu.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/relu6.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/softmax.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/step.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/array_ops_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/log.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/complex_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/backend_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/fused_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/rotate_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/selu_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/erf_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/split_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/device_util.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/backend.js","../../../../../tfjs-core-workspace/tfjs-core/dist/flags.js","../../../../../tfjs-core-workspace/tfjs-core/dist/platforms/platform_browser.js","../../../../../tfjs-core-workspace/tfjs-core/dist/platforms/platform_node.js","../../../../../tfjs-core-workspace/tfjs-converter/dist/data/compiled_api.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/canvas_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/tex_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/webgl_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/flags_webgl.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/addn_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/addn_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/argminmax_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/packing_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/glsl_version.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/shader_compiler_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/shader_compiler.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/batchnorm_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/binaryop_complex_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/binaryop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/binaryop_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/clip_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/clip_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/complex_abs_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/concat_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/concat_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/conv_backprop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/conv_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/conv_gpu_depthwise.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/crop_and_resize_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/cumsum_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/decode_matrix_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/depth_to_space_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/diag_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/encode_float_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/encode_float_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/encode_matrix_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/fft_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/fill_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/gather_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/gather_nd_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/gpgpu_util.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/gpgpu_context.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/gpgpu_math.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/im2col_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/lrn_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/lrn_grad_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/lrn_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/mulmat_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/multinomial_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/onehot_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/pack_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/pad_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/pad_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/pool_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/reduce_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/reshape_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/resize_bilinear_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/reverse_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/reverse_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/scatter_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/segment_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/select_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/slice_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/slice_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/strided_slice_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/texture_manager.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/tile_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/unaryop_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/unaryop_packed_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/unpack_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/backend_webgl.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/split_shared.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/tile_impl.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/topk_impl.js","../../../../../tfjs-core-workspace/tfjs-core/dist/backends/where_impl.js","../../../../../tfjs-core-workspace/tfjs-core/dist/ops/range.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/base.js","../../../../../tfjs-core-workspace/tfjs-backend-cpu/dist/kernels/Max_impl.js","../../../../../tfjs-core-workspace/tfjs-backend-cpu/dist/kernels/Transpose_impl.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernel_utils/shared.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernel_utils/reshape.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernels/Max_impl.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernel_utils/reduce.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/transpose_gpu.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/transpose_packed_gpu.js","../../../custom_tfjs_webgl.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernels/Max.js","../../../../../tfjs-core-workspace/tfjs-backend-webgl/dist/kernels/Transpose_impl.js","../../../forward_mode_webgl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.\nconst TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';\n/**\n * The environment contains evaluated flags as well as the registered platform.\n * This is always used as a global singleton and can be retrieved with\n * `tf.env()`.\n */\n/** @doc {heading: 'Environment'} */\nexport class Environment {\n    // tslint:disable-next-line: no-any\n    constructor(global) {\n        this.global = global;\n        this.flags = {};\n        this.flagRegistry = {};\n        this.urlFlags = {};\n        this.populateURLFlags();\n    }\n    setPlatform(platformName, platform) {\n        if (this.platform != null) {\n            console.warn(`Platform ${this.platformName} has already been set. ` +\n                `Overwriting the platform with ${platform}.`);\n        }\n        this.platformName = platformName;\n        this.platform = platform;\n    }\n    registerFlag(flagName, evaluationFn, setHook) {\n        this.flagRegistry[flagName] = { evaluationFn, setHook };\n        // Override the flag value from the URL. This has to happen here because the\n        // environment is initialized before flags get registered.\n        if (this.urlFlags[flagName] != null) {\n            const flagValue = this.urlFlags[flagName];\n            console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);\n            this.set(flagName, flagValue);\n        }\n    }\n    async getAsync(flagName) {\n        if (flagName in this.flags) {\n            return this.flags[flagName];\n        }\n        this.flags[flagName] = await this.evaluateFlag(flagName);\n        return this.flags[flagName];\n    }\n    get(flagName) {\n        if (flagName in this.flags) {\n            return this.flags[flagName];\n        }\n        const flagValue = this.evaluateFlag(flagName);\n        if (flagValue instanceof Promise) {\n            throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` +\n                `Please use getAsync() instead.`);\n        }\n        this.flags[flagName] = flagValue;\n        return this.flags[flagName];\n    }\n    getNumber(flagName) {\n        return this.get(flagName);\n    }\n    getBool(flagName) {\n        return this.get(flagName);\n    }\n    getFlags() {\n        return this.flags;\n    }\n    // For backwards compatibility.\n    get features() {\n        return this.flags;\n    }\n    set(flagName, value) {\n        if (this.flagRegistry[flagName] == null) {\n            throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);\n        }\n        this.flags[flagName] = value;\n        if (this.flagRegistry[flagName].setHook != null) {\n            this.flagRegistry[flagName].setHook(value);\n        }\n    }\n    evaluateFlag(flagName) {\n        if (this.flagRegistry[flagName] == null) {\n            throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);\n        }\n        return this.flagRegistry[flagName].evaluationFn();\n    }\n    setFlags(flags) {\n        this.flags = Object.assign({}, flags);\n    }\n    reset() {\n        this.flags = {};\n        this.urlFlags = {};\n        this.populateURLFlags();\n    }\n    populateURLFlags() {\n        if (typeof this.global === 'undefined' ||\n            typeof this.global.location === 'undefined' ||\n            typeof this.global.location.search === 'undefined') {\n            return;\n        }\n        const urlParams = getQueryParams(this.global.location.search);\n        if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {\n            const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');\n            keyValues.forEach(keyValue => {\n                const [key, value] = keyValue.split(':');\n                this.urlFlags[key] = parseValue(key, value);\n            });\n        }\n    }\n}\nexport function getQueryParams(queryString) {\n    const params = {};\n    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {\n        decodeParam(params, t[0], t[1]);\n        return t.join('=');\n    });\n    return params;\n}\nfunction decodeParam(params, name, value) {\n    params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\nfunction parseValue(flagName, value) {\n    value = value.toLowerCase();\n    if (value === 'true' || value === 'false') {\n        return value === 'true';\n    }\n    else if (`${+value}` === value) {\n        return +value;\n    }\n    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);\n}\n/**\n * Returns the current environment (a global singleton).\n *\n * The environment object contains the evaluated feature values as well as the\n * active platform.\n */\n/** @doc {heading: 'Environment'} */\nexport function env() {\n    return ENV;\n}\nexport let ENV = null;\nexport function setEnvironmentGlobal(environment) {\n    ENV = environment;\n}\n//# sourceMappingURL=environment.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Note that the identifier globalNameSpace is scoped to this module, but will\n// always resolve to the same global object regardless of how the module is\n// resolved.\n// tslint:disable-next-line:no-any\nlet globalNameSpace;\n// tslint:disable-next-line:no-any\nexport function getGlobalNamespace() {\n    if (globalNameSpace == null) {\n        // tslint:disable-next-line:no-any\n        let ns;\n        if (typeof (window) !== 'undefined') {\n            ns = window;\n        }\n        else if (typeof (global) !== 'undefined') {\n            ns = global;\n        }\n        else if (typeof (process) !== 'undefined') {\n            ns = process;\n        }\n        else if (typeof (self) !== 'undefined') {\n            ns = self;\n        }\n        else {\n            throw new Error('Could not find a global object');\n        }\n        globalNameSpace = ns;\n    }\n    return globalNameSpace;\n}\n// tslint:disable-next-line:no-any\nfunction getGlobalMap() {\n    const ns = getGlobalNamespace();\n    if (ns._tfGlobals == null) {\n        ns._tfGlobals = new Map();\n    }\n    return ns._tfGlobals;\n}\n/**\n * Returns a globally accessible 'singleton' object.\n *\n * @param key the name of the object\n * @param init a function to initialize to initialize this object\n *             the first time it is fetched.\n */\nexport function getGlobal(key, init) {\n    const globalMap = getGlobalMap();\n    if (globalMap.has(key)) {\n        return globalMap.get(key);\n    }\n    else {\n        const singleton = init();\n        globalMap.set(key, singleton);\n        return globalMap.get(key);\n    }\n}\n//# sourceMappingURL=global_util.js.map","export const Abs = 'Abs';\nexport const Acos = 'Acos';\nexport const Acosh = 'Acosh';\nexport const Add = 'Add';\nexport const AddN = 'AddN';\nexport const All = 'All';\nexport const Any = 'Any';\nexport const ArgMax = 'ArgMax';\nexport const ArgMin = 'ArgMin';\nexport const Asin = 'Asin';\nexport const Asinh = 'Asinh';\nexport const Atan = 'Atan';\nexport const Atanh = 'Atanh';\nexport const Atan2 = 'Atan2';\nexport const AvgPool = 'AvgPool';\nexport const AvgPoolBackprop = 'AvgPoolBackprop';\nexport const AvgPool3D = 'AvgPool3D';\nexport const AvgPool3DBackprop = 'AvgPool3DBackprop';\nexport const BatchMatMul = 'BatchMatMul';\nexport const BatchToSpaceND = 'BatchToSpaceND';\nexport const BroadcastTo = 'BroadcastTo';\nexport const Cast = 'Cast';\nexport const Ceil = 'Ceil';\nexport const ClipByValue = 'ClipByValue';\nexport const Complex = 'Complex';\nexport const Concat = 'Concat';\nexport const Conv2D = 'Conv2D';\nexport const Conv2DBackpropFilter = 'Conv2DBackpropFilter';\nexport const Conv2DBackpropInput = 'Conv2DBackpropInput';\nexport const Conv3D = 'Conv3D';\nexport const Conv3DBackpropFilterV2 = 'Conv3DBackpropFilterV2';\nexport const Conv3DBackpropInputV2 = 'Conv3DBackpropInputV2';\nexport const Cos = 'Cos';\nexport const Cosh = 'Cosh';\nexport const Cumsum = 'Cumsum';\nexport const CropAndResize = 'CropAndResize';\nexport const DepthToSpace = 'DepthToSpace';\nexport const DepthwiseConv2dNative = 'DepthwiseConv2dNative';\nexport const DepthwiseConv2dNativeBackpropFilter = 'DepthwiseConv2dNativeBackpropFilter';\nexport const DepthwiseConv2dNativeBackpropInput = 'DepthwiseConv2dNativeBackpropInput';\nexport const Diag = 'Diag';\nexport const Dilation2D = 'Dilation2D';\nexport const Dilation2DBackpropInput = 'Dilation2DBackpropInput';\nexport const Dilation2DBackpropFilter = 'Dilation2DBackpropFilter';\nexport const Div = 'Div';\nexport const Elu = 'Elu';\nexport const EluGrad = 'EluGrad';\nexport const Erf = 'Erf';\nexport const Equal = 'Equal';\nexport const Exp = 'Exp';\nexport const Expm1 = 'Expm1';\nexport const FFT = 'FFT';\nexport const Floor = 'Floor';\nexport const FloorDiv = 'FloorDiv';\nexport const Fill = 'Fill';\nexport const FusedBatchNorm = 'FusedBatchNorm';\nexport const GatherV2 = 'GatherV2';\nexport const GatherNd = 'GatherNd';\nexport const Greater = 'Greater';\nexport const GreaterEqual = 'GreaterEqual';\nexport const Identity = 'Identity';\nexport const IFFT = 'IFFT';\nexport const Imag = 'Imag';\nexport const IsFinite = 'IsFinite';\nexport const IsInf = 'IsInf';\nexport const IsNan = 'IsNan';\nexport const Less = 'Less';\nexport const LessEqual = 'LessEqual';\nexport const LinSpace = 'LinSpace';\nexport const Log = 'Log';\nexport const Log1p = 'Log1p';\nexport const LogicalAnd = 'LogicalAnd';\nexport const LogicalNot = 'LogicalNot';\nexport const LogicalOr = 'LogicalOr';\nexport const LogSoftmax = 'LogSoftmax';\nexport const LRN = 'LRN';\nexport const LRNBackprop = 'LRNBackprop';\nexport const Max = 'Max';\nexport const Maximum = 'Maximum';\nexport const MaxPool = 'MaxPool';\nexport const MaxPoolBackprop = 'MaxPoolBackprop';\nexport const MaxPool3D = 'MaxPool3D';\nexport const MaxPool3DBackprop = 'MaxPool3DBackprop';\nexport const MaxPoolWithArgmax = 'MaxPoolWithArgmax';\nexport const Mean = 'Mean';\nexport const Min = 'Min';\nexport const Minimum = 'Minimum';\nexport const Mod = 'Mod';\nexport const Multiply = 'Multiply';\nexport const Negate = 'Negate';\nexport const NotEqual = 'NotEqual';\nexport const NonMaxSuppressionV3 = 'NonMaxSuppressionV3';\nexport const NonMaxSuppressionV4 = 'NonMaxSuppressionV4';\nexport const NonMaxSuppressionV5 = 'NonMaxSuppressionV5';\nexport const OnesLike = 'OnesLike';\nexport const OneHot = 'OneHot';\nexport const PadV2 = 'PadV2';\nexport const Pool = 'Pool';\nexport const Pow = 'Pow';\nexport const Prelu = 'Prelu';\nexport const Prod = 'Prod';\nexport const Range = 'Range';\nexport const Real = 'Real';\nexport const Reciprocal = 'Reciprocal';\nexport const Relu = 'Relu';\nexport const Reshape = 'Reshape';\nexport const ResizeNearestNeighbor = 'ResizeNearestNeighbor';\nexport const ResizeNearestNeighborGrad = 'ResizeNearestNeighborGrad';\nexport const ResizeBilinear = 'ResizeBilinear';\nexport const ResizeBilinearGrad = 'ResizeBilinearGrad';\nexport const Relu6 = 'Relu6';\nexport const Reverse = 'Reverse';\nexport const Round = 'Round';\nexport const Rsqrt = 'Rsqrt';\nexport const ScatterNd = 'ScatterNd';\nexport const SelectV2 = 'SelectV2';\nexport const Selu = 'Selu';\nexport const Slice = 'Slice';\nexport const Sin = 'Sin';\nexport const Sinh = 'Sinh';\nexport const Sign = 'Sign';\nexport const Sigmoid = 'Sigmoid';\nexport const Softplus = 'Softplus';\nexport const Sqrt = 'Sqrt';\nexport const Sum = 'Sum';\nexport const SpaceToBatchND = 'SpaceToBatchND';\nexport const SplitV = 'SplitV';\nexport const Softmax = 'Softmax';\nexport const SquaredDifference = 'SquaredDifference';\nexport const Square = 'Square';\nexport const Sub = 'Sub';\nexport const SparseToDense = 'SparseToDense';\nexport const StridedSlice = 'StridedSlice';\nexport const Tan = 'Tan';\nexport const Tanh = 'Tanh';\nexport const Tile = 'Tile';\nexport const TopK = 'TopK';\nexport const Transpose = 'Transpose';\nexport const Unpack = 'Unpack';\nexport const UnsortedSegmentSum = 'UnsortedSegmentSum';\nexport const ZerosLike = 'ZerosLike';\n/**\n * TensorFlow.js-only kernels\n */\nexport const Step = 'Step';\nexport const FromPixels = 'FromPixels';\nexport const RotateWithOffset = 'RotateWithOffset';\nexport const _FusedMatMul = '_FusedMatMul';\nexport const FusedConv2D = 'FusedConv2D';\nexport const FusedDepthwiseConv2D = 'FusedDepthwiseConv2D';\n//# sourceMappingURL=kernel_names.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\nimport { getGlobal } from './global_util';\nconst kernelRegistry = getGlobal('kernelRegistry', () => new Map());\nconst gradRegistry = getGlobal('gradRegistry', () => new Map());\n/**\n * Returns the kernel function (code) associated with the provided names.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n */\nexport function getKernel(kernelName, backendName) {\n    const key = makeKey(kernelName, backendName);\n    return kernelRegistry.get(key);\n}\n/**\n * Returns the registered gradient info associated with the provided kernel.\n * @param kernelName The official TF kernel name.\n */\nexport function getGradient(kernelName) {\n    return gradRegistry.get(kernelName);\n}\nexport function getKernelsForBackend(backendName) {\n    const it = kernelRegistry.entries();\n    const result = [];\n    while (true) {\n        const { done, value } = it.next();\n        if (done) {\n            break;\n        }\n        const [key, config] = value;\n        const [backend,] = key.split('_');\n        if (backend === backendName) {\n            result.push(config);\n        }\n    }\n    return result;\n}\n/**\n * Registers the function (forward pass) for the kernel in a global registry.\n *\n * @param config A config object with the following properties:\n * - `kernelName` The official name of the kernel.\n * - `backendName` The official name of the backend.\n * - `kernelFunc` The function to run during the forward pass of the kernel.\n * - `setupFunc` Optional. Gets called once, after the backend initializes.\n * - `disposeFunc` Optional. Gets called once, right before the backend is\n * disposed.\n */\nexport function registerKernel(config) {\n    const { kernelName, backendName } = config;\n    const key = makeKey(kernelName, backendName);\n    if (kernelRegistry.has(key)) {\n        console.warn(`The kernel '${kernelName}' for backend ` +\n            `'${backendName}' is already registered`);\n    }\n    kernelRegistry.set(key, config);\n}\n/**\n * Registers a gradient function for a given kernel in the global registry,\n * to be used during the back-propagation of that kernel.\n *\n * @param config An object with the following properties:\n * - `kernelName` The name of the kernel that the gradient function is for.\n * - `gradFunc` The function to run during back-propagation.\n */\nexport function registerGradient(config) {\n    const { kernelName } = config;\n    if (gradRegistry.has(kernelName)) {\n        // TODO (yassogba) after 3.0 assess whether we need to keep this gated\n        // to debug mode.\n        if (env().getBool('DEBUG')) {\n            console.warn(`Overriding the gradient for '${kernelName}'`);\n        }\n    }\n    gradRegistry.set(kernelName, config);\n}\n/**\n * Removes the kernel function from the registry.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n *\n */\nexport function unregisterKernel(kernelName, backendName) {\n    const key = makeKey(kernelName, backendName);\n    if (!kernelRegistry.has(key)) {\n        throw new Error(`The kernel '${kernelName}' for backend ` +\n            `'${backendName}' is not registered`);\n    }\n    kernelRegistry.delete(key);\n}\n/** Removes the registered gradient from the global registry. */\nexport function unregisterGradient(kernelName) {\n    if (!gradRegistry.has(kernelName)) {\n        throw new Error(`The gradient '${kernelName}' for backend is not registered`);\n    }\n    gradRegistry.delete(kernelName);\n}\nfunction makeKey(kernelName, backendName) {\n    return `${backendName}_${kernelName}`;\n}\n//# sourceMappingURL=kernel_registry.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\n/**\n * Shuffles the array in-place using Fisher-Yates algorithm.\n *\n * ```js\n * const a = [1, 2, 3, 4, 5];\n * tf.util.shuffle(a);\n * console.log(a);\n * ```\n *\n * @param array The array to shuffle in-place.\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\n// tslint:disable-next-line:no-any\nexport function shuffle(array) {\n    let counter = array.length;\n    let temp = 0;\n    let index = 0;\n    // While there are elements in the array\n    while (counter > 0) {\n        // Pick a random index\n        index = (Math.random() * counter) | 0;\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        temp = array[counter];\n        array[counter] = array[index];\n        array[index] = temp;\n    }\n}\n/** Clamps a value to a specified range. */\nexport function clamp(min, x, max) {\n    return Math.max(min, Math.min(x, max));\n}\nexport function nearestLargerEven(val) {\n    return val % 2 === 0 ? val : val + 1;\n}\nexport function sum(arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n/**\n * Returns a sample from a uniform [a, b) distribution.\n *\n * @param a The minimum support (inclusive).\n * @param b The maximum support (exclusive).\n * @return A pseudorandom number on the half-open interval [a,b).\n */\nexport function randUniform(a, b) {\n    const r = Math.random();\n    return (b * r) + (1 - r) * a;\n}\n/** Returns the squared Euclidean distance between two vectors. */\nexport function distSquared(a, b) {\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n        const diff = Number(a[i]) - Number(b[i]);\n        result += diff * diff;\n    }\n    return result;\n}\n/**\n * Asserts that the expression is true. Otherwise throws an error with the\n * provided message.\n *\n * ```js\n * const x = 2;\n * tf.util.assert(x === 2, 'x is not 2');\n * ```\n *\n * @param expr The expression to assert (as a boolean).\n * @param msg A function that returns the message to report when throwing an\n *     error. We use a function for performance reasons.\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\nexport function assert(expr, msg) {\n    if (!expr) {\n        throw new Error(typeof msg === 'string' ? msg : msg());\n    }\n}\nexport function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = '') {\n    assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n}\nexport function assertNonNull(a) {\n    assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);\n}\n// NOTE: We explicitly type out what T extends instead of any so that\n// util.flatten on a nested array of number doesn't try to infer T as a\n// number[][], causing us to explicitly type util.flatten<number>().\n/**\n *  Flattens an arbitrarily nested array.\n *\n * ```js\n * const a = [[1, 2], [3, 4], [5, [6, [7]]]];\n * const flat = tf.util.flatten(a);\n * console.log(flat);\n * ```\n *\n *  @param arr The nested array to flatten.\n *  @param result The destination array which holds the elements.\n *  @param skipTypedArray If true, avoids flattening the typed arrays. Defaults\n *      to false.\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\nexport function flatten(arr, result = [], skipTypedArray = false) {\n    if (result == null) {\n        result = [];\n    }\n    if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {\n        for (let i = 0; i < arr.length; ++i) {\n            flatten(arr[i], result, skipTypedArray);\n        }\n    }\n    else {\n        result.push(arr);\n    }\n    return result;\n}\n/**\n * Returns the size (number of elements) of the tensor given its shape.\n *\n * ```js\n * const shape = [3, 4, 2];\n * const size = tf.util.sizeFromShape(shape);\n * console.log(size);\n * ```\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\nexport function sizeFromShape(shape) {\n    if (shape.length === 0) {\n        // Scalar.\n        return 1;\n    }\n    let size = shape[0];\n    for (let i = 1; i < shape.length; i++) {\n        size *= shape[i];\n    }\n    return size;\n}\nexport function isScalarShape(shape) {\n    return shape.length === 0;\n}\nexport function arraysEqual(n1, n2) {\n    if (n1 === n2) {\n        return true;\n    }\n    if (n1 == null || n2 == null) {\n        return false;\n    }\n    if (n1.length !== n2.length) {\n        return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n        if (n1[i] !== n2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isInt(a) {\n    return a % 1 === 0;\n}\nexport function tanh(x) {\n    // tslint:disable-next-line:no-any\n    if (Math.tanh != null) {\n        // tslint:disable-next-line:no-any\n        return Math.tanh(x);\n    }\n    if (x === Infinity) {\n        return 1;\n    }\n    else if (x === -Infinity) {\n        return -1;\n    }\n    else {\n        const e2x = Math.exp(2 * x);\n        return (e2x - 1) / (e2x + 1);\n    }\n}\nexport function sizeToSquarishShape(size) {\n    const width = Math.ceil(Math.sqrt(size));\n    return [width, Math.ceil(size / width)];\n}\n/**\n * Creates a new array with randomized indicies to a given quantity.\n *\n * ```js\n * const randomTen = tf.util.createShuffledIndices(10);\n * console.log(randomTen);\n * ```\n *\n * @param number Quantity of how many shuffled indicies to create.\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\nexport function createShuffledIndices(n) {\n    const shuffledIndices = new Uint32Array(n);\n    for (let i = 0; i < n; ++i) {\n        shuffledIndices[i] = i;\n    }\n    shuffle(shuffledIndices);\n    return shuffledIndices;\n}\nexport function rightPad(a, size) {\n    if (size <= a.length) {\n        return a;\n    }\n    return a + ' '.repeat(size - a.length);\n}\nexport function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {\n    return new Promise((resolve, reject) => {\n        let tryCount = 0;\n        const tryFn = () => {\n            if (checkFn()) {\n                resolve();\n                return;\n            }\n            tryCount++;\n            const nextBackoff = delayFn(tryCount);\n            if (maxCounter != null && tryCount >= maxCounter) {\n                reject();\n                return;\n            }\n            setTimeout(tryFn, nextBackoff);\n        };\n        tryFn();\n    });\n}\n/**\n * Given the full size of the array and a shape that may contain -1 as the\n * implicit dimension, returns the inferred shape where -1 is replaced.\n * E.g. For shape=[2, -1, 3] and size=24, it will return [2, 4, 3].\n *\n * @param shape The shape, which may contain -1 in some dimension.\n * @param size The full size (number of elements) of the array.\n * @return The inferred shape where -1 is replaced with the inferred size.\n */\nexport function inferFromImplicitShape(shape, size) {\n    let shapeProd = 1;\n    let implicitIdx = -1;\n    for (let i = 0; i < shape.length; ++i) {\n        if (shape[i] >= 0) {\n            shapeProd *= shape[i];\n        }\n        else if (shape[i] === -1) {\n            if (implicitIdx !== -1) {\n                throw Error(`Shapes can only have 1 implicit size. ` +\n                    `Found -1 at dim ${implicitIdx} and dim ${i}`);\n            }\n            implicitIdx = i;\n        }\n        else if (shape[i] < 0) {\n            throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);\n        }\n    }\n    if (implicitIdx === -1) {\n        if (size > 0 && size !== shapeProd) {\n            throw Error(`Size(${size}) must match the product of shape ${shape}`);\n        }\n        return shape;\n    }\n    if (shapeProd === 0) {\n        throw Error(`Cannot infer the missing size in [${shape}] when ` +\n            `there are 0 elements`);\n    }\n    if (size % shapeProd !== 0) {\n        throw Error(`The implicit shape can't be a fractional number. ` +\n            `Got ${size} / ${shapeProd}`);\n    }\n    const newShape = shape.slice();\n    newShape[implicitIdx] = size / shapeProd;\n    return newShape;\n}\nexport function parseAxisParam(axis, shape) {\n    const rank = shape.length;\n    // Normalize input\n    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);\n    // Check for valid range\n    assert(axis.every(ax => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +\n        `got axis ${axis}`);\n    // Check for only integers\n    assert(axis.every(ax => isInt(ax)), () => `All values in axis param must be integers but ` +\n        `got axis ${axis}`);\n    // Handle negative axis.\n    return axis.map(a => a < 0 ? rank + a : a);\n}\n/** Reduces the shape by removing all dimensions of shape 1. */\nexport function squeezeShape(shape, axis) {\n    const newShape = [];\n    const keptDims = [];\n    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n    const axes = (axis == null || isEmptyArray) ?\n        null :\n        parseAxisParam(axis, shape).sort();\n    let j = 0;\n    for (let i = 0; i < shape.length; ++i) {\n        if (axes != null) {\n            if (axes[j] === i && shape[i] !== 1) {\n                throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n            }\n            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n                newShape.push(shape[i]);\n                keptDims.push(i);\n            }\n            if (axes[j] <= i) {\n                j++;\n            }\n        }\n        if (shape[i] !== 1) {\n            newShape.push(shape[i]);\n            keptDims.push(i);\n        }\n    }\n    return { newShape, keptDims };\n}\nexport function getTypedArrayFromDType(dtype, size) {\n    let values = null;\n    if (dtype == null || dtype === 'float32') {\n        values = new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        values = new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        values = new Uint8Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n    return values;\n}\nexport function getArrayFromDType(dtype, size) {\n    let values = null;\n    if (dtype == null || dtype === 'float32') {\n        values = new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        values = new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        values = new Uint8Array(size);\n    }\n    else if (dtype === 'string') {\n        values = new Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n    return values;\n}\nexport function checkConversionForErrors(vals, dtype) {\n    for (let i = 0; i < vals.length; i++) {\n        const num = vals[i];\n        if (isNaN(num) || !isFinite(num)) {\n            throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);\n        }\n    }\n}\n/** Returns true if the dtype is valid. */\nexport function isValidDtype(dtype) {\n    return dtype === 'bool' || dtype === 'complex64' || dtype === 'float32' ||\n        dtype === 'int32' || dtype === 'string';\n}\n/**\n * Returns true if the new type can't encode the old type without loss of\n * precision.\n */\nexport function hasEncodingLoss(oldType, newType) {\n    if (newType === 'complex64') {\n        return false;\n    }\n    if (newType === 'float32' && oldType !== 'complex64') {\n        return false;\n    }\n    if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') {\n        return false;\n    }\n    if (newType === 'bool' && oldType === 'bool') {\n        return false;\n    }\n    return true;\n}\nexport function isTypedArray(a) {\n    return a instanceof Float32Array || a instanceof Int32Array ||\n        a instanceof Uint8Array;\n}\nexport function bytesPerElement(dtype) {\n    if (dtype === 'float32' || dtype === 'int32') {\n        return 4;\n    }\n    else if (dtype === 'complex64') {\n        return 8;\n    }\n    else if (dtype === 'bool') {\n        return 1;\n    }\n    else {\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\n/**\n * Returns the approximate number of bytes allocated in the string array - 2\n * bytes per character. Computing the exact bytes for a native string in JS is\n * not possible since it depends on the encoding of the html page that serves\n * the website.\n */\nexport function bytesFromStringArray(arr) {\n    if (arr == null) {\n        return 0;\n    }\n    let bytes = 0;\n    arr.forEach(x => bytes += x.length);\n    return bytes;\n}\n/** Returns true if the value is a string. */\nexport function isString(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexport function isBoolean(value) {\n    return typeof value === 'boolean';\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\nexport function inferDtype(values) {\n    if (Array.isArray(values)) {\n        return inferDtype(values[0]);\n    }\n    if (values instanceof Float32Array) {\n        return 'float32';\n    }\n    else if (values instanceof Int32Array || values instanceof Uint8Array) {\n        return 'int32';\n    }\n    else if (isNumber(values)) {\n        return 'float32';\n    }\n    else if (isString(values)) {\n        return 'string';\n    }\n    else if (isBoolean(values)) {\n        return 'bool';\n    }\n    return 'float32';\n}\nexport function isFunction(f) {\n    return !!(f && f.constructor && f.call && f.apply);\n}\nexport function nearestDivisor(size, start) {\n    for (let i = start; i < size; ++i) {\n        if (size % i === 0) {\n            return i;\n        }\n    }\n    return size;\n}\nexport function computeStrides(shape) {\n    const rank = shape.length;\n    if (rank < 2) {\n        return [];\n    }\n    // Last dimension has implicit stride of 1, thus having D-1 (instead of D)\n    // strides.\n    const strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n        strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    return strides;\n}\nexport function toTypedArray(a, dtype) {\n    if (dtype === 'string') {\n        throw new Error('Cannot convert a string[] to a TypedArray');\n    }\n    if (Array.isArray(a)) {\n        a = flatten(a);\n    }\n    if (env().getBool('DEBUG')) {\n        checkConversionForErrors(a, dtype);\n    }\n    if (noConversionNeeded(a, dtype)) {\n        return a;\n    }\n    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n        return new Float32Array(a);\n    }\n    else if (dtype === 'int32') {\n        return new Int32Array(a);\n    }\n    else if (dtype === 'bool') {\n        const bool = new Uint8Array(a.length);\n        for (let i = 0; i < bool.length; ++i) {\n            if (Math.round(a[i]) !== 0) {\n                bool[i] = 1;\n            }\n        }\n        return bool;\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\nfunction createNestedArray(offset, shape, a) {\n    const ret = new Array();\n    if (shape.length === 1) {\n        const d = shape[0];\n        for (let i = 0; i < d; i++) {\n            ret[i] = a[offset + i];\n        }\n    }\n    else {\n        const d = shape[0];\n        const rest = shape.slice(1);\n        const len = rest.reduce((acc, c) => acc * c);\n        for (let i = 0; i < d; i++) {\n            ret[i] = createNestedArray(offset + i * len, rest, a);\n        }\n    }\n    return ret;\n}\n// Provide a nested array of TypedArray in given shape.\nexport function toNestedArray(shape, a) {\n    if (shape.length === 0) {\n        // Scalar type should return a single number.\n        return a[0];\n    }\n    const size = shape.reduce((acc, c) => acc * c);\n    if (size === 0) {\n        // A tensor with shape zero should be turned into empty list.\n        return [];\n    }\n    if (size !== a.length) {\n        throw new Error(`[${shape}] does not match the input size ${a.length}.`);\n    }\n    return createNestedArray(0, shape, a);\n}\nfunction noConversionNeeded(a, dtype) {\n    return (a instanceof Float32Array && dtype === 'float32') ||\n        (a instanceof Int32Array && dtype === 'int32') ||\n        (a instanceof Uint8Array && dtype === 'bool');\n}\nexport function makeOnesTypedArray(size, dtype) {\n    const array = makeZerosTypedArray(size, dtype);\n    for (let i = 0; i < array.length; i++) {\n        array[i] = 1;\n    }\n    return array;\n}\nexport function makeZerosTypedArray(size, dtype) {\n    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n        return new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        return new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        return new Uint8Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\n/**\n * Make nested `TypedArray` filled with zeros.\n * @param shape The shape information for the nested array.\n * @param dtype dtype of the array element.\n */\nexport function makeZerosNestedTypedArray(shape, dtype) {\n    const size = shape.reduce((prev, curr) => prev * curr, 1);\n    if (dtype == null || dtype === 'float32') {\n        return toNestedArray(shape, new Float32Array(size));\n    }\n    else if (dtype === 'int32') {\n        return toNestedArray(shape, new Int32Array(size));\n    }\n    else if (dtype === 'bool') {\n        return toNestedArray(shape, new Uint8Array(size));\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n}\n/**\n * Returns the current high-resolution time in milliseconds relative to an\n * arbitrary time in the past. It works across different platforms (node.js,\n * browsers).\n *\n * ```js\n * console.log(tf.util.now());\n * ```\n */\n/** @doc {heading: 'Util', namespace: 'util'} */\nexport function now() {\n    return env().platform.now();\n}\nexport function assertNonNegativeIntegerDimensions(shape) {\n    shape.forEach(dimSize => {\n        assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got ` +\n            `shape [${shape}].`);\n    });\n}\n/**\n * Returns a platform-specific implementation of\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n *\n * If `fetch` is defined on the global object (`window`, `process`, etc.),\n * `tf.util.fetch` returns that function.\n *\n * If not, `tf.util.fetch` returns a platform-specific solution.\n *\n * ```js\n * const resource = await tf.util.fetch('https://unpkg.com/@tensorflow/tfjs');\n * // handle response\n * ```\n */\n/** @doc {heading: 'Util'} */\nexport function fetch(path, requestInits) {\n    return env().platform.fetch(path, requestInits);\n}\n/**\n * Encodes the provided string into bytes using the provided encoding scheme.\n *\n * @param s The string to encode.\n * @param encoding The encoding scheme. Defaults to utf-8.\n *\n */\n/** @doc {heading: 'Util'} */\nexport function encodeString(s, encoding = 'utf-8') {\n    encoding = encoding || 'utf-8';\n    return env().platform.encode(s, encoding);\n}\n/**\n * Decodes the provided bytes into a string using the provided encoding scheme.\n * @param bytes The bytes to decode.\n *\n * @param encoding The encoding scheme. Defaults to utf-8.\n */\n/** @doc {heading: 'Util'} */\nexport function decodeString(bytes, encoding = 'utf-8') {\n    encoding = encoding || 'utf-8';\n    return env().platform.decode(bytes, encoding);\n}\n/**\n * Computes flat index for a given location (multidimentionsal index) in a\n * Tensor/multidimensional array.\n *\n * @param locs Location in the tensor.\n * @param rank Rank of the tensor.\n * @param strides Tensor strides.\n */\nexport function locToIndex(locs, rank, strides) {\n    if (rank === 0) {\n        return 0;\n    }\n    else if (rank === 1) {\n        return locs[0];\n    }\n    let index = locs[locs.length - 1];\n    for (let i = 0; i < locs.length - 1; ++i) {\n        index += strides[i] * locs[i];\n    }\n    return index;\n}\n/**\n * Computes the location (multidimensional index) in a tensor/multidimentional\n * array for a given flat index.\n *\n * @param index Index in flat array.\n * @param rank Rank of tensor.\n * @param strides Strides of tensor.\n */\nexport function indexToLoc(index, rank, strides) {\n    if (rank === 0) {\n        return [];\n    }\n    else if (rank === 1) {\n        return [index];\n    }\n    const locs = new Array(rank);\n    for (let i = 0; i < locs.length - 1; ++i) {\n        locs[i] = Math.floor(index / strides[i]);\n        index -= locs[i] * strides[i];\n    }\n    locs[locs.length - 1] = index;\n    return locs;\n}\n//# sourceMappingURL=util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from './util';\nexport class Profiler {\n    constructor(backendTimer, logger) {\n        this.backendTimer = backendTimer;\n        this.logger = logger;\n        if (logger == null) {\n            this.logger = new Logger();\n        }\n    }\n    profileKernel(kernelName, inputs, f) {\n        let outputs;\n        const holdResultWrapperFn = () => {\n            outputs = f();\n        };\n        const timer = this.backendTimer.time(holdResultWrapperFn);\n        outputs.map(r => {\n            // Dangling promise here because we don't want to propagate up\n            // asynchronicity.\n            r.data().then(tensorVals => {\n                checkComputationForErrors(tensorVals, r.dtype, kernelName);\n            });\n        });\n        const kernelProfile = {\n            kernelName,\n            outputs,\n            inputs,\n            timeMs: timer.then(timing => timing.kernelMs),\n            extraInfo: timer.then(timing => timing.getExtraProfileInfo != null ?\n                timing.getExtraProfileInfo() :\n                '')\n        };\n        return kernelProfile;\n    }\n    logKernelProfile(kernelProfile) {\n        const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;\n        outputs.forEach(result => {\n            Promise.all([result.data(), timeMs, extraInfo]).then(valueContainer => {\n                this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);\n            });\n        });\n    }\n}\nexport function checkComputationForErrors(vals, dtype, kernelName) {\n    if (dtype !== 'float32') {\n        // Only floating point computations will generate NaN values\n        return false;\n    }\n    for (let i = 0; i < vals.length; i++) {\n        const num = vals[i];\n        if (isNaN(num) || !isFinite(num)) {\n            // Throwing custom exception so behavior is testable.\n            console.warn(`Found ${num} in the result of '${kernelName}'`);\n            return true;\n        }\n    }\n    return false;\n}\nexport class Logger {\n    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {\n        const time = typeof timeMs === 'number' ? util.rightPad(`${timeMs}ms`, 9) :\n            timeMs['error'];\n        const paddedName = util.rightPad(name, 25);\n        const rank = result.rank;\n        const size = result.size;\n        const shape = util.rightPad(result.shape.toString(), 14);\n        let inputShapesDescription = '';\n        for (const name in inputs) {\n            const input = inputs[name];\n            // The input might be a non-tensor (e.g HTMLImageElement), in which case\n            // we claim the output shape as input shape.\n            const inputShape = input.shape || result.shape;\n            const inputRank = inputShape.length;\n            inputShapesDescription +=\n                `${name}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;\n        }\n        console.log(`%c${paddedName}\\t%c${time}\\t%c${rank}D ${shape}\\t%c${size}\\t%c${inputShapesDescription}\\t%c${extraInfo}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');\n    }\n}\n//# sourceMappingURL=profiler.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensorToString } from './tensor_format';\nimport * as util from './util';\nimport { computeStrides, toNestedArray } from './util';\n/**\n * A mutable object, similar to `tf.Tensor`, that allows users to set values\n * at locations before converting to an immutable `tf.Tensor`.\n *\n * See `tf.buffer` for creating a tensor buffer.\n */\n/** @doc {heading: 'Tensors', subheading: 'Classes'} */\nexport class TensorBuffer {\n    constructor(shape, dtype, values) {\n        this.dtype = dtype;\n        this.shape = shape.slice();\n        this.size = util.sizeFromShape(shape);\n        if (values != null) {\n            const n = values.length;\n            util.assert(n === this.size, () => `Length of values '${n}' does not match the size ` +\n                `inferred by the shape '${this.size}'.`);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` +\n                `a TensorBuffer for the real and imaginary parts separately and ` +\n                `call tf.complex(real, imag).`);\n        }\n        this.values = values || util.getArrayFromDType(dtype, this.size);\n        this.strides = computeStrides(shape);\n    }\n    /**\n     * Sets a value in the buffer at a given location.\n     *\n     * @param value The value to set.\n     * @param locs  The location indices.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Creation'} */\n    set(value, ...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        util.assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must ` +\n            `match the rank (${this.rank})`);\n        const index = this.locToIndex(locs);\n        this.values[index] = value;\n    }\n    /**\n     * Returns the value in the buffer at the provided location.\n     *\n     * @param locs The location indices.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Creation'} */\n    get(...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        let i = 0;\n        for (const loc of locs) {\n            if (loc < 0 || loc >= this.shape[i]) {\n                const msg = `Requested out of range element at ${locs}. ` +\n                    `  Buffer shape=${this.shape}`;\n                throw new Error(msg);\n            }\n            i++;\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return this.values[index];\n    }\n    locToIndex(locs) {\n        if (this.rank === 0) {\n            return 0;\n        }\n        else if (this.rank === 1) {\n            return locs[0];\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return index;\n    }\n    indexToLoc(index) {\n        if (this.rank === 0) {\n            return [];\n        }\n        else if (this.rank === 1) {\n            return [index];\n        }\n        const locs = new Array(this.shape.length);\n        for (let i = 0; i < locs.length - 1; ++i) {\n            locs[i] = Math.floor(index / this.strides[i]);\n            index -= locs[i] * this.strides[i];\n        }\n        locs[locs.length - 1] = index;\n        return locs;\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Creates an immutable `tf.Tensor` object from the buffer.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Creation'} */\n    toTensor() {\n        return trackerFn().makeTensor(this.values, this.shape, this.dtype);\n    }\n}\n// For tracking tensor creation and disposal.\nlet trackerFn = null;\n// Used by chaining methods to call into ops.\nlet opHandler = null;\n// Used to warn about deprecated methods.\nlet deprecationWarningFn = null;\n// This here so that we can use this method on dev branches and keep the\n// functionality at master.\n// tslint:disable-next-line:no-unused-expression\n[deprecationWarningFn];\n/**\n * An external consumer can register itself as the tensor tracker. This way\n * the Tensor class can notify the tracker for every tensor created and\n * disposed.\n */\nexport function setTensorTracker(fn) {\n    trackerFn = fn;\n}\n/**\n * An external consumer can register itself as the op handler. This way the\n * Tensor class can have chaining methods that call into ops via the op\n * handler.\n */\nexport function setOpHandler(handler) {\n    opHandler = handler;\n}\n/**\n * Sets the deprecation warning function to be used by this file. This way the\n * Tensor class can be a leaf but still use the environment.\n */\nexport function setDeprecationWarningFn(fn) {\n    deprecationWarningFn = fn;\n}\n/**\n * A `tf.Tensor` object represents an immutable, multidimensional array of\n * numbers that has a shape and a data type.\n *\n * See `tf.tensor` for details on how to create a `tf.Tensor`.\n */\n/** @doc {heading: 'Tensors', subheading: 'Classes'} */\nexport class Tensor {\n    constructor(shape, dtype, dataId, id) {\n        /** Whether this tensor has been globally kept. */\n        this.kept = false;\n        this.isDisposedInternal = false;\n        this.shape = shape.slice();\n        this.dtype = dtype || 'float32';\n        this.size = util.sizeFromShape(shape);\n        this.strides = computeStrides(shape);\n        this.dataId = dataId;\n        this.id = id;\n        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    async buffer() {\n        const vals = await this.data();\n        return opHandler.buffer(this.shape, this.dtype, vals);\n    }\n    /** Returns a `tf.TensorBuffer` that holds the underlying data. */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    bufferSync() {\n        return opHandler.buffer(this.shape, this.dtype, this.dataSync());\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * asynchronously.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    async array() {\n        const vals = await this.data();\n        return toNestedArray(this.shape, vals);\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * synchronously.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    arraySync() {\n        return toNestedArray(this.shape, this.dataSync());\n    }\n    /**\n     * Asynchronously downloads the values from the `tf.Tensor`. Returns a\n     * promise of `TypedArray` that resolves when the computation has finished.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    async data() {\n        this.throwIfDisposed();\n        const data = trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            const bytes = await data;\n            try {\n                return bytes.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /**\n     * Synchronously downloads the values from the `tf.Tensor`. This blocks the\n     * UI thread until the values are ready, which can cause performance issues.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    dataSync() {\n        this.throwIfDisposed();\n        const data = trackerFn().readSync(this.dataId);\n        if (this.dtype === 'string') {\n            try {\n                return data.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /** Returns the underlying bytes of the tensor's data. */\n    async bytes() {\n        this.throwIfDisposed();\n        const data = await trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            return data;\n        }\n        else {\n            return new Uint8Array(data.buffer);\n        }\n    }\n    /**\n     * Disposes `tf.Tensor` from memory.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        trackerFn().disposeTensor(this);\n        this.isDisposedInternal = true;\n    }\n    get isDisposed() {\n        return this.isDisposedInternal;\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error(`Tensor is disposed.`);\n        }\n    }\n    /**\n     * Prints the `tf.Tensor`. See `tf.print` for details.\n     *\n     * @param verbose Whether to print verbose information about the tensor,\n     *    including dtype and size.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    print(verbose = false) {\n        return opHandler.print(this, verbose);\n    }\n    /** Returns a copy of the tensor. See `tf.clone` for details. */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    clone() {\n        this.throwIfDisposed();\n        return opHandler.clone(this);\n    }\n    /**\n     * Returns a human-readable description of the tensor. Useful for logging.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    toString(verbose = false) {\n        const vals = this.dataSync();\n        return tensorToString(vals, this.shape, this.dtype, verbose);\n    }\n    cast(dtype) {\n        this.throwIfDisposed();\n        return opHandler.cast(this, dtype);\n    }\n    variable(trainable = true, name, dtype) {\n        this.throwIfDisposed();\n        return trackerFn().makeVariable(this, trainable, name, dtype);\n    }\n}\nObject.defineProperty(Tensor, Symbol.hasInstance, {\n    value: (instance) => {\n        return !!instance && instance.dataId != null && instance.shape != null &&\n            instance.dtype != null;\n    }\n});\n/**\n * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.\n */\n/** @doc {heading: 'Tensors', subheading: 'Classes'} */\nexport class Variable extends Tensor {\n    constructor(initialValue, trainable, name, tensorId) {\n        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);\n        this.trainable = trainable;\n        this.name = name;\n    }\n    /**\n     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have\n     * the same shape and dtype as the old `tf.Tensor`.\n     *\n     * @param newValue New tensor to be assigned to this variable.\n     */\n    /** @doc {heading: 'Tensors', subheading: 'Classes'} */\n    assign(newValue) {\n        if (newValue.dtype !== this.dtype) {\n            throw new Error(`dtype of the new value (${newValue.dtype}) and ` +\n                `previous value (${this.dtype}) must match`);\n        }\n        if (!util.arraysEqual(newValue.shape, this.shape)) {\n            throw new Error(`shape of the new value (${newValue.shape}) and ` +\n                `previous value (${this.shape}) must match`);\n        }\n        trackerFn().disposeTensor(this);\n        this.dataId = newValue.dataId;\n        trackerFn().incRef(this, null /* backend */);\n    }\n    dispose() {\n        trackerFn().disposeVariable(this);\n        this.isDisposedInternal = true;\n    }\n}\nObject.defineProperty(Variable, Symbol.hasInstance, {\n    value: (instance) => {\n        return instance instanceof Tensor && instance.assign != null &&\n            instance.assign instanceof Function;\n    }\n});\n//# sourceMappingURL=tensor.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n(function (Rank) {\n    Rank[\"R0\"] = \"R0\";\n    Rank[\"R1\"] = \"R1\";\n    Rank[\"R2\"] = \"R2\";\n    Rank[\"R3\"] = \"R3\";\n    Rank[\"R4\"] = \"R4\";\n    Rank[\"R5\"] = \"R5\";\n    Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {}));\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nvar UpcastInt32AndMap;\n(function (UpcastInt32AndMap) {\n    UpcastInt32AndMap[\"float32\"] = \"float32\";\n    UpcastInt32AndMap[\"int32\"] = \"int32\";\n    UpcastInt32AndMap[\"bool\"] = \"int32\";\n    UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\nvar UpcastBoolAndMap;\n(function (UpcastBoolAndMap) {\n    UpcastBoolAndMap[\"float32\"] = \"float32\";\n    UpcastBoolAndMap[\"int32\"] = \"int32\";\n    UpcastBoolAndMap[\"bool\"] = \"bool\";\n    UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\nvar UpcastFloat32AndMap;\n(function (UpcastFloat32AndMap) {\n    UpcastFloat32AndMap[\"float32\"] = \"float32\";\n    UpcastFloat32AndMap[\"int32\"] = \"float32\";\n    UpcastFloat32AndMap[\"bool\"] = \"float32\";\n    UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\nvar UpcastComplex64AndMap;\n(function (UpcastComplex64AndMap) {\n    UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n    UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nconst upcastTypeMap = {\n    'float32': UpcastFloat32AndMap,\n    'int32': UpcastInt32AndMap,\n    'bool': UpcastBoolAndMap,\n    'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n    if (typeA === 'string' || typeB === 'string') {\n        if (typeA === 'string' && typeB === 'string') {\n            return 'string';\n        }\n        throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n    }\n    return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\nexport function sumOutType(type) {\n    return upcastType(type, 'int32');\n}\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tensor } from './tensor';\nimport { upcastType } from './types';\nimport { assert } from './util';\nexport function makeTypesMatch(a, b) {\n    if (a.dtype === b.dtype) {\n        return [a, b];\n    }\n    const dtype = upcastType(a.dtype, b.dtype);\n    return [a.cast(dtype), b.cast(dtype)];\n}\nexport function assertTypesMatch(a, b) {\n    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and` +\n        ` second(${b.dtype}) input must match`);\n}\nexport function isTensorInList(tensor, tensorList) {\n    return tensorList.some(x => x.id === tensor.id);\n}\n/**\n * Extracts any `Tensor`s found within the provided object.\n *\n * @param container an object that may be a `Tensor` or may directly contain\n *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it\n *   is safe to pass any object here, except that `Promise`s are not\n *   supported.\n * @returns An array of `Tensors` found within the passed object. If the\n *   argument is simply a `Tensor', a list containing that `Tensor` is\n *   returned. If the object is not a `Tensor` or does not\n *   contain `Tensors`, an empty list is returned.\n */\nexport function getTensorsInContainer(result) {\n    const list = [];\n    const seen = new Set();\n    walkTensorContainer(result, list, seen);\n    return list;\n}\nfunction walkTensorContainer(container, list, seen) {\n    if (container == null) {\n        return;\n    }\n    if (container instanceof Tensor) {\n        list.push(container);\n        return;\n    }\n    if (!isIterable(container)) {\n        return;\n    }\n    // Iteration over keys works also for arrays.\n    const iterable = container;\n    for (const k in iterable) {\n        const val = iterable[k];\n        if (!seen.has(val)) {\n            seen.add(val);\n            walkTensorContainer(val, list, seen);\n        }\n    }\n}\n// tslint:disable-next-line:no-any\nfunction isIterable(obj) {\n    return Array.isArray(obj) || typeof obj === 'object';\n}\n//# sourceMappingURL=tensor_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Environment, setEnvironmentGlobal } from './environment';\nimport { getGlobalNamespace } from './global_util';\nimport { Add, Cast } from './kernel_names';\nimport { getGradient, getKernel, getKernelsForBackend } from './kernel_registry';\nimport { Profiler } from './profiler';\nimport { backpropagateGradients, getFilteredNodesXToY } from './tape';\nimport { setTensorTracker, Tensor, Variable } from './tensor';\nimport { getTensorsInContainer } from './tensor_util';\nimport * as util from './util';\nimport { bytesFromStringArray, makeOnesTypedArray, now, sizeFromShape } from './util';\nclass EngineState {\n    constructor() {\n        // Public since optimizers will use it.\n        this.registeredVariables = {};\n        this.nextTapeNodeId = 0;\n        this.numBytes = 0;\n        this.numTensors = 0;\n        this.numStringTensors = 0;\n        this.numDataBuffers = 0;\n        // Number of nested tf.grad() statements when computing higher-order\n        // gradients. E.g. `1` for first-order gradients and `2` for second-order\n        // gradients. Used to track if the tape should be removed after a backprop.\n        this.gradientDepth = 0;\n        // Number of nested kernel calls. When kernel depth is greater than 1, we turn\n        // off the tape.\n        this.kernelDepth = 0;\n        this.scopeStack = [];\n        /**\n         * Keeps track of the number of data moves during a kernel execution. We\n         * maintain a stack since kernels can call other kernels, recursively.\n         */\n        this.numDataMovesStack = [];\n        this.nextScopeId = 0;\n        this.tensorInfo = new WeakMap();\n        this.profiling = false;\n        this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };\n    }\n    dispose() {\n        for (const variableName in this.registeredVariables) {\n            this.registeredVariables[variableName].dispose();\n        }\n    }\n}\nexport class Engine {\n    constructor(ENV) {\n        this.ENV = ENV;\n        this.registry = {};\n        this.registryFactory = {};\n        this.pendingBackendInitId = 0;\n        this.state = new EngineState();\n    }\n    async ready() {\n        if (this.pendingBackendInit != null) {\n            return this.pendingBackendInit.then(() => { });\n        }\n        if (this.backendInstance != null) {\n            return;\n        }\n        const sortedBackends = this.getSortedBackends();\n        for (let i = 0; i < sortedBackends.length; i++) {\n            const backendName = sortedBackends[i];\n            const success = await this.initializeBackend(backendName).success;\n            if (success) {\n                await this.setBackend(backendName);\n                return;\n            }\n        }\n        throw new Error(`Could not initialize any backends, all backend initializations ` +\n            `failed.`);\n    }\n    get backend() {\n        if (this.pendingBackendInit != null) {\n            throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` +\n                `sure to await tf.ready() or await tf.setBackend() before calling ` +\n                `other methods`);\n        }\n        if (this.backendInstance == null) {\n            const { name, asyncInit } = this.initializeBackendsAndReturnBest();\n            if (asyncInit) {\n                throw new Error(`The highest priority backend '${name}' has not yet been ` +\n                    `initialized. Make sure to await tf.ready() or ` +\n                    `await tf.setBackend() before calling other methods`);\n            }\n            this.setBackend(name);\n        }\n        return this.backendInstance;\n    }\n    backendNames() {\n        return Object.keys(this.registryFactory);\n    }\n    findBackend(backendName) {\n        if (!(backendName in this.registry)) {\n            // If the backend hasn't been initialized but we have a registry entry for\n            // it, initialize it and return it.\n            if (backendName in this.registryFactory) {\n                const { asyncInit } = this.initializeBackend(backendName);\n                if (asyncInit) {\n                    // Backend is not ready yet.\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        return this.registry[backendName];\n    }\n    findBackendFactory(backendName) {\n        if (!(backendName in this.registryFactory)) {\n            return null;\n        }\n        return this.registryFactory[backendName].factory;\n    }\n    registerBackend(backendName, factory, priority = 1) {\n        if (backendName in this.registryFactory) {\n            console.warn(`${backendName} backend was already registered. ` +\n                `Reusing existing backend factory.`);\n            return false;\n        }\n        this.registryFactory[backendName] = { factory, priority };\n        return true;\n    }\n    async setBackend(backendName) {\n        if (this.registryFactory[backendName] == null) {\n            throw new Error(`Backend name '${backendName}' not found in registry`);\n        }\n        this.backendName = backendName;\n        if (this.registry[backendName] == null) {\n            this.backendInstance = null;\n            const { success, asyncInit } = this.initializeBackend(backendName);\n            const result = asyncInit ? await success : success;\n            if (!result) {\n                return false;\n            }\n        }\n        this.backendInstance = this.registry[backendName];\n        this.setupRegisteredKernels();\n        // Reset the profiler.\n        this.profiler = new Profiler(this.backendInstance);\n        return true;\n    }\n    setupRegisteredKernels() {\n        const kernels = getKernelsForBackend(this.backendName);\n        kernels.forEach(kernel => {\n            if (kernel.setupFunc != null) {\n                kernel.setupFunc(this.backendInstance);\n            }\n        });\n    }\n    disposeRegisteredKernels(backendName) {\n        const kernels = getKernelsForBackend(backendName);\n        kernels.forEach(kernel => {\n            if (kernel.disposeFunc != null) {\n                kernel.disposeFunc(this.registry[backendName]);\n            }\n        });\n    }\n    /**\n     * Initializes a backend by looking up the backend name in the factory\n     * registry and calling the factory method. Returns a boolean representing\n     * whether the initialization of the backend suceeded. Throws an error if\n     * there is no backend in the factory registry.\n     */\n    initializeBackend(backendName) {\n        const registryFactoryEntry = this.registryFactory[backendName];\n        if (registryFactoryEntry == null) {\n            throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);\n        }\n        try {\n            const backend = registryFactoryEntry.factory();\n            // Test if the factory returns a promise.\n            if (Promise.resolve(backend) === backend) {\n                const promiseId = ++this.pendingBackendInitId;\n                const success = backend\n                    .then(backendInstance => {\n                    // Outdated promise. Another backend was set in the meantime.\n                    if (promiseId < this.pendingBackendInitId) {\n                        return false;\n                    }\n                    this.registry[backendName] = backendInstance;\n                    this.pendingBackendInit = null;\n                    return true;\n                })\n                    .catch(err => {\n                    // Outdated promise. Another backend was set in the meantime.\n                    if (promiseId < this.pendingBackendInitId) {\n                        return false;\n                    }\n                    this.pendingBackendInit = null;\n                    console.warn(`Initialization of backend ${backendName} failed`);\n                    console.warn(err.stack || err.message);\n                    return false;\n                });\n                this.pendingBackendInit = success;\n                return { success, asyncInit: true };\n            }\n            else {\n                this.registry[backendName] = backend;\n                return { success: true, asyncInit: false };\n            }\n        }\n        catch (err) {\n            console.warn(`Initialization of backend ${backendName} failed`);\n            console.warn(err.stack || err.message);\n            return { success: false, asyncInit: false };\n        }\n    }\n    removeBackend(backendName) {\n        if (!(backendName in this.registryFactory)) {\n            throw new Error(`${backendName} backend not found in registry`);\n        }\n        if (this.backendName === backendName && this.pendingBackendInit != null) {\n            // There is a pending promise of the backend we want to remove. Make it\n            // obsolete.\n            this.pendingBackendInitId++;\n        }\n        if (backendName in this.registry) {\n            this.disposeRegisteredKernels(backendName);\n            this.registry[backendName].dispose();\n            delete this.registry[backendName];\n        }\n        delete this.registryFactory[backendName];\n        // Unset the backend if it is active.\n        if (this.backendName === backendName) {\n            this.pendingBackendInit = null;\n            this.backendName = null;\n            this.backendInstance = null;\n        }\n    }\n    getSortedBackends() {\n        if (Object.keys(this.registryFactory).length === 0) {\n            throw new Error('No backend found in registry.');\n        }\n        return Object.keys(this.registryFactory).sort((a, b) => {\n            // Highest priority comes first.\n            return this.registryFactory[b].priority -\n                this.registryFactory[a].priority;\n        });\n    }\n    initializeBackendsAndReturnBest() {\n        const sortedBackends = this.getSortedBackends();\n        for (let i = 0; i < sortedBackends.length; i++) {\n            const backendName = sortedBackends[i];\n            const { success, asyncInit } = this.initializeBackend(backendName);\n            if (asyncInit || success) {\n                return { name: backendName, asyncInit };\n            }\n        }\n        throw new Error(`Could not initialize any backends, all backend initializations ` +\n            `failed.`);\n    }\n    moveData(backend, dataId) {\n        const info = this.state.tensorInfo.get(dataId);\n        const srcBackend = info.backend;\n        const values = this.readSync(dataId);\n        // Delete the tensor from the old backend and move it to the new\n        // backend.\n        srcBackend.disposeData(dataId);\n        info.backend = backend;\n        backend.move(dataId, values, info.shape, info.dtype);\n        if (this.shouldCheckForMemLeaks()) {\n            // Track the number of moves during a kernel execution to correctly\n            // detect memory leaks.\n            this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n        }\n    }\n    tidy(nameOrFn, fn) {\n        let name = null;\n        if (fn == null) {\n            // Called with only 1 argument.\n            if (typeof nameOrFn !== 'function') {\n                throw new Error('Please provide a function to tidy()');\n            }\n            fn = nameOrFn;\n        }\n        else {\n            // Called with 2 arguments.\n            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {\n                throw new Error('When calling with two arguments, the first argument ' +\n                    'to tidy() must be a string');\n            }\n            if (typeof fn !== 'function') {\n                throw new Error('When calling with two arguments, the 2nd argument ' +\n                    'to tidy() must be a function');\n            }\n            name = nameOrFn;\n            // TODO(nsthorat,smilkov): Do operation logging and performance\n            // profiling.\n        }\n        let result;\n        return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {\n            result = fn();\n            if (result instanceof Promise) {\n                console.error('Cannot return a Promise inside of tidy.');\n            }\n            return result;\n        });\n    }\n    scopedRun(start, end, f) {\n        start();\n        try {\n            const res = f();\n            end();\n            return res;\n        }\n        catch (ex) {\n            end();\n            throw ex;\n        }\n    }\n    nextTensorId() {\n        return Engine.nextTensorId++;\n    }\n    nextVariableId() {\n        return Engine.nextVariableId++;\n    }\n    /**\n     * This method is called instead of the public-facing tensor.clone() when\n     * saving a tensor for backwards pass. It makes sure to add the clone\n     * operation to the tape regardless of being called inside a kernel\n     * execution.\n     *\n     * This method will go away once all kernels are modularized since we won't\n     * need to turn off the tape inside runKernel().\n     */\n    clone(x) {\n        const y = this.makeTensorFromDataId(x.dataId, x.shape, x.dtype);\n        const inputs = { x };\n        const grad = (dy) => ({\n            x: () => {\n                const dtype = 'float32';\n                const gradInputs = { x: dy };\n                const attrs = { dtype };\n                return ENGINE.runKernelFunc(backend => backend.cast(dy, dtype), gradInputs, null /* grad */, Cast, attrs);\n            }\n        });\n        const saved = [];\n        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});\n        return y;\n    }\n    /**\n     * Execute a kernel with the given name and return the output tensor.\n     *\n     * @param kernelName The name of the kernel to execute.\n     * @param inputs A map of input names to tensors.\n     * @param attrs A map of attribute names to their values. An attribute is a\n     *     primitive (non-tensor) input to the kernel.\n     * @param inputsToSave A list of tensors, inputs to save for the backprop\n     *     computation.\n     * @param outputsToSave A list of booleans, specifying which output to save\n     *     for the backprop computation. These are booleans since the output\n     * tensors are not visible to the user.\n     */\n    runKernel(kernelName, inputs, attrs, inputsToSave, outputsToSave) {\n        const forwardFunc = null;\n        const backwardsFunc = null;\n        // Call runKernel as a stop-gap until we modularize all kernels.\n        // Once we modularize all kernels, we will remove the existing\n        // `runKernelFunc`.\n        return this.runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave);\n    }\n    shouldCheckForMemLeaks() {\n        return this.ENV.getBool('IS_TEST');\n    }\n    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {\n        const numDataIdsAfter = this.backend.numDataIds();\n        // Count the number of data ids associated with the result of the kernel.\n        let numOutputDataIds = 0;\n        outInfos.forEach(info => {\n            // Complex numbers allocate 3 data ids, one for 'real', one for\n            // 'imaginary', and one for the container that holds the former two.\n            numOutputDataIds += (info.dtype === 'complex64' ? 3 : 1);\n        });\n        // Account for the number of moves during kernel execution. A \"data move\"\n        // can happen in the middle of a kernel execution, placing a new (key,value)\n        // pair in the data storage. Since data moves have net zero effect (we\n        // always remove the data from the old backend), we have to cancel them out\n        // when detecting memory leaks.\n        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];\n        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;\n        if (dataIdsLeaked > 0) {\n            throw new Error(`Backend '${this.backendName}' has an internal memory leak ` +\n                `(${dataIdsLeaked} data ids) after running '${kernelName}'`);\n        }\n    }\n    /**\n     * @deprecated Use `runKernel` for newly added kernels. Keep using this method\n     *     only for kernels that are not yet fully modularized.\n     */\n    runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave) {\n        let outputs;\n        let saved = [];\n        const isTapeOn = this.isTapeOn();\n        if (kernelName == null) {\n            kernelName =\n                this.state.activeScope != null ? this.state.activeScope.name : '';\n        }\n        const startingBytecount = this.state.numBytes;\n        const startingNumTensors = this.state.numTensors;\n        if (this.shouldCheckForMemLeaks()) {\n            this.state.numDataMovesStack.push(0);\n        }\n        let kernelFunc;\n        const kernel = getKernel(kernelName, this.backendName);\n        let out;\n        if (kernel != null) {\n            kernelFunc = () => {\n                const numDataIdsBefore = this.backend.numDataIds();\n                out = kernel.kernelFunc({ inputs, attrs, backend: this.backend });\n                const outInfos = Array.isArray(out) ? out : [out];\n                if (this.shouldCheckForMemLeaks()) {\n                    this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);\n                }\n                const outTensors = outInfos.map(({ dataId, shape, dtype }) => this.makeTensorFromDataId(dataId, shape, dtype));\n                // Save the inputs and outputs.\n                // Do not save unless we are recording to the tape. Otherwise it would\n                // cause a mem leak since we would never run backprop, which disposes\n                // the kept tensors.\n                if (isTapeOn) {\n                    let tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);\n                    if (tensorsToSave == null) {\n                        // Fallback for ops that call runKernelFunc and pass in\n                        // inputsToSave and outputsToSave. Currently this is the set of ops\n                        // with kernel support in the WASM backend. Once those ops and\n                        // respective gradients are modularised we can remove this path.\n                        if (outputsToSave == null) {\n                            outputsToSave = [];\n                        }\n                        const outsToSave = outTensors.filter((_, i) => outputsToSave[i]);\n                        tensorsToSave = (inputsToSave || []).slice().concat(outsToSave);\n                    }\n                    saved = this.saveTensorsForBackwardMode(tensorsToSave);\n                }\n                return outTensors;\n            };\n        }\n        else {\n            const saveFunc = (tensors) => {\n                // Do not save unless we are recording to the tape. Otherwise it would\n                // cause a mem leak since we would never run backprop, which disposes\n                // the kept tensors.\n                if (!isTapeOn) {\n                    return;\n                }\n                saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n            };\n            kernelFunc = () => {\n                const numDataIdsBefore = this.backend.numDataIds();\n                out = this.tidy(() => forwardFunc(this.backend, saveFunc));\n                const outs = (Array.isArray(out) ? out : [out]);\n                if (this.shouldCheckForMemLeaks()) {\n                    this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outs);\n                }\n                return outs;\n            };\n        }\n        // Stop recording to a tape when running a kernel.\n        let kernelProfile;\n        this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {\n            if (!this.ENV.getBool('DEBUG') && !this.state.profiling) {\n                outputs = kernelFunc();\n            }\n            else {\n                kernelProfile = this.profiler.profileKernel(kernelName, inputs, () => kernelFunc());\n                if (this.ENV.getBool('DEBUG')) {\n                    this.profiler.logKernelProfile(kernelProfile);\n                }\n                outputs = kernelProfile.outputs;\n            }\n        });\n        if (isTapeOn) {\n            this.addTapeNode(kernelName, inputs, outputs, backwardsFunc, saved, attrs);\n        }\n        if (this.state.profiling) {\n            this.state.activeProfile.kernels.push({\n                name: kernelName,\n                bytesAdded: this.state.numBytes - startingBytecount,\n                totalBytesSnapshot: this.state.numBytes,\n                tensorsAdded: this.state.numTensors - startingNumTensors,\n                totalTensorsSnapshot: this.state.numTensors,\n                inputShapes: Object.keys(inputs).map(key => inputs[key] != null ? inputs[key].shape : null),\n                outputShapes: outputs.map(item => item.shape),\n                kernelTimeMs: kernelProfile.timeMs,\n                extraInfo: kernelProfile.extraInfo\n            });\n        }\n        return (Array.isArray(out) ? outputs : outputs[0]);\n    }\n    /**\n     * Saves tensors used in forward mode for use in backward mode.\n     *\n     * @param tensors the list of tensors to save.\n     */\n    saveTensorsForBackwardMode(tensors) {\n        const saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n        return saved;\n    }\n    /**\n     * Returns a list of tensors to save for a given gradient calculation.\n     *\n     * Returns undefined if their is no registered gradient for this kernel in the\n     * gradient registry.\n     *\n     * @param kernelName name of kernel to look up gradient for.\n     * @param inputs a map of input tensors.\n     * @param outputs an array of output tensors from forward mode of kernel.\n     */\n    getTensorsForGradient(kernelName, inputs, outputs) {\n        const gradConfig = getGradient(kernelName);\n        if (gradConfig != null) {\n            const inputsToSave = gradConfig.inputsToSave || [];\n            const outputsToSave = gradConfig.outputsToSave || [];\n            // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs\n            // specified in inputsToSave will be saved.\n            let inputTensorsToSave;\n            if (gradConfig.saveAllInputs) {\n                util.assert(Array.isArray(inputs), () => 'saveAllInputs is true, expected inputs to be an array.');\n                inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);\n            }\n            else {\n                inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);\n            }\n            const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);\n            return inputTensorsToSave.concat(outputTensorsToSave);\n        }\n        // TODO(yassogba) throw exception here once all runkernelFunc calls with\n        // inputsToSave/outputsToSave are removed\n        return null;\n    }\n    /**\n     * Internal method used by public APIs for tensor creation. Makes a new\n     * tensor with the provided shape, dtype and values. It always\n     * creates a new data id and writes the values to the underlying backend.\n     */\n    makeTensor(values, shape, dtype, backend) {\n        if (values == null) {\n            throw new Error('Values passed to engine.makeTensor() are null');\n        }\n        dtype = dtype || 'float32';\n        backend = backend || this.backend;\n        let backendVals = values;\n        if (dtype === 'string' && util.isString(values[0])) {\n            backendVals = values.map(d => util.encodeString(d));\n        }\n        const dataId = backend.write(backendVals, shape, dtype);\n        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n        this.incRef(t, backend);\n        // Count bytes for string tensors.\n        if (dtype === 'string') {\n            const info = this.state.tensorInfo.get(dataId);\n            const newBytes = bytesFromStringArray(backendVals);\n            this.state.numBytes += newBytes - info.bytes;\n            info.bytes = newBytes;\n        }\n        return t;\n    }\n    /**\n     * Internal method used by backends. Makes a new tensor\n     * that is a wrapper around an existing data id. It doesn't create\n     * a new data id, only increments the ref count used in memory tracking.\n     */\n    makeTensorFromDataId(dataId, shape, dtype, backend) {\n        dtype = dtype || 'float32';\n        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n        this.incRef(t, backend);\n        return t;\n    }\n    makeVariable(initialValue, trainable = true, name, dtype) {\n        name = name || this.nextVariableId().toString();\n        if (dtype != null && dtype !== initialValue.dtype) {\n            initialValue = initialValue.cast(dtype);\n        }\n        const v = new Variable(initialValue, trainable, name, this.nextTensorId());\n        if (this.state.registeredVariables[v.name] != null) {\n            throw new Error(`Variable with name ${v.name} was already registered`);\n        }\n        this.state.registeredVariables[v.name] = v;\n        this.incRef(v, this.backend);\n        return v;\n    }\n    incRef(a, backend) {\n        const refCount = this.state.tensorInfo.has(a.dataId) ?\n            this.state.tensorInfo.get(a.dataId).refCount :\n            0;\n        this.state.numTensors++;\n        if (a.dtype === 'string') {\n            this.state.numStringTensors++;\n        }\n        if (refCount === 0) {\n            this.state.numDataBuffers++;\n            // Bytes for complex numbers are counted by their components. Bytes for\n            // string tensors are counted when writing values.\n            let bytes = 0;\n            if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n                bytes = a.size * util.bytesPerElement(a.dtype);\n            }\n            this.state.tensorInfo.set(a.dataId, {\n                backend: backend || this.backend,\n                dtype: a.dtype,\n                shape: a.shape,\n                bytes,\n                refCount: 0\n            });\n            this.state.numBytes += bytes;\n        }\n        this.state.tensorInfo.get(a.dataId).refCount++;\n        if (!(a instanceof Variable)) {\n            this.track(a);\n        }\n    }\n    disposeTensor(a) {\n        if (!this.state.tensorInfo.has(a.dataId)) {\n            return;\n        }\n        this.state.numTensors--;\n        if (a.dtype === 'string') {\n            this.state.numStringTensors--;\n        }\n        const info = this.state.tensorInfo.get(a.dataId);\n        const refCount = info.refCount;\n        if (refCount <= 1) {\n            // Don't count bytes for complex numbers as they are counted by their\n            // components.\n            if (a.dtype !== 'complex64') {\n                this.state.numBytes -= info.bytes;\n            }\n            this.state.numDataBuffers--;\n            info.backend.disposeData(a.dataId);\n            this.state.tensorInfo.delete(a.dataId);\n        }\n        else {\n            this.state.tensorInfo.get(a.dataId).refCount--;\n        }\n        // TODO(nsthorat): Construct an error and save the stack trace for\n        // debugging when in debug mode. Creating a stack trace is too expensive\n        // to do unconditionally.\n    }\n    disposeVariables() {\n        for (const varName in this.state.registeredVariables) {\n            const v = this.state.registeredVariables[varName];\n            this.disposeVariable(v);\n        }\n    }\n    disposeVariable(v) {\n        this.disposeTensor(v);\n        if (this.state.registeredVariables[v.name] != null) {\n            delete this.state.registeredVariables[v.name];\n        }\n    }\n    memory() {\n        const info = this.backend.memory();\n        info.numTensors = this.state.numTensors;\n        info.numDataBuffers = this.state.numDataBuffers;\n        info.numBytes = this.state.numBytes;\n        if (this.state.numStringTensors > 0) {\n            info.unreliable = true;\n            if (info.reasons == null) {\n                info.reasons = [];\n            }\n            info.reasons.push('Memory usage by string tensors is approximate ' +\n                '(2 bytes per character)');\n        }\n        return info;\n    }\n    async profile(query) {\n        this.state.profiling = true;\n        const startBytes = this.state.numBytes;\n        const startNumTensors = this.state.numTensors;\n        this.state.activeProfile.kernels = [];\n        this.state.activeProfile.result = await query();\n        this.state.profiling = false;\n        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(d => d.totalBytesSnapshot));\n        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;\n        this.state.activeProfile.newTensors =\n            this.state.numTensors - startNumTensors;\n        for (const kernel of this.state.activeProfile.kernels) {\n            kernel.kernelTimeMs = await kernel.kernelTimeMs;\n            kernel.extraInfo = await kernel.extraInfo;\n        }\n        return this.state.activeProfile;\n    }\n    isTapeOn() {\n        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;\n    }\n    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {\n        const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };\n        const gradConfig = getGradient(kernelName);\n        if (gradConfig != null) {\n            gradientsFunc = gradConfig.gradFunc;\n        }\n        if (gradientsFunc != null) {\n            tapeNode.gradient = (dys) => {\n                // TODO(smilkov): To optimize back-prop, pass dys that are not used in\n                // the backprop graph to the user as null instead of zeros\n                dys = dys.map((dy, i) => {\n                    if (dy == null) {\n                        const output = outputs[i];\n                        const vals = util.makeZerosTypedArray(output.size, output.dtype);\n                        return this.makeTensor(vals, output.shape, output.dtype);\n                    }\n                    return dy;\n                });\n                // Grad functions of ops with single outputs expect a dy, while ops\n                // with multiple outputs expect dys (array of dy).\n                return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);\n            };\n        }\n        this.state.activeTape.push(tapeNode);\n    }\n    keep(result) {\n        result.kept = true;\n        return result;\n    }\n    startTape() {\n        if (this.state.gradientDepth === 0) {\n            this.state.activeTape = [];\n        }\n        this.state.gradientDepth++;\n    }\n    endTape() {\n        this.state.gradientDepth--;\n    }\n    /**\n     * Start a scope. Use this with endScope() to achieve the same functionality\n     * as scope() without the need for a function closure.\n     */\n    startScope(name) {\n        const scopeInfo = {\n            track: [],\n            name: 'unnamed scope',\n            id: this.state.nextScopeId++\n        };\n        if (name) {\n            scopeInfo.name = name;\n        }\n        this.state.scopeStack.push(scopeInfo);\n        this.state.activeScope = scopeInfo;\n    }\n    /**\n     * End a scope. Use this with startScope() to achieve the same functionality\n     * as scope() without the need for a function closure.\n     */\n    endScope(result) {\n        const tensorsToTrackInParent = getTensorsInContainer(result);\n        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(t => t.id));\n        // Dispose the arrays tracked in this scope.\n        for (let i = 0; i < this.state.activeScope.track.length; i++) {\n            const tensor = this.state.activeScope.track[i];\n            if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {\n                tensor.dispose();\n            }\n        }\n        const oldScope = this.state.scopeStack.pop();\n        this.state.activeScope = this.state.scopeStack.length === 0 ?\n            null :\n            this.state.scopeStack[this.state.scopeStack.length - 1];\n        // Track the current result in the parent scope.\n        tensorsToTrackInParent.forEach(tensor => {\n            // Only track the tensor if was allocated in the inner scope and is not\n            // globally kept.\n            if (!tensor.kept && tensor.scopeId === oldScope.id) {\n                this.track(tensor);\n            }\n        });\n    }\n    /**\n     * Returns gradients of `f` with respect to each of the `xs`. The gradients\n     * returned are of the same length as `xs`, but some might be null if `f`\n     * was not a function of that `x`. It also takes optional dy to multiply the\n     * gradient, which defaults to `1`.\n     */\n    gradients(f, xs, dy, allowNoGradients = false) {\n        util.assert(xs.length > 0, () => 'gradients() received an empty list of xs.');\n        if (dy != null && dy.dtype !== 'float32') {\n            throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);\n        }\n        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy('forward', f));\n        util.assert(y instanceof Tensor, () => 'The result y returned by f() must be a tensor.');\n        // Filter out the nodes that don't connect x => y.\n        const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);\n        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {\n            throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +\n                'that the f you passed encloses all operations that lead from x ' +\n                'to y.');\n        }\n        return this.tidy('backward', () => {\n            const accumulatedGradientMap = {};\n            accumulatedGradientMap[y.id] = (dy == null) ? ones(y.shape) : dy;\n            // Backprop gradients through the filtered nodes.\n            backpropagateGradients(accumulatedGradientMap, filteredTape, \n            // Pass the tidy function to avoid circular dep with `tape.ts`.\n            f => this.tidy(f), \n            // Pass an add function to avoide a circular dep with `tape.ts`.\n            add);\n            const grads = xs.map(x => accumulatedGradientMap[x.id]);\n            if (this.state.gradientDepth === 0) {\n                // This means that we are not computing higher-order gradients\n                // and can clean up the tape.\n                this.state.activeTape.forEach(node => {\n                    for (const tensor of node.saved) {\n                        tensor.dispose();\n                    }\n                });\n                this.state.activeTape = null;\n            }\n            return { value: y, grads };\n        });\n    }\n    customGrad(f) {\n        util.assert(util.isFunction(f), () => 'The f passed in customGrad(f) must be a function.');\n        return (...inputs) => {\n            util.assert(inputs.every(t => t instanceof Tensor), () => 'The args passed in customGrad(f)(x1, x2,...) must all be ' +\n                'tensors');\n            let res;\n            const inputMap = {};\n            inputs.forEach((input, i) => {\n                inputMap[i] = input;\n            });\n            return this.runKernelFunc((_, save) => {\n                res = f(...[...inputs, save]);\n                util.assert(res.value instanceof Tensor, () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.value` is a tensor');\n                util.assert(util.isFunction(res.gradFunc), () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function.');\n                return res.value;\n            }, inputMap, (dy, saved) => {\n                const gradRes = res.gradFunc(dy, saved);\n                const grads = Array.isArray(gradRes) ? gradRes : [gradRes];\n                util.assert(grads.length === inputs.length, () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function that returns ' +\n                    'the same number of tensors as inputs passed to f(...).');\n                util.assert(grads.every(t => t instanceof Tensor), () => 'The function f passed in customGrad(f) must return an ' +\n                    'object where `obj.gradFunc` is a function that returns ' +\n                    'a list of only tensors.');\n                const gradMap = {};\n                grads.forEach((grad, i) => {\n                    gradMap[i] = () => grad;\n                });\n                return gradMap;\n            });\n        };\n    }\n    readSync(dataId) {\n        // Route the read to the correct backend.\n        const info = this.state.tensorInfo.get(dataId);\n        return info.backend.readSync(dataId);\n    }\n    read(dataId) {\n        // Route the read to the correct backend.\n        const info = this.state.tensorInfo.get(dataId);\n        return info.backend.read(dataId);\n    }\n    async time(query) {\n        const start = now();\n        const timingInfo = await this.backend.time(query);\n        timingInfo.wallMs = now() - start;\n        return timingInfo;\n    }\n    /**\n     * Tracks a Tensor in the current scope to be automatically cleaned up\n     * when the current scope ends, and returns the value.\n     *\n     * @param result The Tensor to track in the current scope.\n     */\n    track(result) {\n        if (this.state.activeScope != null) {\n            result.scopeId = this.state.activeScope.id;\n            this.state.activeScope.track.push(result);\n        }\n        return result;\n    }\n    get registeredVariables() {\n        return this.state.registeredVariables;\n    }\n    /**\n     * Resets the engine state. Removes all backends but does not remove\n     * registered backend factories.\n     */\n    reset() {\n        // Make any pending promise obsolete.\n        this.pendingBackendInitId++;\n        this.state.dispose();\n        this.ENV.reset();\n        this.state = new EngineState();\n        for (const backendName in this.registry) {\n            this.disposeRegisteredKernels(backendName);\n            this.registry[backendName].dispose();\n            delete this.registry[backendName];\n        }\n        this.backendName = null;\n        this.backendInstance = null;\n        this.pendingBackendInit = null;\n    }\n}\nEngine.nextTensorId = 0;\nEngine.nextVariableId = 0;\nfunction ones(shape) {\n    const values = makeOnesTypedArray(sizeFromShape(shape), 'float32');\n    return ENGINE.makeTensor(values, shape, 'float32');\n}\nfunction getOrMakeEngine() {\n    const ns = getGlobalNamespace();\n    if (ns._tfengine == null) {\n        const environment = new Environment(ns);\n        ns._tfengine = new Engine(environment);\n    }\n    setEnvironmentGlobal(ns._tfengine.ENV);\n    // Tell the current tensor interface that the global engine is responsible\n    // for tracking.\n    setTensorTracker(() => ns._tfengine);\n    return ns._tfengine;\n}\nexport const ENGINE = getOrMakeEngine();\n/**\n * A implementation of the add op for use within engine and tape.\n *\n * This allows us to avoid a circular dependency between add.ts and engine.\n * It is exported to be available in tape tests.\n */\nexport function add(a, b) {\n    // We duplicate Add here to avoid a circular dependency with add.ts.\n    const inputs = { a, b };\n    return ENGINE.runKernelFunc((backend, save) => {\n        const res = backend.add(a, b);\n        save([a, b]);\n        return res;\n    }, inputs, null /* gradient */, Add);\n}\n//# sourceMappingURL=engine.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from './util';\n/**\n * Computes a list of TapeNodes that connect x to y, filtering everything else\n * out and preserving the order of the original tape elements.\n *\n * @param tape The tape elements to filter.\n * @param xs The input Tensors.\n * @param y The output Tensor.\n */\nexport function getFilteredNodesXToY(tape, xs, y) {\n    // Forward pass to compute all the nodes and Tensors that are transitively a\n    // function of x.\n    const tensorsFromX = {};\n    const nodesFromX = {};\n    for (let i = 0; i < xs.length; i++) {\n        tensorsFromX[xs[i].id] = true;\n    }\n    for (let i = 0; i < tape.length; i++) {\n        const node = tape[i];\n        const nodeInputs = node.inputs;\n        for (const inputName in nodeInputs) {\n            const input = nodeInputs[inputName];\n            let anyInputFromX = false;\n            for (let j = 0; j < xs.length; j++) {\n                if (tensorsFromX[input.id]) {\n                    node.outputs.forEach(output => tensorsFromX[output.id] = true);\n                    anyInputFromX = true;\n                    nodesFromX[node.id] = true;\n                    break;\n                }\n            }\n            if (anyInputFromX) {\n                break;\n            }\n        }\n    }\n    // Backward pass to find all of the nodes and Tensors that lead to y.\n    const tensorsLeadToY = {};\n    tensorsLeadToY[y.id] = true;\n    const nodesToY = {};\n    for (let i = tape.length - 1; i >= 0; i--) {\n        const node = tape[i];\n        const nodeInputs = node.inputs;\n        // If any of the outputs lead to y, mark all of the inputs as leading to y.\n        for (let j = 0; j < node.outputs.length; j++) {\n            if (tensorsLeadToY[node.outputs[j].id]) {\n                for (const inputName in nodeInputs) {\n                    tensorsLeadToY[nodeInputs[inputName].id] = true;\n                    nodesToY[node.id] = true;\n                }\n                break;\n            }\n        }\n    }\n    // Return the paths that come from x and lead to y.\n    const filteredTape = [];\n    for (let i = 0; i < tape.length; i++) {\n        const node = tape[i];\n        if (nodesFromX[node.id] && nodesToY[node.id]) {\n            // Prune the inputs from the node that aren't a function of x.\n            const prunedInputs = {};\n            for (const inputName in node.inputs) {\n                const nodeInput = node.inputs[inputName];\n                if (tensorsFromX[nodeInput.id]) {\n                    prunedInputs[inputName] = nodeInput;\n                }\n            }\n            // Copy the node and overwrite inputsAndArgs to the pruned version.\n            const prunedNode = Object.assign({}, node);\n            prunedNode.inputs = prunedInputs;\n            prunedNode.outputs = node.outputs;\n            filteredTape.push(prunedNode);\n        }\n    }\n    return filteredTape;\n}\n/**\n * Backpropagate gradients through the filtered TapeNodes.\n *\n * @param tensorAccumulatedGradientMap A map of Tensor to its gradient. This map\n * is mutated by this method.\n * @param filteredTape The filtered TapeNodes to backprop through.\n */\nexport function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy, add) {\n    // Walk the tape backward and keep a map of Tensor to its gradient.\n    for (let i = filteredTape.length - 1; i >= 0; i--) {\n        const node = filteredTape[i];\n        const dys = [];\n        node.outputs.forEach(o => {\n            const gradTensor = tensorAccumulatedGradientMap[o.id];\n            if (gradTensor != null) {\n                dys.push(gradTensor);\n            }\n            else {\n                // This particular output is not in the back-propagation subgraph, so it\n                // does not affect the final output, thus we put null for its dy.\n                dys.push(null);\n            }\n        });\n        if (node.gradient == null) {\n            throw new Error(`Cannot compute gradient: gradient function not found ` +\n                `for ${node.kernelName}.`);\n        }\n        // Backprop dy through this node and accumulate gradients over the inputs.\n        const inputGradients = node.gradient(dys);\n        for (const inputName in node.inputs) {\n            if (!(inputName in inputGradients)) {\n                throw new Error(`Cannot backprop through input ${inputName}. ` +\n                    `Available gradients found: ${Object.keys(inputGradients)}.`);\n            }\n            // Call the gradient function.\n            const dx = tidy(() => inputGradients[inputName]());\n            if (dx.dtype !== 'float32') {\n                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +\n                    `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);\n            }\n            const x = node.inputs[inputName];\n            if (!util.arraysEqual(dx.shape, x.shape)) {\n                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +\n                    `'${inputName}' has shape '${dx.shape}', which does not match ` +\n                    `the shape of the input '${x.shape}'`);\n            }\n            if (tensorAccumulatedGradientMap[x.id] == null) {\n                tensorAccumulatedGradientMap[x.id] = dx;\n            }\n            else {\n                const curGradient = tensorAccumulatedGradientMap[x.id];\n                tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);\n                curGradient.dispose();\n            }\n        }\n    }\n}\n//# sourceMappingURL=tape.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n    let firstElem = val;\n    if (isTypedArray(val)) {\n        return dtype === 'string' ? [] : [val.length];\n    }\n    if (!Array.isArray(val)) {\n        return []; // Scalar.\n    }\n    const shape = [];\n    while (Array.isArray(firstElem) ||\n        isTypedArray(firstElem) && dtype !== 'string') {\n        shape.push(firstElem.length);\n        firstElem = firstElem[0];\n    }\n    if (Array.isArray(val) &&\n        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n        deepAssertShapeConsistency(val, shape, []);\n    }\n    return shape;\n}\nfunction deepAssertShapeConsistency(val, shape, indices) {\n    indices = indices || [];\n    if (!(Array.isArray(val)) && !isTypedArray(val)) {\n        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +\n            `but should be an array/TypedArray of ${shape[0]} elements`);\n        return;\n    }\n    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +\n        `but is an array of ${val.length} elements`);\n    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\n        `elements, but has ${val.length} elements`);\n    const subShape = shape.slice(1);\n    for (let i = 0; i < val.length; ++i) {\n        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n    }\n}\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n    if (expectedDtype == null) {\n        return;\n    }\n    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\n        expectedDtype === 'numeric' && actualDType === 'string') {\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +\n            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n    }\n}\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\n    if (x instanceof Tensor) {\n        assertDtype(parseAsDtype, x.dtype, argName, functionName);\n        return x;\n    }\n    let inferredDtype = inferDtype(x);\n    // If the user expects a bool/int/float, use that info to update the\n    // inferredDtype when it is not a string.\n    if (inferredDtype !== 'string' &&\n        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n        inferredDtype = parseAsDtype;\n    }\n    assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n    if ((x == null) ||\n        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\n            typeof x !== 'boolean' && typeof x !== 'string')) {\n        const type = x == null ? 'null' : x.constructor.name;\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +\n            `Tensor or TensorLike, but got '${type}'`);\n    }\n    const inferredShape = inferShape(x, inferredDtype);\n    if (!isTypedArray(x) && !Array.isArray(x)) {\n        x = [x];\n    }\n    const skipTypedArray = true;\n    const values = inferredDtype !== 'string' ?\n        toTypedArray(x, inferredDtype) :\n        flatten(x, [], skipTypedArray);\n    return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\n    if (!Array.isArray(arg)) {\n        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +\n            '`Tensor[]` or `TensorLike[]`');\n    }\n    const tensors = arg;\n    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName), parseAsDtype);\n}\n//# sourceMappingURL=tensor_util_env.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\n/**\n * Used for wrapping functions that perform math operations on\n * Tensors. The function will be wrapped in a named scope that cleans all\n * memory usage after the function is done.\n */\nexport function op(f) {\n    const keys = Object.keys(f);\n    if (keys.length !== 1) {\n        throw new Error(`Please provide an object with a single key ` +\n            `(operation name) mapping to a function. Got an object with ` +\n            `${keys.length} keys.`);\n    }\n    let opName = keys[0];\n    const fn = f[opName];\n    // Strip the underscore from the end of the function name.\n    if (opName.endsWith('_')) {\n        opName = opName.substring(0, opName.length - 1);\n    }\n    // tslint:disable-next-line:no-any\n    const f2 = (...args) => {\n        ENGINE.startScope(opName);\n        try {\n            const result = fn(...args);\n            if (result instanceof Promise) {\n                console.error('Cannot return a Promise inside of tidy.');\n            }\n            ENGINE.endScope(result);\n            return result;\n        }\n        catch (ex) {\n            ENGINE.endScope(null);\n            throw ex;\n        }\n    };\n    Object.defineProperty(f2, 'name', { value: opName, configurable: true });\n    // tslint:disable-next-line:no-any\n    return f2;\n}\n//# sourceMappingURL=operation.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Complex } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * Converts two real numbers to a complex number.\n *\n * Given a tensor `real` representing the real part of a complex number, and a\n * tensor `imag` representing the imaginary part of a complex number, this\n * operation returns complex numbers elementwise of the form [r0, i0, r1, i1],\n * where r represents the real part and i represents the imag part.\n *\n * The input tensors real and imag must have the same shape.\n *\n * ```js\n * const real = tf.tensor1d([2.25, 3.25]);\n * const imag = tf.tensor1d([4.75, 5.75]);\n * const complex = tf.complex(real, imag);\n *\n * complex.print();\n * ```\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction complex_(real, imag) {\n    const $real = convertToTensor(real, 'real', 'complex');\n    const $imag = convertToTensor(imag, 'imag', 'complex');\n    util.assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, ` +\n        `must match in call to tf.complex().`);\n    const forward = (backend) => {\n        return backend.complex($real, $imag);\n    };\n    const inputs = { real: $real, imag: $imag };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Complex);\n}\nexport const complex = op({ complex_ });\n//# sourceMappingURL=complex.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n//# sourceMappingURL=tensor_ops_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function tensor(values, shape, dtype) {\n    const inferredShape = inferShape(values, dtype);\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Cast } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * Casts a `tf.Tensor` to a new dtype.\n *\n * ```js\n * const x = tf.tensor1d([1.5, 2.5, 3]);\n * tf.cast(x, 'int32').print();\n * ```\n * @param x The input tensor to be casted.\n * @param dtype The dtype to cast the input tensor to.\n */\n/** @doc {heading: 'Tensors', subheading: 'Transformations'} */\nfunction cast_(x, dtype) {\n    const $x = convertToTensor(x, 'x', 'cast');\n    // Sanity checks.\n    if (!util.isValidDtype(dtype)) {\n        throw new Error(`Failed to cast to unknown dtype ${dtype}`);\n    }\n    if (dtype === 'string' && $x.dtype !== 'string' ||\n        dtype !== 'string' && $x.dtype === 'string') {\n        throw new Error('Only strings can be casted to strings');\n    }\n    const inputs = { x: $x };\n    const attrs = { dtype };\n    return ENGINE.runKernelFunc(backend => backend.cast($x, dtype), inputs, null /* grad */, Cast, attrs);\n}\nexport const cast = op({ cast_ });\n//# sourceMappingURL=cast.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Reshape } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * Reshapes a `tf.Tensor` to a given shape.\n *\n * Given an input tensor, returns a new tensor with the same values as the\n * input tensor with shape `shape`.\n *\n * If one component of shape is the special value -1, the size of that\n * dimension is computed so that the total size remains constant. In\n * particular, a shape of [-1] flattens into 1-D. At most one component of\n * shape can be -1.\n *\n * If shape is 1-D or higher, then the operation returns a tensor with shape\n * shape filled with the values of tensor. In this case, the number of\n * elements implied by shape must be the same as the number of elements in\n * tensor.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * x.reshape([2, 2]).print();\n * ```\n *\n * @param x The input tensor to be reshaped.\n * @param shape An array of integers defining the output tensor shape.\n */\n/** @doc {heading: 'Tensors', subheading: 'Transformations'} */\nfunction reshape_(x, shape) {\n    const $x = convertToTensor(x, 'x', 'reshape', null);\n    shape = util.inferFromImplicitShape(shape, $x.size);\n    util.assert($x.size === util.sizeFromShape(shape), () => 'new shape and old shape must have the same number of elements.');\n    const inputs = { x: $x };\n    const attrs = { shape };\n    const forward = (backend, save) => {\n        save([$x]);\n        return backend.reshape($x, shape);\n    };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Reshape, attrs);\n}\nexport const reshape = op({ reshape_ });\n//# sourceMappingURL=reshape.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Transpose } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * Transposes the `tf.Tensor`. Permutes the dimensions according to `perm`.\n *\n * The returned `tf.Tensor`'s dimension `i` will correspond to the input\n * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\n * where `n` is the rank of the input `tf.Tensor`. Hence by default, this\n * operation performs a regular matrix transpose on 2-D input `tf.Tensor`s.\n *\n * ```js\n * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n *\n * a.transpose().print();  // or tf.transpose(a)\n * ```\n *\n * @param x The tensor to transpose.\n * @param perm The permutation of the dimensions of a.\n */\n/** @doc {heading: 'Operations', subheading: 'Matrices'} */\nfunction transpose_(x, perm) {\n    const $x = convertToTensor(x, 'x', 'transpose');\n    if (perm == null) {\n        perm = $x.shape.map((s, i) => i).reverse();\n    }\n    util.assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} ` +\n        `must match length of perm ${perm}.`);\n    perm.forEach(axis => {\n        util.assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1}` +\n            ` but got ${perm}`);\n    });\n    if ($x.rank <= 1) {\n        return $x.clone();\n    }\n    const inputs = { x: $x };\n    const attrs = { perm };\n    return ENGINE.runKernelFunc(backend => backend.transpose($x, perm), inputs, null /* gradient */, Transpose, attrs);\n}\nexport const transpose = op({ transpose_ });\n//# sourceMappingURL=transpose.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n * Returns true if the axis specifies the inner most dimensions of the\n * array.\n */\nexport function axesAreInnerMostDims(axes, rank) {\n    for (let i = 0; i < axes.length; ++i) {\n        if (axes[axes.length - i - 1] !== rank - 1 - i) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function combineLocations(outputLoc, reduceLoc, axes) {\n    const rank = outputLoc.length + reduceLoc.length;\n    const loc = [];\n    let outIdx = 0;\n    let reduceIdx = 0;\n    for (let dim = 0; dim < rank; dim++) {\n        if (axes.indexOf(dim) === -1) {\n            loc.push(outputLoc[outIdx++]);\n        }\n        else {\n            loc.push(reduceLoc[reduceIdx++]);\n        }\n    }\n    return loc;\n}\nexport function computeOutAndReduceShapes(aShape, axes) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (axes.indexOf(dim) === -1) {\n            outShape.push(aShape[dim]);\n        }\n    }\n    const reduceShape = axes.map(dim => aShape[dim]);\n    return [outShape, reduceShape];\n}\nexport function expandShapeToKeepDim(shape, axes) {\n    const reduceSubShape = axes.map(x => 1);\n    return combineLocations(shape, reduceSubShape, axes);\n}\nexport function assertAxesAreInnerMostDims(msg, axes, rank) {\n    util.assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. ` +\n        `Got axes ${axes} and rank-${rank} input.`);\n}\n/**\n * Returns the axes permutation to be used with `tf.transpose`, if such\n * permutation is necessary. Otherwise it returns null. This method is used by\n * operations that operate only on inner-most axes.\n */\nexport function getAxesPermutation(axes, rank) {\n    if (axesAreInnerMostDims(axes, rank)) {\n        return null;\n    }\n    const result = [];\n    for (let i = 0; i < rank; ++i) {\n        if (axes.indexOf(i) === -1) {\n            result.push(i);\n        }\n    }\n    axes.forEach(axis => result.push(axis));\n    return result;\n}\n/** Returns the axes permutation that undoes the original permutation. */\nexport function getUndoAxesPermutation(axes) {\n    return axes.map((axis, i) => [i, axis])\n        .sort((a, b) => a[1] - b[1])\n        .map(x => x[0]);\n}\nexport function getInnerMostAxes(numAxes, rank) {\n    const res = [];\n    for (let i = rank - numAxes; i < rank; ++i) {\n        res.push(i);\n    }\n    return res;\n}\n//# sourceMappingURL=axis_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Max } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport * as axis_util from './axis_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { transpose } from './transpose';\n/**\n * Computes the maximum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.max().print();  // or tf.max(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.max(axis).print();  // or tf.max(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction max_(x, axis = null, keepDims = false) {\n    const $x = convertToTensor(x, 'x', 'max');\n    const forward = (backend, save) => {\n        const origAxes = util.parseAxisParam(axis, $x.shape);\n        let axes = origAxes;\n        const permutedAxes = axis_util.getAxesPermutation(axes, $x.rank);\n        let maxInput = $x;\n        if (permutedAxes != null) {\n            maxInput = transpose($x, permutedAxes);\n            axes = axis_util.getInnerMostAxes(axes.length, maxInput.rank);\n        }\n        const y = backend.max(maxInput, axes);\n        if (permutedAxes != null) {\n            maxInput.dispose();\n        }\n        let res = y;\n        if (keepDims) {\n            const expandedShape = axis_util.expandShapeToKeepDim(res.shape, util.parseAxisParam(axis, $x.shape));\n            res = reshape(res, expandedShape);\n            y.dispose();\n        }\n        save([$x, res]);\n        return res;\n    };\n    const inputs = { x: $x };\n    const attrs = { reductionIndices: axis, keepDims };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Max, attrs);\n}\nexport const max = op({ max_ });\n//# sourceMappingURL=max.js.map","import { computeStrides } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    if (tensor.rank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensor.rank}.`);\n    }\n    if (indices.rank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indices.rank - 1] > tensor.rank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indices.rank - 1]} vs. ${tensor.rank}`);\n    }\n    if (tensor.size === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensor.rank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=gather_nd_util.js.map","import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n    if (updates.rank < batchDim) {\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n    }\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\n        throw new Error(shapeError +\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n    }\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n    }\n    for (let d = 0; d < batchDim; ++d) {\n        if (updates.shape[d] !== indices.shape[d]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n        }\n    }\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n        }\n    }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n    if (indices.rank < 1) {\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (updates.rank < 1) {\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\n            ` but the rank was ${updates.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n    }\n    if (shape.length < 1) {\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n    }\n    if (shape.length === 0) {\n        if (indices.size === 0) {\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n        }\n        if (updates.size === 0) {\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n        }\n    }\n    validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n    // Calculate the number of dimensions in indices\n    const indicesRank = indices.shape.length;\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n    // Calculate the number of elements that make up each slice of our updated\n    // tensor. This allows us to work with flattened tensors and copy over whole\n    // slices at a time.\n    const totalNd = shape.length;\n    let sliceSize = 1;\n    for (let i = sliceRank; i < totalNd; ++i) {\n        sliceSize *= shape[i];\n    }\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n    const outputSize = sizeFromShape(shape);\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\n}\n//# sourceMappingURL=scatter_nd_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { setDeprecationWarningFn } from './tensor';\nimport { getTensorsInContainer } from './tensor_util';\n/**\n * Enables production mode which disables correctness checks in favor of\n * performance.\n */\n/** @doc {heading: 'Environment'} */\nexport function enableProdMode() {\n    env().set('PROD', true);\n}\n/**\n * Enables debug mode which will log information about all executed kernels:\n * the elapsed time of the kernel execution, as well as the rank, shape, and\n * size of the output tensor.\n *\n * Debug mode will significantly slow down your application as it will\n * download the result of every operation to the CPU. This should not be used in\n * production. Debug mode does not affect the timing information of the kernel\n * execution as we do not measure download time in the kernel execution time.\n *\n * See also: `tf.profile`, `tf.memory`.\n */\n/** @doc {heading: 'Environment'} */\nexport function enableDebugMode() {\n    env().set('DEBUG', true);\n}\n/** Globally disables deprecation warnings */\nexport function disableDeprecationWarnings() {\n    env().set('DEPRECATION_WARNINGS_ENABLED', false);\n    console.warn(`TensorFlow.js deprecation warnings have been disabled.`);\n}\n/** Warn users about deprecated functionality. */\nexport function deprecationWarn(msg) {\n    if (env().getBool('DEPRECATION_WARNINGS_ENABLED')) {\n        console.warn(msg + ' You can disable deprecation warnings with ' +\n            'tf.disableDeprecationWarnings().');\n    }\n}\nsetDeprecationWarningFn(deprecationWarn);\n/**\n * Dispose all variables kept in backend engine.\n */\n/** @doc {heading: 'Environment'} */\nexport function disposeVariables() {\n    ENGINE.disposeVariables();\n}\n/**\n * It returns the global engine that keeps track of all tensors and backends.\n */\n/** @doc {heading: 'Environment'} */\nexport function engine() {\n    return ENGINE;\n}\n/**\n * Returns memory info at the current time in the program. The result is an\n * object with the following properties:\n *\n * - `numBytes`: Number of bytes allocated (undisposed) at this time.\n * - `numTensors`: Number of unique tensors allocated.\n * - `numDataBuffers`: Number of unique data buffers allocated\n *   (undisposed) at this time, which is ≤ the number of tensors\n *   (e.g. `a.reshape(newShape)` makes a new Tensor that shares the same\n *   data buffer with `a`).\n * - `unreliable`: True if the memory usage is unreliable. See `reasons` when\n *    `unreliable` is true.\n * - `reasons`: `string[]`, reasons why the memory is unreliable, present if\n *    `unreliable` is true.\n *\n * WebGL Properties:\n * - `numBytesInGPU`: Number of bytes allocated (undisposed) in the GPU only at\n *     this time.\n */\n/** @doc {heading: 'Performance', subheading: 'Memory'} */\nexport function memory() {\n    return ENGINE.memory();\n}\n/**\n * Executes the provided function `f()` and returns a promise that resolves\n * with information about the function's memory use:\n * - `newBytes`: the number of new bytes allocated\n * - `newTensors`: the number of new tensors created\n * - `peakBytes`: the peak number of bytes allocated\n * - `kernels`: an array of objects for each kernel involved that reports\n * their input and output shapes, number of bytes used, and number of new\n * tensors created.\n *\n * ```js\n * const profile = await tf.profile(() => {\n *   const x = tf.tensor1d([1, 2, 3]);\n *   let x2 = x.square();\n *   x2.dispose();\n *   x2 = x.square();\n *   x2.dispose();\n *   return x;\n * });\n *\n * console.log(`newBytes: ${profile.newBytes}`);\n * console.log(`newTensors: ${profile.newTensors}`);\n * console.log(`byte usage over all kernels: ${profile.kernels.map(k =>\n * k.totalBytesSnapshot)}`);\n * ```\n *\n */\n/** @doc {heading: 'Performance', subheading: 'Profile'} */\nexport function profile(f) {\n    return ENGINE.profile(f);\n}\n/**\n * Executes the provided function `fn` and after it is executed, cleans up all\n * intermediate tensors allocated by `fn` except those returned by `fn`.\n * `fn` must not return a Promise (async functions not allowed). The returned\n * result can be a complex object.\n *\n * Using this method helps avoid memory leaks. In general, wrap calls to\n * operations in `tf.tidy` for automatic memory cleanup.\n *\n * NOTE: Variables do *not* get cleaned up when inside a tidy(). If you want to\n * dispose variables, please use `tf.disposeVariables` or call dispose()\n * directly on variables.\n *\n * ```js\n * // y = 2 ^ 2 + 1\n * const y = tf.tidy(() => {\n *   // a, b, and one will be cleaned up when the tidy ends.\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *   const b = a.square();\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * y.print();\n * ```\n *\n * @param nameOrFn The name of the closure, or the function to execute.\n *     If a name is provided, the 2nd argument should be the function.\n *     If debug mode is on, the timing and the memory usage of the function\n *     will be tracked and displayed on the console using the provided name.\n * @param fn The function to execute.\n */\n/** @doc {heading: 'Performance', subheading: 'Memory'} */\nexport function tidy(nameOrFn, fn) {\n    return ENGINE.tidy(nameOrFn, fn);\n}\n/**\n * Disposes any `tf.Tensor`s found within the provided object.\n *\n * @param container an object that may be a `tf.Tensor` or may directly\n *     contain `tf.Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. If\n *     the object is not a `tf.Tensor` or does not contain `Tensors`, nothing\n *     happens. In general it is safe to pass any object here, except that\n *     `Promise`s are not supported.\n */\n/** @doc {heading: 'Performance', subheading: 'Memory'} */\nexport function dispose(container) {\n    const tensors = getTensorsInContainer(container);\n    tensors.forEach(tensor => tensor.dispose());\n}\n/**\n * Keeps a `tf.Tensor` generated inside a `tf.tidy` from being disposed\n * automatically.\n *\n * ```js\n * let b;\n * const y = tf.tidy(() => {\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *\n *   // b will not be cleaned up by the tidy. a and one will be cleaned up\n *   // when the tidy ends.\n *   b = tf.keep(a.square());\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * console.log('y:');\n * y.print();\n * console.log('b:');\n * b.print();\n * ```\n *\n * @param result The tensor to keep from being disposed.\n */\n/** @doc {heading: 'Performance', subheading: 'Memory'} */\nexport function keep(result) {\n    return ENGINE.keep(result);\n}\n/**\n * Executes `f()` and returns a promise that resolves with timing\n * information.\n *\n * The result is an object with the following properties:\n *\n * - `wallMs`: Wall execution time.\n * - `kernelMs`: Kernel execution time, ignoring data transfer. If using the\n * WebGL backend and the query timer extension is not available, this will\n * return an error object.\n * - On `WebGL` The following additional properties exist:\n *   - `uploadWaitMs`: CPU blocking time on texture uploads.\n *   - `downloadWaitMs`: CPU blocking time on texture downloads (readPixels).\n *\n * ```js\n * const x = tf.randomNormal([20, 20]);\n * const time = await tf.time(() => x.matMul(x));\n *\n * console.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);\n * ```\n *\n * @param f The function to execute and time.\n */\n/** @doc {heading: 'Performance', subheading: 'Timing'} */\nexport function time(f) {\n    return ENGINE.time(f);\n}\n/**\n * Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and\n * executing operations on those tensors. Returns a promise that resolves\n * to a boolean if the backend initialization was successful.\n *\n * Note this disposes the current backend, if any, as well as any tensors\n * associated with it. A new backend is initialized, even if it is of the\n * same type as the previous one.\n *\n * @param backendName The name of the backend. Currently supports\n *     `'webgl'|'cpu'` in the browser, `'tensorflow'` under node.js\n *     (requires tfjs-node), and `'wasm'` (requires tfjs-backend-wasm).\n */\n/** @doc {heading: 'Backends'} */\nexport function setBackend(backendName) {\n    return ENGINE.setBackend(backendName);\n}\n/**\n * Returns a promise that resolves when the currently selected backend (or the\n * highest priority one) has initialized. Await this promise when you are using\n * a backend that has async initialization.\n */\n/** @doc {heading: 'Backends'} */\nexport function ready() {\n    return ENGINE.ready();\n}\n/**\n * Returns the current backend name (cpu, webgl, etc). The backend is\n * responsible for creating tensors and executing operations on those tensors.\n */\n/** @doc {heading: 'Backends'} */\nexport function getBackend() {\n    return ENGINE.backendName;\n}\n/**\n * Removes a backend and the registered factory.\n */\n/** @doc {heading: 'Backends'} */\nexport function removeBackend(name) {\n    ENGINE.removeBackend(name);\n}\n/**\n * Finds the backend registered under the provided name. Returns null if the\n * name is not in the registry, or the registration hasn't finished yet.\n */\nexport function findBackend(name) {\n    return ENGINE.findBackend(name);\n}\n/**\n * Finds the backend factory registered under the provided name. Returns a\n * function that produces a new backend when called. Returns null if the name\n * is not in the registry.\n */\nexport function findBackendFactory(name) {\n    return ENGINE.findBackendFactory(name);\n}\n/**\n * Registers a global backend. The registration should happen when importing\n * a module file (e.g. when importing `backend_webgl.ts`), and is used for\n * modular builds (e.g. custom tfjs bundle with only webgl support).\n *\n * @param factory The backend factory function. When called, it should\n * return a backend instance, or a promise of an instance.\n * @param priority The priority of the backend (higher = more important).\n *     In case multiple backends are registered, the priority is used to find\n *     the best backend. Defaults to 1.\n * @return False if there is already a registered backend under this name, true\n *     if not.\n */\n/** @doc {heading: 'Backends'} */\nexport function registerBackend(name, factory, priority = 1) {\n    return ENGINE.registerBackend(name, factory, priority);\n}\n/**\n * Gets the current backend. If no backends have been initialized, this will\n * attempt to initialize the best backend. Will throw an error if the highest\n * priority backend has async initialization, in which case, you should call\n * 'await tf.ready()' before running other code.\n */\n/** @doc {heading: 'Backends'} */\nexport function backend() {\n    return ENGINE.backend;\n}\n/**\n * Sets the global platform.\n *\n * @param platformName The name of this platform.\n * @param platform A platform implementation.\n */\nexport function setPlatform(platformName, platform) {\n    env().setPlatform(platformName, platform);\n}\n//# sourceMappingURL=globals.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { FloorDiv } from '../kernel_names';\nimport { makeTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.\n * The result is rounded with floor function.\n *\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 9, 16]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.floorDiv(b).print();  // or tf.div(a, b)\n * ```\n *\n * ```js\n * // Broadcast div a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(2);\n *\n * a.floorDiv(b).print();  // or tf.floorDiv(a, b)\n * ```\n *\n * @param a The first tensor as the numerator.\n * @param b The second tensor as the denominator. Must have the same dtype as\n * `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Arithmetic'} */\nfunction floorDiv_(a, b) {\n    let $a = convertToTensor(a, 'a', 'floorDiv');\n    let $b = convertToTensor(b, 'b', 'floorDiv');\n    [$a, $b] = makeTypesMatch($a, $b);\n    const forward = (backend, save) => {\n        const res = backend.floorDiv($a, $b);\n        save([$a, $b]);\n        return res;\n    };\n    const inputs = { a: $a, b: $b };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, FloorDiv);\n}\nexport const floorDiv = op({ floorDiv_ });\n//# sourceMappingURL=floorDiv.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Div } from '../kernel_names';\nimport { makeTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { floorDiv } from './floorDiv';\nimport { op } from './operation';\n/**\n * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 9, 16]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.div(b).print();  // or tf.div(a, b)\n * ```\n *\n * ```js\n * // Broadcast div a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(2);\n *\n * a.div(b).print();  // or tf.div(a, b)\n * ```\n *\n * @param a The first tensor as the numerator.\n * @param b The second tensor as the denominator. Must have the same dtype as\n * `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Arithmetic'} */\nfunction div_(a, b) {\n    let $a = convertToTensor(a, 'a', 'div');\n    let $b = convertToTensor(b, 'b', 'div');\n    [$a, $b] = makeTypesMatch($a, $b);\n    if ($a.dtype === 'int32' && $b.dtype === 'int32') {\n        return floorDiv($a, $b);\n    }\n    const forward = (backend, save) => {\n        const res = backend.realDivide($a, $b);\n        save([$a, $b]);\n        return res;\n    };\n    const inputs = { a: $a, b: $b };\n    const attrs = {};\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Div, attrs);\n}\nexport const div = op({ div_ });\n//# sourceMappingURL=div.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Multiply } from '../kernel_names';\nimport { makeTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Multiplies two `tf.Tensor`s element-wise, A * B. Supports broadcasting.\n *\n * We also expose `tf.mulStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3, 4]);\n * const b = tf.tensor1d([2, 3, 4, 5]);\n *\n * a.mul(b).print();  // or tf.mul(a, b)\n * ```\n *\n * ```js\n * // Broadcast mul a with b.\n * const a = tf.tensor1d([1, 2, 3, 4]);\n * const b = tf.scalar(5);\n *\n * a.mul(b).print();  // or tf.mul(a, b)\n * ```\n * @param a The first tensor to multiply.\n * @param b The second tensor to multiply. Must have the same dtype as `a`.\n */\n/** @doc {heading: 'Operations', subheading: 'Arithmetic'} */\nfunction mul_(a, b) {\n    let $a = convertToTensor(a, 'a', 'mul');\n    let $b = convertToTensor(b, 'b', 'mul');\n    [$a, $b] = makeTypesMatch($a, $b);\n    const forward = (backend, save) => {\n        const res = backend.multiply($a, $b);\n        save([$a, $b]);\n        return res;\n    };\n    const inputs = { a: $a, b: $b };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Multiply);\n}\nexport const mul = op({ mul_ });\n//# sourceMappingURL=mul.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {\n    // `computerConv2DInfo` require filterShape to be in the dimension of:\n    // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n    // outDepth, it should have the same depth as the input.\n    // Input shape: [batch, height, width, inChannels]\n    const inputChannels = inputShape[3];\n    const $filterShape = [...filterShape, inputChannels];\n    const $dataFormat = convertConv2DDataFormat(dataFormat);\n    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {\n    const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n    let filterShape;\n    if (dataFormat === 'channelsLast') {\n        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n    }\n    else if (dataFormat === 'channelsFirst') {\n        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {\n    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n    let filterShape;\n    let $dataFormat;\n    if (dataFormat === 'NDHWC') {\n        $dataFormat = 'channelsLast';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n    }\n    else if (dataFormat === 'NCDHW') {\n        $dataFormat = 'channelsFirst';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {\n    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideHeight, strideWidth] = parseTupleParam(strides);\n    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inHeight,\n        inWidth,\n        inChannels,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideHeight,\n        strideWidth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {\n    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inDepth,\n        inHeight,\n        inWidth,\n        inChannels,\n        outDepth,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideDepth,\n        strideHeight,\n        strideWidth,\n        filterDepth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterDepth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationDepth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputRows = inShape[0];\n    const inputCols = inShape[1];\n    const outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    util.assert(util.isInt(outputRows), () => `The output # of rows (${outputRows}) must be an integer. ` +\n        `Change the stride and/or zero pad parameters`);\n    const outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    util.assert(util.isInt(outputCols), () => `The output # of columns (${outputCols}) must be an integer. ` +\n        `Change the stride and/or zero pad parameters`);\n    return [outputRows, outputCols];\n}\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputDepth = inShape[0];\n    const inputRows = inShape[1];\n    const inputCols = inShape[2];\n    const outputDepths = conditionalRound((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    util.assert(util.isInt(outputDepths), () => `The output # of depths (${outputDepths}) must be an integer. ` +\n        `Change the stride and/or zero pad parameters`);\n    const outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    util.assert(util.isInt(outputRows), () => `The output # of rows (${outputRows}) must be an integer. ` +\n        `Change the stride and/or zero pad parameters`);\n    const outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    util.assert(util.isInt(outputCols), () => `The output # of columns (${outputCols}) must be an integer. ` +\n        `Change the stride and/or zero pad parameters`);\n    return [outputDepths, outputRows, outputCols, outChannels];\n}\nexport function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {\n    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\nfunction parseTupleParam(param) {\n    if (typeof param === 'number') {\n        return [param, param, param];\n    }\n    if (param.length === 2) {\n        return [param[0], param[1], 1];\n    }\n    return param;\n}\nfunction parse3TupleParam(param) {\n    return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize, dilation) {\n    if (dilation <= 1) {\n        return filterSize;\n    }\n    return filterSize + (filterSize - 1) * (dilation - 1);\n}\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n    let padInfo;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };\n        const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n        outHeight = outShape[0];\n        outWidth = outShape[1];\n    }\n    else if (pad === 'same') {\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else if (typeof pad === 'object') {\n        const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n        const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n        const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n        const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n        const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n            'VALID' :\n            'EXPLICIT';\n        padInfo = { top, bottom, left, right, type: padType };\n        outHeight = conditionalRound((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n        outWidth = conditionalRound((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outHeight, outWidth };\n}\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n    let padInfo;\n    let outDepth;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = {\n            top: pad,\n            bottom: pad,\n            left: pad,\n            right: pad,\n            front: pad,\n            back: pad,\n            type: padType\n        };\n        const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n        outDepth = outShape[0];\n        outHeight = outShape[1];\n        outWidth = outShape[2];\n    }\n    else if (pad === 'same') {\n        outDepth = Math.ceil(inDepth / strideDepth);\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n        const front = Math.floor(padAlongDepth / 2);\n        const back = padAlongDepth - front;\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, front, back, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            front: 0,\n            back: 0,\n            type: 'VALID'\n        };\n        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outDepth, outHeight, outWidth };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode\n */\nfunction conditionalRound(value, roundingMode) {\n    if (!roundingMode) {\n        return value;\n    }\n    switch (roundingMode) {\n        case 'round':\n            // used for Caffe Conv\n            return Math.round(value);\n        case 'ceil':\n            // used for Caffe Pool\n            return Math.ceil(value);\n        case 'floor':\n            return Math.floor(value);\n        default:\n            throw new Error(`Unknown roundingMode ${roundingMode}`);\n    }\n}\nexport function tupleValuesAreOne(param) {\n    const [dimA, dimB, dimC] = parseTupleParam(param);\n    return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat) {\n    if (dataFormat === 'NHWC') {\n        return 'channelsLast';\n    }\n    else if (dataFormat === 'NCHW') {\n        return 'channelsFirst';\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n}\n//# sourceMappingURL=conv_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsConsistent(shapes, axis) {\n    const rank = shapes[0].length;\n    shapes.forEach((shape, i) => {\n        util.assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same ` +\n            `as the rank of the rest (${rank})`);\n    });\n    util.assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);\n    const firstShape = shapes[0];\n    shapes.forEach((shape, i) => {\n        for (let r = 0; r < rank; r++) {\n            util.assert((r === axis) || (shape[r] === firstShape[r]), () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` +\n                `does not match the shape of the rest (${firstShape}) ` +\n                `along the non-concatenated axis ${i}.`);\n        }\n    });\n}\nexport function computeOutShape(shapes, axis) {\n    const outputShape = shapes[0].slice();\n    for (let i = 1; i < shapes.length; i++) {\n        outputShape[axis] += shapes[i][axis];\n    }\n    return outputShape;\n}\n//# sourceMappingURL=concat_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Slice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport * as slice_util from './slice_util';\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n */\n/** @doc {heading: 'Tensors', subheading: 'Slicing and Joining'} */\nfunction slice_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice');\n    if ($x.rank === 0) {\n        throw new Error('Slicing scalar is not possible');\n    }\n    const [begin_, size_] = slice_util.parseSliceParams($x, begin, size);\n    slice_util.assertParamsValid($x, begin_, size_);\n    const forward = (backend, save) => {\n        save([$x]);\n        return backend.slice($x, begin_, size_);\n    };\n    const inputs = { x: $x };\n    const attrs = { begin, size };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Slice, attrs);\n}\nexport const slice = op({ slice_ });\n//# sourceMappingURL=slice.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    util.assert(input.rank === begin.length, () => `Error in slice${input.rank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${input.rank}).`);\n    util.assert(input.rank === size.length, () => `Error in slice${input.rank}D: Length of size ${size} must ` +\n        `match the rank of the array (${input.rank}).`);\n    for (let i = 0; i < input.rank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${input.rank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(x.rank - 1).fill(0)];\n    }\n    else if (begin.length < x.rank) {\n        begin_ = begin.concat(new Array(x.rank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(x.rank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(x.rank - 1).fill(-1)];\n    }\n    else if (size.length < x.rank) {\n        size_ = size.concat(new Array(x.rank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\n//# sourceMappingURL=slice_util.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer } from '../tensor';\nimport * as util from '../util';\n/**\n * Creates an empty `tf.TensorBuffer` with the specified `shape` and `dtype`.\n *\n * The values are stored in CPU as `TypedArray`. Fill the buffer using\n * `buffer.set()`, or by modifying directly `buffer.values`.\n *\n * When done, call `buffer.toTensor()` to get an immutable `tf.Tensor` with\n * those values.\n *\n * ```js\n * // Create a buffer and set values at particular indices.\n * const buffer = tf.buffer([2, 2]);\n * buffer.set(3, 0, 0);\n * buffer.set(5, 1, 0);\n *\n * // Convert the buffer back to a tensor.\n * buffer.toTensor().print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The dtype of the buffer. Defaults to 'float32'.\n * @param values The values of the buffer as `TypedArray`. Defaults to\n * zeros.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function buffer(shape, dtype = 'float32', values) {\n    dtype = dtype || 'float32';\n    util.assertNonNegativeIntegerDimensions(shape);\n    return new TensorBuffer(shape, dtype, values);\n}\n//# sourceMappingURL=buffer.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Returns the dimensions in the input shape that are broadcasted to\n * produce the provided output shape.\n *\n * The returned dimensions are 0-indexed and sorted. An example:\n * inShape = [4, 1, 3]\n * outShape = [5, 4, 3, 3]\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\n */\nexport function getBroadcastDims(inShape, outShape) {\n    const inRank = inShape.length;\n    const dims = [];\n    for (let i = 0; i < inRank; i++) {\n        const dim = inRank - 1 - i;\n        const a = inShape[dim] || 1;\n        const b = outShape[outShape.length - 1 - i] || 1;\n        if (b > 1 && a === 1) {\n            dims.unshift(dim);\n        }\n    }\n    return dims;\n}\n/**\n * Returns the axes in the output space that should be reduced to produce\n * the input space.\n */\nexport function getReductionAxes(inShape, outShape) {\n    const result = [];\n    for (let i = 0; i < outShape.length; i++) {\n        const inDim = inShape[inShape.length - i - 1];\n        const outAxis = outShape.length - i - 1;\n        const outDim = outShape[outAxis];\n        if (inDim == null || (inDim === 1 && outDim > 1)) {\n            result.unshift(outAxis);\n        }\n    }\n    return result;\n}\nexport function assertAndGetBroadcastShape(shapeA, shapeB) {\n    const result = [];\n    const l = Math.max(shapeA.length, shapeB.length);\n    for (let i = 0; i < l; i++) {\n        let a = shapeA[shapeA.length - i - 1];\n        if (a == null) {\n            a = 1;\n        }\n        let b = shapeB[shapeB.length - i - 1];\n        if (b == null) {\n            b = 1;\n        }\n        if (a === 1) {\n            result.unshift(b);\n        }\n        else if (b === 1) {\n            result.unshift(a);\n        }\n        else if (a !== b) {\n            const errMsg = `Operands could not be broadcast together with shapes ` +\n                `${shapeA} and ${shapeB}.`;\n            throw Error(errMsg);\n        }\n        else {\n            result.unshift(a);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=broadcast_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Elu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes exponential linear element-wise: `x > 0 ? e ^ x - 1 : 0`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 1, -3, 2]);\n *\n * x.elu().print();  // or tf.elu(x)\n * ```\n * @param x The input tensor.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction elu_(x) {\n    const $x = convertToTensor(x, 'x', 'elu');\n    const forward = (backend, save) => {\n        const y = backend.elu($x);\n        save([y]);\n        return y;\n    };\n    const inputs = { x: $x };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Elu);\n}\nexport const elu = op({ elu_ });\n//# sourceMappingURL=elu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Inputs of size above this threshold will be parallelized by calling multiple\n * shader programs.\n */\nimport { nearestDivisor } from '../util';\nexport const PARALLELIZE_THRESHOLD = 30;\nexport function computeOptimalWindowSize(inSize) {\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        return inSize;\n    }\n    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n}\n//# sourceMappingURL=reduce_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n    let done = false;\n    let res;\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n        }\n        else {\n            res = nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis) {\n    const dimSize = x.shape[axis];\n    const outputShape = [];\n    let batchSize = 1;\n    let sliceSize = 1;\n    for (let i = 0; i < axis; i++) {\n        outputShape.push(x.shape[i]);\n        batchSize *= x.shape[i];\n    }\n    for (let i = 0; i < indices.rank; i++) {\n        outputShape.push(indices.shape[i]);\n    }\n    for (let i = axis + 1; i < x.rank; i++) {\n        outputShape.push(x.shape[i]);\n        sliceSize *= x.shape[i];\n    }\n    return { batchSize, sliceSize, dimSize, outputShape };\n}\n//# sourceMappingURL=segment_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Imag } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Returns the imaginary part of a complex (or real) tensor.\n *\n * Given a tensor input, this operation returns a tensor of type float that is\n * the imaginary part of each element in input considered as a complex number.\n * If input is real, a tensor of all zeros is returned.\n *\n * ```js\n * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\n * tf.imag(x).print();\n * ```\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction imag_(input) {\n    const $input = convertToTensor(input, 'input', 'imag');\n    const forward = (backend) => {\n        return backend.imag($input);\n    };\n    const inputs = { input: $input };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Imag);\n}\nexport const imag = op({ imag_ });\n//# sourceMappingURL=imag.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Real } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Returns the real part of a complex (or real) tensor.\n *\n * Given a tensor input, this operation returns a tensor of type float that is\n * the real part of each element in input considered as a complex number.\n *\n * If the input is real, it simply makes a clone.\n *\n * ```js\n * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\n * tf.real(x).print();\n * ```\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nfunction real_(input) {\n    const $input = convertToTensor(input, 'input', 'real');\n    const forward = (backend) => {\n        return backend.real($input);\n    };\n    const inputs = { input: $input };\n    return ENGINE.runKernelFunc(forward, inputs, null /* gradient */, Real);\n}\nexport const real = op({ real_ });\n//# sourceMappingURL=real.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isTypedArray } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function scalar(value, dtype) {\n    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n        dtype !== 'complex64') {\n        throw new Error('Error creating a new Scalar: value must be a primitive ' +\n            '(number|boolean|string)');\n    }\n    if (dtype === 'string' && isTypedArray(value) &&\n        !(value instanceof Uint8Array)) {\n        throw new Error('When making a scalar from encoded string, ' +\n            'the value must be `Uint8Array`.');\n    }\n    const shape = [];\n    const inferredShape = [];\n    return makeTensor(value, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=scalar.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sum } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam } from '../util';\nimport { expandShapeToKeepDim, getAxesPermutation, getInnerMostAxes } from './axis_util';\nimport { cast } from './cast';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { transpose } from './transpose';\n/**\n * Computes the sum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If axes has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.sum().print();  // or tf.sum(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.sum(axis).print();  // or tf.sum(x, axis)\n * ```\n *\n * @param x The input tensor to compute the sum over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n */\n/** @doc {heading: 'Operations', subheading: 'Reduction'} */\nfunction sum_(x, axis = null, keepDims = false) {\n    let $x = convertToTensor(x, 'x', 'sum');\n    if ($x.dtype === 'bool') {\n        $x = cast($x, 'int32');\n    }\n    const forward = (backend, save) => {\n        save([$x]);\n        const axes = parseAxisParam(axis, $x.shape);\n        const permutation = getAxesPermutation(axes, $x.rank);\n        let reductionAxes = axes;\n        let permutedX = $x;\n        if (permutation != null) {\n            permutedX = transpose($x, permutation);\n            reductionAxes = getInnerMostAxes(reductionAxes.length, $x.rank);\n        }\n        let value = backend.sum(permutedX, reductionAxes);\n        if (keepDims) {\n            const newShape = expandShapeToKeepDim(value.shape, axes);\n            value = reshape(value, newShape);\n        }\n        return value;\n    };\n    const inputs = { x: $x };\n    const attrs = { axis, keepDims };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Sum, attrs);\n}\nexport const sum = op({ sum_ });\n//# sourceMappingURL=sum.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { makeZerosTypedArray, sizeFromShape } from '../util';\nimport { complex } from './complex';\n/**\n * Creates a `tf.Tensor` with all elements set to 0.\n *\n * ```js\n * tf.zeros([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Can\n *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function zeros(shape, dtype = 'float32') {\n    if (dtype === 'complex64') {\n        const real = zeros(shape, 'float32');\n        const imag = zeros(shape, 'float32');\n        return complex(real, imag);\n    }\n    const values = makeZerosTypedArray(sizeFromShape(shape), dtype);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n//# sourceMappingURL=zeros.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Prelu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes leaky rectified linear element-wise with parametric alphas.\n *\n * `x < 0 ? alpha * x : f(x) = x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n * const alpha = tf.scalar(0.1);\n *\n * x.prelu(alpha).print();  // or tf.prelu(x, alpha)\n * ```\n * @param x The input tensor.\n * @param alpha Scaling factor for negative values.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction prelu_(x, alpha) {\n    const $x = convertToTensor(x, 'x', 'prelu');\n    const $alpha = convertToTensor(alpha, 'alpha', 'prelu');\n    const forward = (backend, save) => {\n        const res = backend.prelu($x, $alpha);\n        save([$x, $alpha]);\n        return res;\n    };\n    const inputs = { x: $x, alpha: $alpha };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Prelu);\n}\nexport const prelu = op({ prelu_ });\n//# sourceMappingURL=prelu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function tensor1d(values, dtype) {\n    assertNonNull(values);\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 1) {\n        throw new Error('tensor1d() requires values to be a flat/TypedArray');\n    }\n    const shape = null;\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor1d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Relu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport { cast } from './cast';\n/**\n * Computes rectified linear element-wise: `max(x, 0)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.relu().print();  // or tf.relu(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction relu_(x) {\n    const $x = convertToTensor(x, 'x', 'relu');\n    const forward = (backend, save) => {\n        save([$x]);\n        if ($x.dtype === 'bool') {\n            return cast($x, 'int32');\n        }\n        return backend.relu($x);\n    };\n    const inputs = { x: $x };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Relu);\n}\nexport const relu = op({ relu_ });\n//# sourceMappingURL=relu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Relu6 } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { cast } from './cast';\nimport { op } from './operation';\n/**\n * Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 8]);\n *\n * x.relu6().print();  // or tf.relu6(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction relu6_(x) {\n    const $x = convertToTensor(x, 'x', 'relu6');\n    const forward = (backend, save) => {\n        save([$x]);\n        if ($x.dtype === 'bool') {\n            return cast($x, 'int32');\n        }\n        return backend.relu6($x);\n    };\n    const inputs = { x: $x };\n    return ENGINE.runKernelFunc(forward, inputs, null /* grad */, Relu6);\n}\nexport const relu6 = op({ relu6_ });\n//# sourceMappingURL=relu6.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Softmax } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes the softmax normalized vector given the logits.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * ```js\n * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * @param logits The logits array.\n * @param dim The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n */\n/** @doc {heading: 'Operations', subheading: 'Normalization'} */\nfunction softmax_(logits, dim = -1) {\n    const $logits = convertToTensor(logits, 'logits', 'softmax', 'float32');\n    if (dim === -1) {\n        dim = $logits.rank - 1;\n    }\n    if (dim !== $logits.rank - 1) {\n        throw Error('Softmax along a non-last dimension is not yet supported. ' +\n            `Logits was rank ${$logits.rank} and dim was ${dim}`);\n    }\n    const inputs = { logits: $logits };\n    const attrs = { dim };\n    return ENGINE.runKernelFunc((backend, save) => {\n        const y = backend.softmax($logits, dim);\n        save([y]);\n        return y;\n    }, inputs, null /* grad */, Softmax, attrs);\n}\nexport const softmax = op({ softmax_ });\n//# sourceMappingURL=softmax.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Step } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes step of the input `tf.Tensor` element-wise: `x > 0 ? 1 : alpha * x`\n *\n * ```js\n * const x = tf.tensor1d([0, 2, -1, -3]);\n *\n * x.step(.5).print();  // or tf.step(x, .5)\n * ```\n * @param x The input tensor.\n * @param alpha The gradient when input is negative.\n */\n/** @doc {heading: 'Operations', subheading: 'Basic math'} */\nfunction step_(x, alpha = 0.0) {\n    const $x = convertToTensor(x, 'x', 'step');\n    const inputs = { x: $x };\n    const attrs = { alpha };\n    return ENGINE.runKernelFunc(backend => backend.step($x, alpha), inputs, null /* grad */, Step, attrs);\n}\nexport const step = op({ step_ });\n//# sourceMappingURL=step.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(inputShape, blockShape, prod, batchToSpace = true) {\n    let reshaped = [];\n    if (batchToSpace) {\n        reshaped = reshaped.concat(blockShape.slice(0));\n        reshaped.push(inputShape[0] / prod);\n        reshaped = reshaped.concat(inputShape.slice(1));\n    }\n    else {\n        reshaped = reshaped.concat(inputShape[0]);\n        const spatialLength = blockShape.length;\n        for (let i = 0; i < spatialLength; ++i) {\n            reshaped =\n                reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n        }\n        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n    }\n    return reshaped;\n}\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {\n    const permuted = [];\n    if (batchToSpace) {\n        permuted.push(blockShapeRank);\n        for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n            if (i <= 2 * blockShapeRank) {\n                permuted.push(i);\n                permuted.push(i - (blockShapeRank + 1));\n            }\n            else {\n                permuted.push(i);\n            }\n        }\n    }\n    else {\n        const permutedBeforeBatch = [];\n        const permutedAfterBatch = [];\n        for (let i = 1; i < reshapedRank; ++i) {\n            if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n                permutedAfterBatch.push(i);\n            }\n            else {\n                permutedBeforeBatch.push(i);\n            }\n        }\n        permuted.push(...permutedBeforeBatch);\n        permuted.push(0);\n        permuted.push(...permutedAfterBatch);\n    }\n    return permuted;\n}\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshapedPermuted(inputShape, blockShape, prod, batchToSpace = true) {\n    const reshapedPermuted = [];\n    if (batchToSpace) {\n        reshapedPermuted.push(inputShape[0] / prod);\n    }\n    else {\n        reshapedPermuted.push(inputShape[0] * prod);\n    }\n    for (let i = 1; i < inputShape.length; ++i) {\n        if (i <= blockShape.length) {\n            if (batchToSpace) {\n                reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n            }\n            else {\n                reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n            }\n        }\n        else {\n            reshapedPermuted.push(inputShape[i]);\n        }\n    }\n    return reshapedPermuted;\n}\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\nexport function getSliceBeginCoords(crops, blockShape) {\n    const sliceBeginCoords = [0];\n    for (let i = 0; i < blockShape; ++i) {\n        sliceBeginCoords.push(crops[i][0]);\n    }\n    return sliceBeginCoords;\n}\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getSliceSize(uncroppedShape, crops, blockShape) {\n    const sliceSize = uncroppedShape.slice(0, 1);\n    for (let i = 0; i < blockShape; ++i) {\n        sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n    }\n    return sliceSize;\n}\n//# sourceMappingURL=array_ops_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from './environment';\nexport function warn(...msg) {\n    if (!env().getBool('IS_TEST')) {\n        console.warn(...msg);\n    }\n}\nexport function log(...msg) {\n    if (!env().getBool('IS_TEST')) {\n        console.log(...msg);\n    }\n}\n//# sourceMappingURL=log.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n    if (real.length !== imag.length) {\n        throw new Error(`Cannot merge real and imag arrays of different lengths. real:` +\n            `${real.length}, imag: ${imag.length}.`);\n    }\n    const result = new Float32Array(real.length * 2);\n    for (let i = 0; i < result.length; i += 2) {\n        result[i] = real[i / 2];\n        result[i + 1] = imag[i / 2];\n    }\n    return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n    const real = new Float32Array(complex.length / 2);\n    const imag = new Float32Array(complex.length / 2);\n    for (let i = 0; i < complex.length; i += 2) {\n        real[i / 2] = complex[i];\n        imag[i / 2] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n    const len = Math.ceil(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 0; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n    const len = Math.floor(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 2; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n    const real = complex[index * 2];\n    const imag = complex[index * 2 + 1];\n    return { real, imag };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n    data[index * 2] = real;\n    data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n    const real = new Float32Array(n / 2);\n    const imag = new Float32Array(n / 2);\n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n        const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n        real[i] = Math.cos(x);\n        imag[i] = Math.sin(x);\n    }\n    return { real, imag };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n    const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n    const real = Math.cos(x);\n    const imag = Math.sin(x);\n    return { real, imag };\n}\n//# sourceMappingURL=complex_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { tensor1d } from '../ops/tensor1d';\nimport { zeros } from '../ops/zeros';\nimport { hasEncodingLoss, makeZerosTypedArray } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return x.clone();\n        }\n        const zerosTensor = zeros(x.shape);\n        const floatX = cast(x, 'float32');\n        const result = backend.complex(floatX, zerosTensor);\n        zerosTensor.dispose();\n        floatX.dispose();\n        return result;\n    }\n    if (!hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n    }\n    if (x.dtype === 'complex64') {\n        const real = backend.real(x);\n        const result = cast(real, dtype);\n        real.dispose();\n        return result;\n    }\n    if (dtype === 'int32') {\n        return backend.int(x);\n    }\n    else if (dtype === 'bool') {\n        const zero = scalar(0, x.dtype);\n        const result = backend.notEqual(x, zero);\n        zero.dispose();\n        return result;\n    }\n    else {\n        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n    }\n}\nexport function reshapeTensor(x, shape) {\n    return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function linspaceImpl(start, stop, num) {\n    const step = (stop - start) / (num - 1);\n    const values = makeZerosTypedArray(num, 'float32');\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return tensor1d(values, 'float32');\n}\n//# sourceMappingURL=backend_util.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as broadcast_util from './broadcast_util';\nimport { elu } from './elu';\nimport { mul } from './mul';\nimport { prelu } from './prelu';\nimport { relu } from './relu';\nimport { relu6 } from './relu6';\nimport { reshape } from './reshape';\nimport { step } from './step';\nimport { sum } from './sum';\n// Returns gradient for fused activation.\nexport function getFusedDyActivation(dy, y, activation) {\n    if (activation == null || activation === 'linear') {\n        return dy;\n    }\n    if (activation === 'relu') {\n        return mul(dy, step(y));\n    }\n    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);\n}\n// Returns gradient for fused bias.\nexport function getFusedBiasGradient(bias, dyActivation) {\n    let res = dyActivation;\n    const reduceAxes = broadcast_util.getReductionAxes(bias.shape, dyActivation.shape);\n    if (reduceAxes.length > 0) {\n        res = sum(res, reduceAxes);\n    }\n    return reshape(res, bias.shape);\n}\nexport function applyActivation(x, activation, preluActivationWeights) {\n    if (activation === 'linear') {\n        return x;\n    }\n    else if (activation === 'relu') {\n        return relu(x);\n    }\n    else if (activation === 'elu') {\n        return elu(x);\n    }\n    else if (activation === 'relu6') {\n        return relu6(x);\n    }\n    else if (activation === 'prelu') {\n        return prelu(x, preluActivationWeights);\n    }\n    throw new Error(`Unknown fused activation ${activation}.`);\n}\n// Whether we should call fused ops.\nexport const shouldFuse = (gradientDepth, activation) => {\n    const gradientMode = gradientDepth > 0;\n    return !gradientMode || activation === 'linear';\n};\n//# sourceMappingURL=fused_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Returns the image center in pixels.\nexport function getImageCenter(center, imageHeight, imageWidth) {\n    const centerX = imageWidth * (typeof center === 'number' ? center : center[0]);\n    const centerY = imageHeight * (typeof center === 'number' ? center : center[1]);\n    return [centerX, centerY];\n}\n//# sourceMappingURL=rotate_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const SELU_SCALEALPHA = 1.7580993408473768599402175208123;\nexport const SELU_SCALE = 1.0507009873554804934193349852946;\n//# sourceMappingURL=selu_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const ERF_P = 0.3275911;\nexport const ERF_A1 = 0.254829592;\nexport const ERF_A2 = -0.284496736;\nexport const ERF_A3 = 1.421413741;\nexport const ERF_A4 = -1.453152027;\nexport const ERF_A5 = 1.061405429;\n//# sourceMappingURL=erf_util.js.map","import { assert } from '../util';\n/**\n * Prepare the split size array. When the input is a number, the axis is evenly\n * divided among the split size. When the input contains the negative value, the\n * rest of the axis is allocated toward that.\n */\nexport function prepareSplitSize(x, numOrSizeSplits, axis = 0) {\n    let splitSizes = [];\n    if (typeof (numOrSizeSplits) === 'number') {\n        assert(x.shape[axis] % numOrSizeSplits === 0, () => 'Number of splits must evenly divide the axis.');\n        splitSizes =\n            new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);\n    }\n    else {\n        const numOfNegs = numOrSizeSplits.reduce((count, value) => {\n            if (value === -1) {\n                count += 1;\n            }\n            return count;\n        }, 0);\n        assert(numOfNegs <= 1, () => 'There should be only one negative value in split array.');\n        const negIndex = numOrSizeSplits.indexOf(-1);\n        // Allow the number of split array to be -1, which indicates the rest\n        // of dimension is allocated to that split.\n        if (negIndex !== -1) {\n            const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);\n            numOrSizeSplits[negIndex] = x.shape[axis] - total;\n        }\n        assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => 'The sum of sizes must match the size of the axis dimension.');\n        splitSizes = numOrSizeSplits;\n    }\n    return splitSizes;\n}\n//# sourceMappingURL=split_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line:no-any\nfunction _isNavigatorDefined() {\n    return typeof navigator !== 'undefined' && navigator != null;\n}\nexport function isMobile() {\n    if (_isNavigatorDefined()) {\n        // tslint:disable-next-line:no-any\n        const a = navigator.userAgent || navigator.vendor || window.opera;\n        // tslint:disable-next-line:max-line-length\n        return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i\n            .test(a) ||\n            // tslint:disable-next-line:max-line-length\n            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i\n                .test(a.substr(0, 4));\n    }\n    return false;\n}\nexport function isBrowser() {\n    return (typeof window !== 'undefined' && window.document != null) ||\n        //@ts-ignore\n        (typeof WorkerGlobalScope !== 'undefined');\n}\n//# sourceMappingURL=device_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage {\n    constructor(backend, dataMover) {\n        this.backend = backend;\n        this.dataMover = dataMover;\n        this.data = new WeakMap();\n        this.dataIdsCount = 0;\n    }\n    get(dataId) {\n        if (!this.data.has(dataId)) {\n            this.dataMover.moveData(this.backend, dataId);\n        }\n        return this.data.get(dataId);\n    }\n    set(dataId, value) {\n        this.dataIdsCount++;\n        this.data.set(dataId, value);\n    }\n    has(dataId) {\n        return this.data.has(dataId);\n    }\n    delete(dataId) {\n        this.dataIdsCount--;\n        return this.data.delete(dataId);\n    }\n    numDataIds() {\n        return this.dataIdsCount;\n    }\n}\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend {\n    time(f) {\n        return notYetImplemented('time');\n    }\n    read(dataId) {\n        return notYetImplemented('read');\n    }\n    readSync(dataId) {\n        return notYetImplemented('readSync');\n    }\n    numDataIds() {\n        return notYetImplemented('numDataIds');\n    }\n    disposeData(dataId) {\n        return notYetImplemented('disposeData');\n    }\n    write(values, shape, dtype) {\n        return notYetImplemented('write');\n    }\n    move(dataId, values, shape, dtype) {\n        return notYetImplemented('move');\n    }\n    memory() {\n        return notYetImplemented('memory');\n    }\n    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n    floatPrecision() {\n        return notYetImplemented('floatPrecision');\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    batchMatMul(a, b, transposeA, transposeB) {\n        return notYetImplemented('batchMatMul');\n    }\n    fusedBatchMatMul({ a, b, transposeA, transposeB, bias, activation, preluActivationWeights }) {\n        return notYetImplemented('fusedBatchMatMul');\n    }\n    slice(x, begin, size) {\n        return notYetImplemented('slice');\n    }\n    stridedSlice(x, begin, end, strides) {\n        return notYetImplemented('stridedSlice');\n    }\n    unstack(x, axis) {\n        return notYetImplemented('unstack');\n    }\n    reverse(a, axis) {\n        return notYetImplemented('reverse');\n    }\n    concat(tensors, axis) {\n        return notYetImplemented('concat');\n    }\n    neg(a) {\n        return notYetImplemented('neg');\n    }\n    add(a, b) {\n        return notYetImplemented('add');\n    }\n    addN(tensors) {\n        return notYetImplemented('addN');\n    }\n    subtract(a, b) {\n        return notYetImplemented('subtract');\n    }\n    multiply(a, b) {\n        return notYetImplemented('multiply');\n    }\n    realDivide(a, b) {\n        return notYetImplemented('realDivide');\n    }\n    floorDiv(a, b) {\n        return notYetImplemented('floorDiv');\n    }\n    sum(x, axes) {\n        return notYetImplemented('sum');\n    }\n    prod(x, axes) {\n        return notYetImplemented('prod');\n    }\n    unsortedSegmentSum(x, segmentIds, numSegments) {\n        return notYetImplemented('unsortedSegmentSum');\n    }\n    argMin(x, axis) {\n        return notYetImplemented('argMin');\n    }\n    argMax(x, axis) {\n        return notYetImplemented('argMax');\n    }\n    equal(a, b) {\n        return notYetImplemented('equal');\n    }\n    notEqual(a, b) {\n        return notYetImplemented('notEqual');\n    }\n    less(a, b) {\n        return notYetImplemented('less');\n    }\n    lessEqual(a, b) {\n        return notYetImplemented('lessEqual');\n    }\n    greater(a, b) {\n        return notYetImplemented('greater');\n    }\n    greaterEqual(a, b) {\n        return notYetImplemented('greaterEqual');\n    }\n    logicalNot(a) {\n        return notYetImplemented('logicalNot');\n    }\n    logicalAnd(a, b) {\n        return notYetImplemented('logicalAnd');\n    }\n    logicalOr(a, b) {\n        return notYetImplemented('logicalOr');\n    }\n    where(condition) {\n        return notYetImplemented('where');\n    }\n    select(condition, a, b) {\n        return notYetImplemented('select');\n    }\n    topk(x, k, sorted) {\n        return notYetImplemented('topk');\n    }\n    min(x, axes) {\n        return notYetImplemented('min');\n    }\n    minimum(a, b) {\n        return notYetImplemented('minimum');\n    }\n    mod(a, b) {\n        return notYetImplemented('mod');\n    }\n    max(x, axes) {\n        return notYetImplemented('max');\n    }\n    maximum(a, b) {\n        return notYetImplemented('maximum');\n    }\n    all(x, axes) {\n        return notYetImplemented('all');\n    }\n    any(x, axes) {\n        return notYetImplemented('any');\n    }\n    squaredDifference(a, b) {\n        return notYetImplemented('squaredDifference');\n    }\n    ceil(x) {\n        return notYetImplemented('ceil');\n    }\n    floor(x) {\n        return notYetImplemented('floor');\n    }\n    round(x) {\n        return notYetImplemented('round');\n    }\n    sign(x) {\n        return notYetImplemented('sign');\n    }\n    isNaN(x) {\n        return notYetImplemented('isNaN');\n    }\n    isInf(x) {\n        return notYetImplemented('isInf');\n    }\n    isFinite(x) {\n        return notYetImplemented('isFinite');\n    }\n    pow(a, b) {\n        return notYetImplemented('pow');\n    }\n    exp(x) {\n        return notYetImplemented('exp');\n    }\n    expm1(x) {\n        return notYetImplemented('expm1');\n    }\n    softmax(x, dim) {\n        return notYetImplemented('softmax');\n    }\n    log(x) {\n        return notYetImplemented('log');\n    }\n    log1p(x) {\n        return notYetImplemented('log1p');\n    }\n    sqrt(x) {\n        return notYetImplemented('sqrt');\n    }\n    rsqrt(x) {\n        return notYetImplemented('rsqrt');\n    }\n    square(x) {\n        return notYetImplemented('square');\n    }\n    reciprocal(x) {\n        return notYetImplemented('reciprocal');\n    }\n    relu(x) {\n        return notYetImplemented('relu');\n    }\n    relu6(x) {\n        return notYetImplemented('relu6');\n    }\n    prelu(x, a) {\n        return notYetImplemented('prelu');\n    }\n    elu(x) {\n        return notYetImplemented('elu');\n    }\n    eluDer(dy, y) {\n        return notYetImplemented('eluDer');\n    }\n    selu(x) {\n        return notYetImplemented('selu');\n    }\n    int(x) {\n        return notYetImplemented('int');\n    }\n    clip(x, min, max) {\n        return notYetImplemented('clip');\n    }\n    abs(x) {\n        return notYetImplemented('abs');\n    }\n    complexAbs(x) {\n        return notYetImplemented('complexAbs');\n    }\n    sigmoid(x) {\n        return notYetImplemented('sigmoid');\n    }\n    softplus(x) {\n        return notYetImplemented('softplus');\n    }\n    sin(x) {\n        return notYetImplemented('sin');\n    }\n    cos(x) {\n        return notYetImplemented('cos');\n    }\n    tan(x) {\n        return notYetImplemented('tan');\n    }\n    asin(x) {\n        return notYetImplemented('asin');\n    }\n    acos(x) {\n        return notYetImplemented('acos');\n    }\n    atan(x) {\n        return notYetImplemented('atan');\n    }\n    atan2(a, b) {\n        return notYetImplemented('atan2');\n    }\n    sinh(x) {\n        return notYetImplemented('sinh');\n    }\n    cosh(x) {\n        return notYetImplemented('cosh');\n    }\n    tanh(x) {\n        return notYetImplemented('tanh');\n    }\n    asinh(x) {\n        return notYetImplemented('asinh');\n    }\n    acosh(x) {\n        return notYetImplemented('acosh');\n    }\n    atanh(x) {\n        return notYetImplemented('atanh');\n    }\n    erf(x) {\n        return notYetImplemented('erf');\n    }\n    step(x, alpha) {\n        return notYetImplemented('step');\n    }\n    fusedConv2d({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        return notYetImplemented('fusedConv2d');\n    }\n    conv2d(x, filter, convInfo) {\n        return notYetImplemented('conv2d');\n    }\n    conv2dDerInput(dy, filter, convInfo) {\n        return notYetImplemented('conv2dDerInput');\n    }\n    conv2dDerFilter(x, dY, convInfo) {\n        return notYetImplemented('conv2dDerFilter');\n    }\n    fusedDepthwiseConv2D({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        return notYetImplemented('fusedDepthwiseConv2D');\n    }\n    depthwiseConv2D(input, filter, convInfo) {\n        return notYetImplemented('depthwiseConv2D');\n    }\n    depthwiseConv2DDerInput(dy, filter, convInfo) {\n        return notYetImplemented('depthwiseConv2DDerInput');\n    }\n    depthwiseConv2DDerFilter(x, dY, convInfo) {\n        return notYetImplemented('depthwiseConv2DDerFilter');\n    }\n    conv3d(x, filter, convInfo) {\n        return notYetImplemented('conv3d');\n    }\n    conv3dDerInput(dy, filter, convInfo) {\n        return notYetImplemented('conv3dDerInput');\n    }\n    conv3dDerFilter(x, dY, convInfo) {\n        return notYetImplemented('conv3dDerFilter');\n    }\n    maxPool(x, convInfo) {\n        return notYetImplemented('maxPool');\n    }\n    maxPoolBackprop(dy, x, y, convInfo) {\n        return notYetImplemented('maxPoolBackprop');\n    }\n    avgPool(x, convInfo) {\n        return notYetImplemented('avgPool');\n    }\n    avgPoolBackprop(dy, x, convInfo) {\n        return notYetImplemented('avgPoolBackprop');\n    }\n    avgPool3d(x, convInfo) {\n        return notYetImplemented('avgPool3d');\n    }\n    avgPool3dBackprop(dy, x, convInfo) {\n        return notYetImplemented('avgPool3dBackprop');\n    }\n    maxPool3d(x, convInfo) {\n        return notYetImplemented('maxPool3d');\n    }\n    maxPool3dBackprop(dy, x, y, convInfo) {\n        return notYetImplemented('maxPool3dBackprop');\n    }\n    reshape(x, shape) {\n        return notYetImplemented('reshape');\n    }\n    cast(x, dtype) {\n        return notYetImplemented('cast');\n    }\n    tile(x, reps) {\n        return notYetImplemented('tile');\n    }\n    pad(x, paddings, constantValue) {\n        return notYetImplemented('pad');\n    }\n    transpose(x, perm) {\n        return notYetImplemented('transpose');\n    }\n    gather(x, indices, axis) {\n        return notYetImplemented('gather');\n    }\n    gatherND(x, indices) {\n        return notYetImplemented('gatherND');\n    }\n    scatterND(indices, updates, shape) {\n        return notYetImplemented('scatterND');\n    }\n    batchToSpaceND(x, blockShape, crops) {\n        return notYetImplemented('batchToSpaceND');\n    }\n    spaceToBatchND(x, blockShape, paddings) {\n        return notYetImplemented('spaceToBatchND');\n    }\n    resizeBilinear(x, newHeight, newWidth, alignCorners) {\n        return notYetImplemented('resizeBilinear');\n    }\n    resizeBilinearBackprop(dy, x, alignCorners) {\n        return notYetImplemented('resizeBilinearBackprop');\n    }\n    resizeNearestNeighbor(x, newHEight, newWidth, alignCorners) {\n        return notYetImplemented('resizeNearestNeighbor');\n    }\n    resizeNearestNeighborBackprop(dy, x, alignCorners) {\n        return notYetImplemented('resizeNearestNeighborBackprop');\n    }\n    batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n        return notYetImplemented('batchNorm');\n    }\n    localResponseNormalization4D(x, radius, bias, alpha, beta) {\n        return notYetImplemented('localResponseNormalization4D');\n    }\n    LRNGrad(dy, inputImage, outputImage, radius, bias, alpha, beta) {\n        return notYetImplemented('LRNGrad');\n    }\n    multinomial(logits, normalized, numSamples, seed) {\n        return notYetImplemented('multinomial');\n    }\n    oneHot(indices, depth, onValue, offValue) {\n        return notYetImplemented('oneHot');\n    }\n    cumsum(x, axis, exclusive, reverse) {\n        return notYetImplemented('cumsum');\n    }\n    nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        return notYetImplemented('nonMaxSuppression');\n    }\n    fft(x) {\n        return notYetImplemented('fft');\n    }\n    ifft(x) {\n        return notYetImplemented('ifft');\n    }\n    complex(real, imag) {\n        return notYetImplemented('complex');\n    }\n    real(input) {\n        return notYetImplemented('real');\n    }\n    imag(input) {\n        return notYetImplemented('imag');\n    }\n    cropAndResize(image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        return notYetImplemented('cropAndResize');\n    }\n    depthToSpace(x, blockSize, dataFormat) {\n        return notYetImplemented('depthToSpace');\n    }\n    // Aligns with the \"SplitV\" kernel in TensorFlow.\n    split(value, sizeSplits, axis) {\n        return notYetImplemented('split');\n    }\n    sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n        return notYetImplemented('sparseToDense');\n    }\n    diag(x) {\n        return notYetImplemented('diag');\n    }\n    fill(shape, value, dtype) {\n        return notYetImplemented('fill');\n    }\n    onesLike(x) {\n        return notYetImplemented('onesLike');\n    }\n    zerosLike(x) {\n        return notYetImplemented('zerosLike');\n    }\n    linspace(start, stop, num) {\n        return notYetImplemented('linspace');\n    }\n    dispose() {\n        return notYetImplemented('dispose');\n    }\n}\nfunction notYetImplemented(kernelName) {\n    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` +\n        `Did you forget to import the kernel?`);\n}\n//# sourceMappingURL=backend.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as device_util from './device_util';\nimport { env } from './environment';\nconst ENV = env();\n/**\n * This file contains environment-related flag registrations.\n */\n/** Whether to enable debug mode. */\nENV.registerFlag('DEBUG', () => false, debugValue => {\n    if (debugValue) {\n        console.warn('Debugging mode is ON. The output of every math call will ' +\n            'be downloaded to CPU and checked for NaNs. ' +\n            'This significantly impacts performance.');\n    }\n});\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag('IS_BROWSER', () => device_util.isBrowser());\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag('IS_NODE', () => (typeof process !== 'undefined') &&\n    (typeof process.versions !== 'undefined') &&\n    (typeof process.versions.node !== 'undefined'));\n/** Whether this browser is Chrome. */\nENV.registerFlag('IS_CHROME', () => typeof navigator !== 'undefined' && navigator != null &&\n    navigator.userAgent != null && /Chrome/.test(navigator.userAgent) &&\n    /Google Inc/.test(navigator.vendor));\n/**\n * True when the environment is \"production\" where we disable safety checks\n * to gain performance.\n */\nENV.registerFlag('PROD', () => false);\n/**\n * Whether to do sanity checks when inferring a shape from user-provided\n * values, used when creating a new tensor.\n */\nENV.registerFlag('TENSORLIKE_CHECK_SHAPE_CONSISTENCY', () => ENV.getBool('DEBUG'));\n/** Whether deprecation warnings are enabled. */\nENV.registerFlag('DEPRECATION_WARNINGS_ENABLED', () => true);\n/** True if running unit tests. */\nENV.registerFlag('IS_TEST', () => false);\n//# sourceMappingURL=flags.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '../environment';\nexport class PlatformBrowser {\n    fetch(path, init) {\n        return fetch(path, init);\n    }\n    now() {\n        return performance.now();\n    }\n    encode(text, encoding) {\n        if (encoding !== 'utf-8' && encoding !== 'utf8') {\n            throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);\n        }\n        if (this.textEncoder == null) {\n            this.textEncoder = new TextEncoder();\n        }\n        return this.textEncoder.encode(text);\n    }\n    decode(bytes, encoding) {\n        return new TextDecoder(encoding).decode(bytes);\n    }\n}\nif (env().get('IS_BROWSER')) {\n    env().setPlatform('browser', new PlatformBrowser());\n}\n//# sourceMappingURL=platform_browser.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '../environment';\n// We are wrapping this within an object so it can be stubbed by Jasmine.\nexport const getNodeFetch = {\n    // tslint:disable-next-line:no-require-imports\n    importFetch: () => require('node-fetch')\n};\nlet systemFetch;\n// These getters and setters are for testing so we don't export a mutable\n// variable.\nexport function resetSystemFetch() {\n    systemFetch = null;\n}\nexport function setSystemFetch(fetchFn) {\n    systemFetch = fetchFn;\n}\nexport function getSystemFetch() {\n    return systemFetch;\n}\nexport class PlatformNode {\n    constructor() {\n        // tslint:disable-next-line:no-require-imports\n        this.util = require('util');\n        // According to the spec, the built-in encoder can do only UTF-8 encoding.\n        // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/TextEncoder\n        this.textEncoder = new this.util.TextEncoder();\n    }\n    fetch(path, requestInits) {\n        if (env().global.fetch != null) {\n            return env().global.fetch(path, requestInits);\n        }\n        if (systemFetch == null) {\n            systemFetch = getNodeFetch.importFetch();\n        }\n        return systemFetch(path, requestInits);\n    }\n    now() {\n        const time = process.hrtime();\n        return time[0] * 1000 + time[1] / 1000000;\n    }\n    encode(text, encoding) {\n        if (encoding !== 'utf-8' && encoding !== 'utf8') {\n            throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);\n        }\n        return this.textEncoder.encode(text);\n    }\n    decode(bytes, encoding) {\n        if (bytes.length === 0) {\n            return '';\n        }\n        return new this.util.TextDecoder(encoding).decode(bytes);\n    }\n}\nif (env().get('IS_NODE')) {\n    env().setPlatform('node', new PlatformNode());\n}\n//# sourceMappingURL=platform_node.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/** DataType enum. */\nexport var DataType;\n(function (DataType) {\n    DataType[DataType[\"DT_INVALID\"] = 0] = \"DT_INVALID\";\n    DataType[DataType[\"DT_FLOAT\"] = 1] = \"DT_FLOAT\";\n    DataType[DataType[\"DT_DOUBLE\"] = 2] = \"DT_DOUBLE\";\n    DataType[DataType[\"DT_INT32\"] = 3] = \"DT_INT32\";\n    DataType[DataType[\"DT_UINT8\"] = 4] = \"DT_UINT8\";\n    DataType[DataType[\"DT_INT16\"] = 5] = \"DT_INT16\";\n    DataType[DataType[\"DT_INT8\"] = 6] = \"DT_INT8\";\n    DataType[DataType[\"DT_STRING\"] = 7] = \"DT_STRING\";\n    DataType[DataType[\"DT_COMPLEX64\"] = 8] = \"DT_COMPLEX64\";\n    DataType[DataType[\"DT_INT64\"] = 9] = \"DT_INT64\";\n    DataType[DataType[\"DT_BOOL\"] = 10] = \"DT_BOOL\";\n    DataType[DataType[\"DT_QINT8\"] = 11] = \"DT_QINT8\";\n    DataType[DataType[\"DT_QUINT8\"] = 12] = \"DT_QUINT8\";\n    DataType[DataType[\"DT_QINT32\"] = 13] = \"DT_QINT32\";\n    DataType[DataType[\"DT_BFLOAT16\"] = 14] = \"DT_BFLOAT16\";\n    DataType[DataType[\"DT_FLOAT_REF\"] = 101] = \"DT_FLOAT_REF\";\n    DataType[DataType[\"DT_DOUBLE_REF\"] = 102] = \"DT_DOUBLE_REF\";\n    DataType[DataType[\"DT_INT32_REF\"] = 103] = \"DT_INT32_REF\";\n    DataType[DataType[\"DT_UINT8_REF\"] = 104] = \"DT_UINT8_REF\";\n    DataType[DataType[\"DT_INT16_REF\"] = 105] = \"DT_INT16_REF\";\n    DataType[DataType[\"DT_INT8_REF\"] = 106] = \"DT_INT8_REF\";\n    DataType[DataType[\"DT_STRING_REF\"] = 107] = \"DT_STRING_REF\";\n    DataType[DataType[\"DT_COMPLEX64_REF\"] = 108] = \"DT_COMPLEX64_REF\";\n    DataType[DataType[\"DT_INT64_REF\"] = 109] = \"DT_INT64_REF\";\n    DataType[DataType[\"DT_BOOL_REF\"] = 110] = \"DT_BOOL_REF\";\n    DataType[DataType[\"DT_QINT8_REF\"] = 111] = \"DT_QINT8_REF\";\n    DataType[DataType[\"DT_QUINT8_REF\"] = 112] = \"DT_QUINT8_REF\";\n    DataType[DataType[\"DT_QINT32_REF\"] = 113] = \"DT_QINT32_REF\";\n    DataType[DataType[\"DT_BFLOAT16_REF\"] = 114] = \"DT_BFLOAT16_REF\";\n})(DataType || (DataType = {}));\nexport var SaverDef;\n(function (SaverDef) {\n    /** CheckpointFormatVersion enum. */\n    let CheckpointFormatVersion;\n    (function (CheckpointFormatVersion) {\n        CheckpointFormatVersion[CheckpointFormatVersion[\"LEGACY\"] = 0] = \"LEGACY\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V1\"] = 1] = \"V1\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V2\"] = 2] = \"V2\";\n    })(CheckpointFormatVersion = SaverDef.CheckpointFormatVersion || (SaverDef.CheckpointFormatVersion = {}));\n})(SaverDef || (SaverDef = {}));\n//# sourceMappingURL=compiled_api.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst contexts = {};\nconst WEBGL_ATTRIBUTES = {\n    alpha: false,\n    antialias: false,\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: false,\n    depth: false,\n    stencil: false,\n    failIfMajorPerformanceCaveat: true\n};\nexport function setWebGLContext(webGLVersion, gl) {\n    contexts[webGLVersion] = gl;\n}\nexport function getWebGLContext(webGLVersion) {\n    if (!(webGLVersion in contexts)) {\n        contexts[webGLVersion] = getWebGLRenderingContext(webGLVersion);\n    }\n    const gl = contexts[webGLVersion];\n    if (gl.isContextLost()) {\n        delete contexts[webGLVersion];\n        return getWebGLContext(webGLVersion);\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.DITHER);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SAMPLE_COVERAGE);\n    gl.enable(gl.SCISSOR_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    return contexts[webGLVersion];\n}\nfunction createCanvas(webGLVersion) {\n    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n        return new OffscreenCanvas(300, 150);\n    }\n    else if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction getWebGLRenderingContext(webGLVersion) {\n    if (webGLVersion !== 1 && webGLVersion !== 2) {\n        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n    }\n    const canvas = createCanvas(webGLVersion);\n    canvas.addEventListener('webglcontextlost', (ev) => {\n        ev.preventDefault();\n        delete contexts[webGLVersion];\n    }, false);\n    if (webGLVersion === 1) {\n        return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));\n    }\n    return canvas.getContext('webgl2', WEBGL_ATTRIBUTES);\n}\n//# sourceMappingURL=canvas_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { util } from '@tensorflow/tfjs-core';\nexport var PackingScheme;\n(function (PackingScheme) {\n    /**\n     * All values in a single texel are densely packed without any constraints.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 4]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   010|011   020|021\n     * -------   -------   -------\n     * 002|003   012|013   022|023\n     *\n     * 100|101   110|111   120|121\n     * -------   -------   -------\n     * 102|103   112|113   122|123\n     *\n     */\n    PackingScheme[PackingScheme[\"DENSE\"] = 0] = \"DENSE\";\n    /**\n     * Single texels contain only values from the same batch, and from adjacent\n     * rows and columns.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 5]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     */\n    PackingScheme[PackingScheme[\"SHARED_BATCH\"] = 1] = \"SHARED_BATCH\";\n})(PackingScheme || (PackingScheme = {}));\nexport var TextureUsage;\n(function (TextureUsage) {\n    TextureUsage[TextureUsage[\"RENDER\"] = 0] = \"RENDER\";\n    TextureUsage[TextureUsage[\"UPLOAD\"] = 1] = \"UPLOAD\";\n    TextureUsage[TextureUsage[\"PIXELS\"] = 2] = \"PIXELS\";\n    TextureUsage[TextureUsage[\"DOWNLOAD\"] = 3] = \"DOWNLOAD\";\n})(TextureUsage || (TextureUsage = {}));\nexport var PhysicalTextureType;\n(function (PhysicalTextureType) {\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT16\"] = 0] = \"UNPACKED_FLOAT16\";\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT32\"] = 1] = \"UNPACKED_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_4X1_UNSIGNED_BYTE\"] = 2] = \"PACKED_4X1_UNSIGNED_BYTE\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT32\"] = 3] = \"PACKED_2X2_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT16\"] = 4] = \"PACKED_2X2_FLOAT16\";\n})(PhysicalTextureType || (PhysicalTextureType = {}));\nexport function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns, rows];\n}\nexport function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {\n    return matrixSize * channelsPerTexture;\n}\nexport function getColorMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns * 4, rows];\n}\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape) {\n    const size = util.sizeFromShape(shape);\n    const texelsNeeded = Math.ceil(size / 4);\n    return util.sizeToSquarishShape(texelsNeeded);\n}\nexport function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {\n    if (unpackedSize % channelsPerTexture !== 0) {\n        throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ` +\n            `${channelsPerTexture}`);\n    }\n    return unpackedSize / channelsPerTexture;\n}\nexport function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {\n    const requiredSize = unpackedArray.length * channels / 4;\n    if (matrix.length < requiredSize) {\n        throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);\n    }\n    let dst = 0;\n    for (let src = 0; src < unpackedArray.length; src += 4) {\n        for (let c = 0; c < channels; c++) {\n            matrix[dst++] = unpackedArray[src + c];\n        }\n    }\n}\nexport function getPackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [\n        Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n    ];\n}\nexport function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {\n    const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return w * h * 4;\n}\nexport function getTextureConfig(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    let internalFormatFloat;\n    let internalFormatHalfFloat;\n    let internalFormatPackedHalfFloat;\n    let internalFormatPackedFloat;\n    let textureFormatFloat;\n    let downloadTextureFormat;\n    let downloadUnpackNumChannels;\n    let defaultNumChannels;\n    let textureTypeHalfFloat;\n    let textureTypeFloat;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        internalFormatFloat = glany.R32F;\n        internalFormatHalfFloat = glany.R16F;\n        internalFormatPackedHalfFloat = glany.RGBA16F;\n        internalFormatPackedFloat = glany.RGBA32F;\n        textureFormatFloat = glany.RED;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 1;\n        textureTypeHalfFloat = glany.HALF_FLOAT;\n        textureTypeFloat = glany.FLOAT;\n    }\n    else {\n        internalFormatFloat = gl.RGBA;\n        internalFormatHalfFloat = gl.RGBA;\n        internalFormatPackedHalfFloat = gl.RGBA;\n        internalFormatPackedFloat = glany.RGBA;\n        textureFormatFloat = gl.RGBA;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 4;\n        textureTypeHalfFloat = textureHalfFloatExtension != null ?\n            textureHalfFloatExtension.HALF_FLOAT_OES :\n            null;\n        textureTypeFloat = gl.FLOAT;\n    }\n    downloadTextureFormat = gl.RGBA;\n    return {\n        internalFormatFloat,\n        internalFormatHalfFloat,\n        internalFormatPackedHalfFloat,\n        internalFormatPackedFloat,\n        textureFormatFloat,\n        downloadTextureFormat,\n        downloadUnpackNumChannels,\n        defaultNumChannels,\n        textureTypeHalfFloat,\n        textureTypeFloat\n    };\n}\n//# sourceMappingURL=tex_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        return util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\n//# sourceMappingURL=webgl_util.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { device_util, env } from '@tensorflow/tfjs-core';\nimport { getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled } from './webgl_util';\nconst ENV = env();\n/**\n * This file contains WebGL-specific flag registrations.\n */\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n    if (isWebGLVersionEnabled(2)) {\n        return 2;\n    }\n    else if (isWebGLVersionEnabled(1)) {\n        return 1;\n    }\n    return 0;\n});\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\nENV.registerFlag('WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the depthwise conv op. */\n// TODO: https://github.com/tensorflow/tfjs/issues/1679\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => false);\n/** Whether we will pack binary ops. */\nENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack unary ops. */\nENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack array ops. */\nENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack image ops. */\nENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n    const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n    !device_util.isMobile());\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n    return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n        false :\n        ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n/** Whether the fence API is available. */\nENV.registerFlag('WEBGL_FENCE_API_ENABLED', () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n    // Use uniform uploads only when 32bit floats are supported. In\n    // 16bit\n    // environments there are problems with comparing a 16bit texture value\n    // with a 32bit uniform value.\n    const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n    return useUniforms ? 4 : 0;\n});\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', () => {\n    return -1;\n}, threshold => {\n    if (threshold < 0 && threshold !== -1) {\n        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n    }\n});\n//# sourceMappingURL=flags_webgl.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNPackedProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ArgMinMaxProgram {\n    constructor(reduceInfo, op, firstPass) {\n        this.variableNames = ['A'];\n        const windowSize = reduceInfo.windowSize;\n        const batchSize = reduceInfo.batchSize;\n        const inSize = reduceInfo.inSize;\n        const outSize = Math.ceil(inSize / windowSize);\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        this.outputShape = [batchSize, outSize];\n        const compOp = (op === 'max') ? '>' : '<';\n        const indexSnippet = firstPass ?\n            'inOffset + i;' :\n            'round(getBestIndicesA(batch, inOffset + i));';\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport function getVecChannels(name, rank) {\n    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\nexport function getChannels(name, rank) {\n    if (rank === 1) {\n        return [name];\n    }\n    return getVecChannels(name, rank);\n}\nexport function getSourceCoords(rank, dims) {\n    if (rank === 1) {\n        return 'rc';\n    }\n    let coords = '';\n    for (let i = 0; i < rank; i++) {\n        coords += dims[i];\n        if (i < rank - 1) {\n            coords += ',';\n        }\n    }\n    return coords;\n}\n//# sourceMappingURL=packing_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport function getGlslDifferences() {\n    let version;\n    let attribute;\n    let varyingVs;\n    let varyingFs;\n    let texture2D;\n    let output;\n    let defineOutput;\n    let defineSpecialNaN;\n    let defineSpecialInf;\n    let defineRound;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        version = '#version 300 es';\n        attribute = 'in';\n        varyingVs = 'out';\n        varyingFs = 'in';\n        texture2D = 'texture';\n        output = 'outputColor';\n        defineOutput = 'out vec4 outputColor;';\n        // Use custom isnan definition to work across differences between\n        // implementations on various platforms. While this should happen in ANGLE\n        // we still see differences between android and windows (on chrome) when\n        // using isnan directly.\n        defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n        // In webgl 2 we do not need to specify a custom isinf so there is no\n        // need for a special INFINITY constant.\n        defineSpecialInf = ``;\n        defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    else {\n        version = '';\n        attribute = 'attribute';\n        varyingVs = 'varying';\n        varyingFs = 'varying';\n        texture2D = 'texture2D';\n        output = 'gl_FragColor';\n        defineOutput = '';\n        // WebGL1 has no built in isnan so we define one here.\n        defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n        defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n        defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    return {\n        version,\n        attribute,\n        varyingVs,\n        varyingFs,\n        texture2D,\n        output,\n        defineOutput,\n        defineSpecialNaN,\n        defineSpecialInf,\n        defineRound\n    };\n}\n//# sourceMappingURL=glsl_version.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nfunction buildVec(x) {\n    if (x.length === 1) {\n        return `${x[0]}`;\n    }\n    return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(`Vectors to be dotted must be of the same length -` +\n            `got ${x.length} and ${y.length}`);\n    }\n    const slices = [];\n    const nearestVec4 = Math.floor(x.length / 4);\n    const nearestVec4Remainder = x.length % 4;\n    for (let i = 0; i < nearestVec4; i++) {\n        const xSlice = x.slice(i * 4, i * 4 + 4);\n        const ySlice = y.slice(i * 4, i * 4 + 4);\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    if (nearestVec4Remainder !== 0) {\n        let xSlice = x.slice(nearestVec4 * 4);\n        let ySlice = y.slice(nearestVec4 * 4);\n        if (xSlice.length === 1) {\n            xSlice = xSlice.map(d => `float(${d})`);\n            ySlice = ySlice.map(d => `float(${d})`);\n        }\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape) {\n    const strides = util.computeStrides(shape).map(d => d.toString());\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n//# sourceMappingURL=shader_compiler_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nconst { getBroadcastDims } = backend_util;\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {\n    const prefixSnippets = [];\n    inputsInfo.forEach(x => {\n        const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n        // Snippet when we decided to upload the values as uniform.\n        if (x.shapeInfo.isUniform) {\n            prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n        }\n        else {\n            prefixSnippets.push(`uniform sampler2D ${x.name};`);\n            prefixSnippets.push(`uniform int offset${x.name};`);\n        }\n    });\n    const inputPrefixSnippet = prefixSnippets.join('\\n');\n    const inputSamplingSnippet = inputsInfo\n        .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n        .join('\\n');\n    const outTexShape = outputShape.texShape;\n    const glsl = getGlslDifferences();\n    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n    let outputSamplingSnippet;\n    let floatTextureSetOutputSnippet;\n    let shaderPrefix = getShaderPrefix(glsl);\n    if (outputShape.isPacked) {\n        outputSamplingSnippet =\n            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n    }\n    else {\n        outputSamplingSnippet =\n            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n    }\n    if (usesPackedTextures) {\n        shaderPrefix += SHADER_PACKED_PREFIX;\n    }\n    const source = [\n        shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n        inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nfunction getSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getSamplerScalar(inInfo);\n        case 1:\n            return getSampler1D(inInfo);\n        case 2:\n            return getSampler2D(inInfo);\n        case 3:\n            return getSampler3D(inInfo);\n        case 4:\n            return getSampler4D(inInfo);\n        case 5:\n            return getSampler5D(inInfo);\n        case 6:\n            return getSampler6D(inInfo);\n        default:\n            throw new Error(`${shape.length}-D input sampling` +\n                ` is not yet supported`);\n    }\n}\nfunction getPackedSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getPackedSamplerScalar(inInfo);\n        case 1:\n            return getPackedSampler1D(inInfo);\n        case 2:\n            return getPackedSampler2D(inInfo);\n        case 3:\n            return getPackedSampler3D(inInfo);\n        default:\n            return getPackedSamplerND(inInfo);\n    }\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {\n    let res = '';\n    if (usesPackedTextures) {\n        res += getPackedSamplerFromInInfo(inInfo);\n    }\n    else {\n        res += getSamplerFromInInfo(inInfo);\n    }\n    const inShape = inInfo.shapeInfo.logicalShape;\n    const outShape = outShapeInfo.logicalShape;\n    if (inShape.length <= outShape.length) {\n        if (usesPackedTextures) {\n            res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n        else {\n            res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n    }\n    return res;\n}\nfunction getPackedOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutputPacked1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutputPacked2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutputPacked3DCoords(outShape, outTexShape);\n        default:\n            return getOutputPackedNDCoords(outShape, outTexShape);\n    }\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        case 5:\n            return getOutput5DCoords(outShape, outTexShape);\n        case 6:\n            return getOutput6DCoords(outShape, outTexShape);\n        default:\n            throw new Error(`${outShape.length}-D output sampling is not yet supported`);\n    }\n}\nfunction getFloatTextureSampleSnippet(glsl) {\n    return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\nfunction getFloatTextureSetRSnippet(glsl) {\n    return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\nfunction getFloatTextureSetRGBASnippet(glsl) {\n    return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\nfunction getShaderPrefix(glsl) {\n    const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n    return SHADER_PREFIX;\n}\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\nfunction getOutputScalarCoords() {\n    return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\nfunction getOutputPacked1DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (packedTexShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n    }\n    if (packedTexShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n    }\n    if (texShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\nfunction getOutputPacked3DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\nfunction getOutput3DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\nfunction getOutputPackedNDCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = ``;\n    let coords = 'b, r, c';\n    for (let b = 2; b < shape.length - 1; b++) {\n        texelsInBatchN *= shape[shape.length - b - 1];\n        batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n        coords = `b${b}, ` + coords;\n    }\n    return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\nfunction getOutput4DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2'], shape);\n    return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\nfunction getOutput5DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3'], shape);\n    return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\nfunction getOutput6DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n    return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\nfunction getOutputPacked2DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      }\n    `;\n    }\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n    }\n    if (shape[1] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n    }\n    if (shape[0] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n    }\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getFlatOffsetUniformName(texName) {\n    return `offset${texName}`;\n}\nfunction getPackedSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\nfunction getSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        return `float ${funcName}() {return ${texName};}`;\n    }\n    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n    if (texNumR === 1 && texNumC === 1) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const tNumR = texShape[0];\n    const tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    if (tNumC === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const glsl = getGlslDifferences();\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n    }\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        const texNumR = texShape[0];\n        const texNumC = texShape[1];\n        return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const offset = getFlatOffsetUniformName(texName);\n    if (texNumC === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    if (texNumR === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\nfunction getPackedSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (shape[0] === 1) {\n        const squeezedShape = shape.slice(1);\n        const keptDims = [1, 2];\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['b', 'row', 'col'];\n        return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col', 'depth'];\n        return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n    }\n    if (texNumC === stride1 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\nfunction getPackedSamplerND(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const rank = shape.length;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = `int b, int row, int col`;\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n        params = `int b${b}, ` + params;\n        texelsInBatch *= shape[rank - b - 1];\n        index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler4D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride2 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler5D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride3 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler6D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride4 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getUniformSampler(inputInfo) {\n    const texName = inputInfo.name;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    if (inSize < 2) {\n        return `return ${texName};`;\n    }\n    return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\nfunction getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    let output = `return outputValue;`;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    const isInputScalar = inSize === 1;\n    const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n    const isOutputScalar = outSize === 1;\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n        output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n    }\n    else if (isInputScalar && !isOutputScalar) {\n        if (outRank === 1) {\n            output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n        }\n        else {\n            output = `\n        return vec4(outputValue.x);\n      `;\n        }\n    }\n    else if (broadcastDims.length) {\n        const rows = inRank - 2;\n        const cols = inRank - 1;\n        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.x);`;\n        }\n        else if (broadcastDims.indexOf(rows) > -1) {\n            output = `return vec4(outputValue.x, outputValue.y, ` +\n                `outputValue.x, outputValue.y);`;\n        }\n        else if (broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.xx, outputValue.zz);`;\n        }\n    }\n    return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const outTexShape = outShapeInfo.texShape;\n    const inTexShape = inputInfo.shapeInfo.texShape;\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n        inputInfo.shapeInfo.flatOffset == null &&\n        util.arraysEqual(inTexShape, outTexShape)) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n    }\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\nexport function getCoordsDataType(rank) {\n    if (rank <= 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else if (rank === 5) {\n        return 'ivec5';\n    }\n    else if (rank === 6) {\n        return 'ivec6';\n    }\n    else {\n        throw Error(`GPU for rank ${rank} is not yet supported`);\n    }\n}\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(inInfo, squeezedShape) {\n    // Deep copy.\n    const newInputInfo = JSON.parse(JSON.stringify(inInfo));\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\n    return newInputInfo;\n}\nfunction getSqueezedParams(params, keptDims) {\n    return keptDims.map(d => params[d]).join(', ');\n}\n//# sourceMappingURL=shader_compiler.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ArgMinMaxPackedProgram {\n    constructor(shape, windowSize, op, firstPass) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        util.assert(shape.length > 2, () => `Packed arg${op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n        const inSize = shape[shape.length - 1];\n        const outSize = Math.ceil(inSize / windowSize);\n        this.outputShape = shape.slice(0, -1);\n        if (outSize > 1) {\n            this.outputShape.push(outSize);\n        }\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        const outShape = this.outputShape;\n        const rank = outShape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        let sourceLocSetup;\n        let sourceRank;\n        if (outSize === 1) {\n            sourceRank = rank + 1;\n            const sourceLocDType = getCoordsDataType(sourceRank);\n            sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n        }\n        else {\n            sourceRank = rank;\n            sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n        }\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n        const inChannel = '.' + channels[sourceRank - 1]; // e.g. \".b\" for rank 3.\n        const intChannels = channels.map(x => 'int ' + x);\n        const srcRCoords = getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n        const srcGCoords = getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n        const srcBCoords = getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n        const srcACoords = getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n        const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n        const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n        const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n        const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n        this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AvgPool2DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterHeight * filterWidth);\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class AvgPool3DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=avg_pool_backprop_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.outputShape = [];\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = '0.0';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = '1.0';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormPackedProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = 'vec4(0.0)';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = 'vec4(1.0)';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n    REAL: 'return areal * breal - aimag * bimag;',\n    IMAG: 'return areal * bimag + aimag * breal;'\n};\nexport class BinaryOpComplexProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_complex_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nconst CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const ADD = 'return a + b;';\nexport const SUB = 'return a - b;';\nexport const MUL = 'return a * b;';\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nexport const DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nexport const INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\nexport const POW = `\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport const EQUAL = `return float(a == b);`;\nexport const NOT_EQUAL = `return float(a != b);`;\nexport const LESS = `return float(a < b);`;\nexport const LESS_EQUAL = `return float(a <= b);`;\nexport const GREATER = `return float(a > b);`;\nexport const GREATER_EQUAL = `return float(a >= b);`;\nexport const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\nexport const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\nexport const MAX = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\nexport const MIN = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\nexport const MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\nexport const ATAN2 = CHECK_NAN_SNIPPET + `\n  return atan(a, b);\n`;\nexport const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\nexport class BinaryOpProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['A', 'B'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nconst CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nexport const DIV = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\nexport const INT_DIV = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\nexport const POW = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const PRELU = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\nexport const ATAN2 = `\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const EQUAL = `\n  return vec4(equal(a, b));\n`;\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\nexport const LESS = `\n  return vec4(lessThan(a, b));\n`;\nexport const LESS_EQUAL = `\n  return vec4(lessThanEqual(a, b));\n`;\nexport const GREATER = `\n  return vec4(greaterThan(a, b));\n`;\nexport const GREATER_EQUAL = `\n  return vec4(greaterThanEqual(a, b));\n`;\nexport const LOGICAL_AND = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\nexport const LOGICAL_OR = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\nexport const MAX = `\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const MIN = `\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport const MOD = `\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  ` +\n    CHECK_NAN_SNIPPET + `\n  return result;\n`;\nexport class BinaryOpPackedProgram {\n    constructor(op, aShape, bShape, checkOutOfBounds = false) {\n        this.variableNames = ['A', 'B'];\n        this.supportsBroadcasting = true;\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const rank = this.outputShape.length;\n        let checkOutOfBoundsString = '';\n        if (checkOutOfBounds) {\n            if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n                checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n            }\n            else {\n                const dtype = getCoordsDataType(rank);\n                checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n                if (rank === 1) {\n                    checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n                }\n                else {\n                    const channels = getChannels('coords', rank);\n                    checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n                }\n            }\n        }\n        this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipPackedProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ComplexAbsProgram {\n    constructor(shape) {\n        this.variableNames = ['real', 'imag'];\n        this.outputShape = shape;\n        this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n    }\n}\n//# sourceMappingURL=complex_abs_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class ConcatProgram {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    constructor(shapes) {\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            snippets.push(`else if (yC < ${offsets[i]}) ` +\n                `setOutput(getT${i}(yR, yC-${shift}));`);\n        }\n        const lastIndex = offsets.length;\n        const lastShift = offsets[offsets.length - 1];\n        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n    }\n}\n//# sourceMappingURL=concat_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=concat_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = filterDepth - 1 - convInfo.padInfo.front;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class DepthwiseConv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class DepthwiseConvPacked2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = convInfo.outShape;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `int xR; int xC; int xCOffset;`;\n        for (let r = 0; r < filterHeight; r++) {\n            for (let c = 0; c < filterWidth; c++) {\n                mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n            }\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        for (let r = 0; r < filterHeight; r++) {\n            for (let texelC = 0; texelC < texelsAcross; texelC++) {\n                const c = texelC * 2;\n                mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n                if (strideWidth === 1) {\n                    if (c < filterWidth) {\n                        // If padding is odd, the outer texels have to be composed.\n                        if (padLeft % 2 === 1) {\n                            // TODO: Ensure vec4 previous does not result in redundant sample,\n                            // and avoid setting xTexelRC's that exceed the boundary in the\n                            // first place rather than resetting them to vec4(0)).\n                            // To compute xCOffset:\n                            // - If padding is odd, we must add 1 to ensure we ask for an\n                            // even-numbered row.\n                            // - We subtract 2 to access the previous texel.\n                            mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n                        }\n                        else {\n                            // Padding is even, so xRC corresponds to a single texel.\n                            mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n                        }\n                        if (c + 1 < filterWidth) {\n                            // If dilation is even, the second entry should match the first\n                            // (either both are composed or both are single samples). But if\n                            // dilation is odd, then the second entry should be the opposite\n                            // of the first (if the first is composed, the second is a single\n                            // sample, and vice versa.)\n                            const nextTexelOffset = padLeft % 2 === 0 ?\n                                util.nearestLargerEven(dilationWidth) :\n                                dilationWidth;\n                            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n                                // If dilation > 1 then the xRC's will not be able to share any\n                                // values, so each xRC will require two unique calls to getX.\n                                if (dilationWidth > 1) {\n                                    mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                                }\n                                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n                            }\n                            else {\n                                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n                            }\n                        }\n                    }\n                }\n                else { // stride > 1\n                    if (c < filterWidth) {\n                        mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n                        // Depending on whether padLeft is even or odd, we want either the\n                        // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n                        // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n                        // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n                        // need to come from the xy channels of a new texel, hence the `vec4\n                        // final` initialized below.\n                        if (padLeft % 2 === 1) {\n                            mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n                            }\n                        }\n                        else {\n                            mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n                            }\n                        }\n                        mainLoop += `}`;\n                    }\n                }\n                if (c < filterWidth) {\n                    mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n                    if (c + 1 < filterWidth) {\n                        mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n                    }\n                }\n            }\n        }\n        for (let r = 0; r < filterHeight; r++) {\n            for (let c = 0; c < filterWidth; c++) {\n                mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n            }\n        }\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_packed_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=crop_and_resize_gpu.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthToSpaceProgram {\n    constructor(outputShape, blockSize, dataFormat) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.blockSize = blockSize;\n        this.dataFormat = dataFormat;\n        this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n    }\n    getHeightCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[1]`;\n        }\n        else {\n            return `coords[2]`;\n        }\n    }\n    getWidthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[2]`;\n        }\n        else {\n            return `coords[3]`;\n        }\n    }\n    getDepthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[3]`;\n        }\n        else {\n            return `coords[1]`;\n        }\n    }\n    getOutputDepthSize() {\n        if (this.dataFormat === 'NHWC') {\n            return this.outputShape[3];\n        }\n        else {\n            return this.outputShape[1];\n        }\n    }\n    getInputSamplingString() {\n        if (this.dataFormat === 'NHWC') {\n            return `getX(b, in_h, in_w, in_d)`;\n        }\n        else {\n            return `getX(b, in_d, in_h, in_w)`;\n        }\n    }\n}\n//# sourceMappingURL=depth_to_space_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DiagProgram {\n    constructor(size) {\n        this.variableNames = ['X'];\n        this.outputShape = [size, size];\n        this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=diag_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport class EncodeMatrixProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let output = `result`;\n        if (inputIsUnsignedByte) {\n            output = `floor(result * 255. + 0.5)`;\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\nexport class EncodeMatrixPackedProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let mainLoop = '';\n        let output = 'result';\n        if (inputIsUnsignedByte) {\n            output = 'floor(result * 255. + 0.5)';\n        }\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                const channel = row * 2 + col;\n                mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const COMPLEX_FFT = {\n    REAL: 'return real * expR - imag * expI;',\n    IMAG: 'return real * expI + imag * expR;'\n};\nexport class FFTProgram {\n    constructor(op, inputShape, inverse) {\n        this.variableNames = ['real', 'imag'];\n        const innerDim = inputShape[1];\n        this.outputShape = inputShape;\n        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n        const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n        this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${op}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=fft_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FillProgram {\n    constructor(shape, value) {\n        this.outputShape = [];\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n    }\n    getCustomSetupFunc(value) {\n        return (gpgpu, webGLProgram) => {\n            if (this.valueLoc == null) {\n                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(this.valueLoc, value);\n        };\n    }\n}\n//# sourceMappingURL=fill_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class GatherProgram {\n    constructor(aShape, indicesLength, axis) {\n        this.variableNames = ['A', 'indices'];\n        const outputShape = aShape.slice();\n        outputShape[axis] = indicesLength;\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape, axis);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\nfunction getSourceCoords(aShape, axis) {\n    const rank = aShape.length;\n    if (rank > 4) {\n        throw Error(`Gather for rank ${rank} is not yet supported`);\n    }\n    if (rank === 1) {\n        return `int(getIndices(resRC))`;\n    }\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        if (i === axis) {\n            sourceCoords.push(`int(getIndices(${currentCoords[i]}))`);\n        }\n        else {\n            sourceCoords.push(`${currentCoords[i]}`);\n        }\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=gather_gpu.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class GatherNDProgram {\n    constructor(sliceDim, strides, shape) {\n        this.sliceDim = sliceDim;\n        this.strides = strides;\n        this.variableNames = ['x', 'indices'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=gather_nd_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n    const glsl = getGlslDifferences();\n    const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n    return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n    webgl_util.validateTextureSize(width, height);\n    const texture = webgl_util.createTexture(gl);\n    const tex2d = gl.TEXTURE_2D;\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n    return texture;\n}\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n    return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n    const posOffset = 0; // x is the first buffer element\n    const uvOffset = 3 * 4; // uv comes after [x y z]\n    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n    const success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    let dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    if (pixels.data instanceof Uint8Array) {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n    }\n    else {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n    }\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    const buffer = gl2.createBuffer();\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n    // Initialize the buffer to the size of the texture in bytes.\n    const bytesPerFloat = 4;\n    const valuesPerTexel = 4;\n    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    webgl_util.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    webgl_util.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n    return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n    const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    const numChannels = 4;\n    const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n    return packedRGBA;\n}\n//# sourceMappingURL=gpgpu_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n    constructor(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        const glVersion = env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (env().getNumber('WEBGL_VERSION') === 1) {\n            const TEXTURE_FLOAT = 'OES_texture_float';\n            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n        this.textureConfig =\n            tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    get debug() {\n        return env().getBool('DEBUG');\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        const gl = this.gl;\n        webgl_util.callAndCheck(gl, () => gl.finish());\n        webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n        this.disposed = true;\n    }\n    createFloat32MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createFloat16MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createUnsignedBytesMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    uploadPixelDataToTexture(texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n    uploadDenseMatrixToTexture(texture, width, height, data) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n    createFloat16PackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createPackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    deleteMatrixTexture(texture) {\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n    }\n    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n    }\n    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n    downloadFloat32MatrixFromBuffer(buffer, size) {\n        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n    createBufferFromTexture(texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    createAndWaitForFence() {\n        const fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    }\n    createFence(gl) {\n        let query;\n        let isFencePassed;\n        if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            const gl2 = gl;\n            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = () => {\n                const status = gl2.clientWaitSync(sync, 0, 0);\n                return status === gl2.ALREADY_SIGNALED ||\n                    status === gl2.CONDITION_SATISFIED;\n            };\n            query = sync;\n        }\n        else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = () => true;\n        }\n        return { query, isFencePassed };\n    }\n    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n    }\n    createProgram(fragmentShaderSource) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        const vertexShader = gpgpu_util.createVertexShader(gl);\n        const program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, vertexShader));\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n        webgl_util.linkProgram(gl, program);\n        if (this.debug) {\n            webgl_util.validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    }\n    deleteProgram(program) {\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n        }\n    }\n    setProgram(program) {\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n    }\n    getUniformLocation(program, uniformName, shouldThrow = true) {\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    }\n    getAttributeLocation(program, attribute) {\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n    }\n    getUniformLocationNoThrow(program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    }\n    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n    debugValidate() {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    }\n    executeProgram() {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        const gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n    }\n    blockUntilAllProgramsCompleted() {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n    }\n    getQueryTimerExtension() {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    }\n    getQueryTimerExtensionWebGL2() {\n        return this.getQueryTimerExtension();\n    }\n    getQueryTimerExtensionWebGL1() {\n        return this.getQueryTimerExtension();\n    }\n    beginQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const query = gl2.createQuery();\n            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n            return query;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        const query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    }\n    endQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext.TIME_ELAPSED_EXT);\n            return;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n    async waitForQueryAndGetTime(query) {\n        await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n            // in rapid succession, so without this check we\n            // may poll for the query timer indefinitely\n            this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n        return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    }\n    getQueryTime(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    }\n    isQueryAvailable(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    }\n    pollFence(fenceContext) {\n        return new Promise(resolve => {\n            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n        });\n    }\n    pollItems() {\n        // Find the last query that has finished.\n        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n        for (let i = 0; i <= index; ++i) {\n            const { resolveFn } = this.itemsToPoll[i];\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n    addItemToPoll(isDoneFn, resolveFn) {\n        this.itemsToPoll.push({ isDoneFn, resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        util.repeatedTry(() => {\n            this.pollItems();\n            // End the loop if no more items to poll.\n            return this.itemsToPoll.length === 0;\n        });\n    }\n    bindTextureToFrameBuffer(texture) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n    }\n    unbindTextureToFrameBuffer() {\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    }\n    downloadMatrixDriver(texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n        webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n    }\n    setOutputMatrixWriteRegionDriver(x, y, width, height) {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n    }\n    throwIfDisposed() {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    }\n    throwIfNoProgram() {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n    let i = 0;\n    for (; i < arr.length; ++i) {\n        const isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n//# sourceMappingURL=gpgpu_context.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nexport function compileProgram(gpgpu, program, inputs, output) {\n    const userCode = program.userCode;\n    const inputInfos = inputs.map((input, i) => {\n        const shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.isUniform ? null : input.texData.texShape,\n            isUniform: input.isUniform,\n            isPacked: input.isUniform ? false : input.texData.isPacked,\n            flatOffset: null\n        };\n        if (input.texData != null && input.texData.slice != null &&\n            input.texData.slice.flatOffset > 0) {\n            shapeInfo.flatOffset = input.texData.slice.flatOffset;\n        }\n        return { name: program.variableNames[i], shapeInfo };\n    });\n    const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n    const outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.texData.texShape,\n        isUniform: false,\n        isPacked: output.texData.isPacked,\n        flatOffset: null\n    };\n    const source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);\n    const webGLProgram = gpgpu.createProgram(source);\n    // Add special uniforms (NAN, INFINITY)\n    let infLoc = null;\n    const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n    }\n    // Add user-defined uniforms\n    const uniformLocations = {};\n    for (let i = 0; i < program.variableNames.length; i++) {\n        const varName = program.variableNames[i];\n        const shouldThrow = false;\n        uniformLocations[varName] =\n            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n        uniformLocations[`offset${varName}`] =\n            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n    }\n    return {\n        program,\n        source,\n        webGLProgram,\n        uniformLocations,\n        inShapeInfos,\n        outShapeInfo,\n        infLoc,\n        nanLoc,\n    };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +\n            `was executed with ${inputs.length} inputs`);\n    }\n    shapeInfos.forEach((s, i) => {\n        const shapeA = s.logicalShape;\n        const input = inputs[i];\n        const shapeB = input.shape;\n        if (!util.arraysEqual(shapeA, shapeB)) {\n            throw Error(`Binary was compiled with different shapes than ` +\n                `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n        }\n        // The input is uploaded as uniform.\n        if (s.isUniform && input.isUniform) {\n            return;\n        }\n        const texShapeA = s.texShape;\n        const texShapeB = input.isUniform ? null : input.texData.texShape;\n        if (!util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(`Binary was compiled with different texture shapes than the` +\n                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n        }\n    });\n}\nexport function runProgram(gpgpu, binary, inputs, output, customSetup) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    const outTex = output.texData.texture;\n    const outTexShape = output.texData.texShape;\n    if (output.texData.isPacked) {\n        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    else {\n        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    gpgpu.setProgram(binary.webGLProgram);\n    // Set special uniforms (NAN, INFINITY)\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        if (binary.infLoc !== null) {\n            gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n        }\n    }\n    if (binary.nanLoc !== null) {\n        gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n    }\n    // Set user-defined inputs\n    inputs.forEach((input, i) => {\n        const varName = binary.program.variableNames[i];\n        const varLoc = binary.uniformLocations[varName];\n        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n        if (varLoc == null) {\n            // The compiler inferred that this variable is not used in this shader.\n            return;\n        }\n        if (input.isUniform) {\n            // Upload the values of the tensor as uniform.\n            if (util.sizeFromShape(input.shape) < 2) {\n                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n            }\n            else {\n                let vals = input.uniformValues;\n                if (!(vals instanceof Float32Array)) {\n                    vals = new Float32Array(vals);\n                }\n                gpgpu.gl.uniform1fv(varLoc, vals);\n            }\n            return;\n        }\n        // If the input was sliced, upload the flat offset index.\n        if (input.texData.slice != null && varOffsetLoc != null) {\n            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n        }\n        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n    });\n    if (customSetup != null) {\n        customSetup(gpgpu, binary.webGLProgram);\n    }\n    gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n    let keyInputs = '';\n    inputs.concat(output).forEach(x => {\n        const hasOffset = x.texData != null && x.texData.slice != null &&\n            x.texData.slice.flatOffset > 0;\n        const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n    });\n    const keyUserCode = program.userCode;\n    let key = program.constructor.name;\n    // Fast string concat. See https://jsperf.com/string-concatenation/14.\n    key += '_' + keyInputs + '_' + keyUserCode;\n    return key;\n}\n//# sourceMappingURL=gpgpu_math.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nexport class Im2ColPackedProgram {\n    constructor(outputShape, inputShape, convInfo) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const { filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat } = convInfo;\n        const { left, top } = padInfo;\n        const itemsPerBlockRow = inChannels * filterWidth;\n        const glsl = getGlslDifferences();\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 0 : 1;\n        const colDim = isChannelsLast ? 1 : 2;\n        let unrolled = ``;\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=im2col_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNProgram {\n    constructor(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        const rad = radius;\n        const maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        let powOperator;\n        const basis = `float(${bias}) + float(${alpha}) * sum`;\n        if (beta === 0.5) {\n            powOperator = `inversesqrt(${basis})`;\n        }\n        else if (beta === 1.0) {\n            powOperator = `1.0/(${basis})`;\n        }\n        else {\n            powOperator = `exp(log(${basis}) * float(-${beta}));`;\n        }\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNGradProgram {\n    constructor(inputShape, depthRadius, bias, alpha, beta) {\n        this.variableNames = ['inputImage', 'outputImage', 'dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        this.depth = inputShape[3];\n        this.depthRadius = depthRadius;\n        this.bias = bias;\n        this.alpha = alpha;\n        this.beta = beta;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_grad_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class LRNPackedProgram {\n    constructor(xShape, radius, bias, alpha, beta) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rad = radius;\n        const maxD = xShape[3] - 1;\n        this.outputShape = xShape;\n        // optimize pow(bias + alpha * sum, -beta)\n        // src: https://github.com/tensorflow/tensorflow/..\n        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n        // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n        let powOperator;\n        const basis = `float(${bias}) + float(${alpha}) * sum`;\n        if (beta === 0.5) {\n            powOperator = `inversesqrt(${basis})`;\n        }\n        else if (beta === 1.0) {\n            powOperator = `1.0/(${basis})`;\n        }\n        else {\n            powOperator = `exp(log(${basis}) * float(-${beta}));`;\n        }\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=lrn_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MaxPool2DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class MaxPool3DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=max_pool_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MatMulPackedProgram {\n    constructor(aShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false) {\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const sharedDim = transposeA ? aShape[1] : aShape[2];\n        const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n        const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n        const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          vec4 a = getMatrixA(rc.x, ${aSample});\n          vec4 b = getMatrixB(rc.x, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mulmat_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MultinomialProgram {\n    constructor(batchSize, numOutcomes, numSamples) {\n        this.variableNames = ['probs'];\n        this.outputShape = [batchSize, numSamples];\n        this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n    }\n    getCustomSetupFunc(seed) {\n        return (gpgpu, webGLProgram) => {\n            if (this.seedLoc == null) {\n                this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(this.seedLoc, seed);\n        };\n    }\n}\n//# sourceMappingURL=multinomial_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class OneHotProgram {\n    constructor(numIndices, depth, onValue, offValue) {\n        this.variableNames = ['indices'];\n        this.outputShape = [numIndices, depth];\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=onehot_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        // Only input / output 3D tensors.\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        if (rank === 0) {\n            this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n        }\n        else {\n            const channels = getChannels('rc', rank);\n            const dtype = getCoordsDataType(rank);\n            const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);\n            const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);\n            const output = getOutput(outputShape, channels);\n            this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n        }\n    }\n}\nfunction getSourceCoordsArr(rank, dims) {\n    const coords = [];\n    for (let row = 0; row <= 1; row++) {\n        for (let col = 0; col <= 1; col++) {\n            let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n            for (let d = 2; d < rank; d++) {\n                coord = `${dims[dims.length - 1 - d]},` + coord;\n            }\n            coords.push(coord);\n        }\n    }\n    return coords;\n}\nfunction getOutOfBoundsCondition(rank, shape, dims) {\n    if (rank === 1) {\n        return `rc > ${shape[0]}`;\n    }\n    let cond = '';\n    for (let i = rank - 2; i < rank; i++) {\n        cond += `${dims[i]} >= ${shape[i]}`;\n        if (i < rank - 1) {\n            cond += '||';\n        }\n    }\n    return cond;\n}\nfunction getSetup(rank, cols, rows, dims) {\n    if (rank === 1) {\n        return '';\n    }\n    const innerDims = dims.slice(-2);\n    return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\nfunction getOutput(shape, dims) {\n    const rank = shape.length;\n    const sourceCoords = getSourceCoordsArr(rank, dims);\n    if (rank === 1) {\n        return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n    }\n    return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n//# sourceMappingURL=pack_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const type = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${constantValue}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${constantValue}));\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pad_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadPackedProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const componentSetup = [\n            `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n            rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n        ];\n        const paddingArea = rank === 1 ?\n            'rc < start || rc >= end' :\n            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n        let mainLoop = '';\n        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n            mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(${constantValue});\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        mainLoop += (rank === 1 ? `} ` : `}}`);\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pad_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\nexport class Pool3DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ?\n                (includeBatchInIndex ?\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pool_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ReduceProgram {\n    constructor(reduceInfo, reduceType) {\n        this.variableNames = ['x'];\n        const windowSize = reduceInfo.windowSize;\n        const batchSize = reduceInfo.batchSize;\n        const inSize = reduceInfo.inSize;\n        const outSize = Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        let initializationValue = '0.0';\n        let compareOp = ``;\n        if (reduceType === 'prod') {\n            initializationValue = '1.0';\n        }\n        else if (reduceType === 'min') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '1.0 / 1e-20';\n            compareOp = `min`;\n        }\n        else if (reduceType === 'max') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n            compareOp = `max`;\n        }\n        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (reduceType === 'sum') {\n            returnValue = `sumValue`;\n        }\n        else if (reduceType === 'prod') {\n            returnValue = `prodValue`;\n        }\n        else if (reduceType === 'all') {\n            returnValue = `allValue`;\n        }\n        else if (reduceType === 'any') {\n            returnValue = `anyValue`;\n        }\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        let vecType = `vec4`;\n        if (reduceType === 'all') {\n            initializationValue = '1.0';\n            updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        else if (reduceType === 'any') {\n            initializationValue = '0.0';\n            updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reduce_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as shader_util from './shader_compiler_util';\nexport class ReshapePackedProgram {\n    constructor(outputShape, inputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        let mainLoop = ``;\n        for (let i = 0; i < 4; i++) {\n            let thisRC = `thisRC = rc;`;\n            if (i % 2 === 1) {\n                thisRC += `thisRC.z += 1;`;\n            }\n            if (i > 1) {\n                thisRC += `thisRC.y += 1;`;\n            }\n            mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n        }\n        this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\nfunction getReshapedInputCoords(shape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n//# sourceMappingURL=reshape_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearBackpropProgram {\n    constructor(dy, x, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = x.shape;\n        const [, xHeight, xWidth,] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_backprop_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearPackedProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeigborBackpropProgram {\n    constructor(dy, x, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = x.shape;\n        const [, xHeight, xWidth,] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeighborProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        // When align corners is false, we rounds the value with floor.\n        const roundBase = alignCorners ? '0.5' : '0.0';\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReverseProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        if (rank === 1) {\n            this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n            return;\n        }\n        const getInCoord = (i) => {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - coords[${i}] - 1`;\n            }\n            return `coords[${i}]`;\n        };\n        const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n        const type = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reverse_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        const channels = getChannels('rc', rank);\n        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n        const type = getCoordsDataType(rank);\n        if (rank === 1) {\n            this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n        }\n        else {\n            this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n        }\n        function getR(channels) {\n            return getChannel(channels);\n        }\n        function getG(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getB(channels) {\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getA(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getChannel(channels) {\n            const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n            const inCoords = inCoordsArray.join(',');\n            const innerDims = inCoordsArray.slice(-2).join(',');\n            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n        }\n        function getInCoord(i, channels1) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - ${channels1[i]} - 1`;\n            }\n            else {\n                return `${channels1[i]}`;\n            }\n        }\n    }\n}\n//# sourceMappingURL=reverse_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ScatterProgram {\n    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {\n        this.variableNames = ['updates', 'indices', 'defaultValue'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        let indicesString = '';\n        if (indicesRank === 1) {\n            indicesString = 'i';\n        }\n        else if (indicesRank === 2) {\n            indicesString = 'i, j';\n        }\n        const indicesSnippet = `getIndices(${indicesString})`;\n        let updatesString = '';\n        if (updatesRank === 1) {\n            updatesString = 'i';\n        }\n        else if (updatesRank === 2) {\n            updatesString = 'i, coords[1]';\n        }\n        const updatesSnippet = `getUpdates(${updatesString})`;\n        const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=scatter_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class SegmentOpProgram {\n    constructor(segOpInfo, segOpType) {\n        this.variableNames = ['x', 'segmentIds'];\n        const windowSize = segOpInfo.windowSize;\n        const batchSize = segOpInfo.batchSize;\n        const inSize = segOpInfo.inSize;\n        const numSegments = segOpInfo.numSegments;\n        const outSize = numSegments * Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        const initializationValue = '0.0';\n        const returnValue = `sumValue`;\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n        let checkValueOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        let checkSegmentIdOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=segment_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SelectProgram {\n    constructor(cRank, shape, rank) {\n        this.variableNames = ['c', 'a', 'b'];\n        this.outputShape = shape;\n        let cCoords;\n        let abCoords;\n        if (rank > 4) {\n            throw Error(`Where for rank ${rank} is not yet supported`);\n        }\n        if (rank === 1) {\n            abCoords = `resRC`;\n            cCoords = `resRC`;\n        }\n        else {\n            const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n            const cCoordVars = [];\n            const abCoordVars = [];\n            for (let i = 0; i < shape.length; i++) {\n                abCoordVars.push(`${currentCoords[i]}`);\n                if (i < cRank) {\n                    cCoordVars.push(`${currentCoords[i]}`);\n                }\n            }\n            cCoords = cCoordVars.join();\n            abCoords = abCoordVars.join();\n        }\n        const dtype = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=select_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SliceProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const uniformPart = `uniform int start[${this.rank}];`;\n        const sourceCoords = getCoords(this.rank);\n        let body;\n        const coordSum = destSize.map((_, i) => {\n            return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n        });\n        body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n        this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank <= 6) {\n        return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n    }\n    else {\n        throw Error(`Slicing for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=slice_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class SlicePackedProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const coords = getChannels('coords', this.rank);\n        const sourceLoc = getChannels('sourceLoc', this.rank);\n        const innerDims = this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n        const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n        const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n        const sourceLocSetup = this.rank <= 4 ?\n            `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n            destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n                .join('\\n');\n        this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\n//# sourceMappingURL=slice_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class StridedSliceProgram {\n    constructor(begin, strides, size) {\n        this.variableNames = ['x'];\n        this.outputShape = size;\n        const rank = size.length;\n        const inputDtype = getCoordsDataType(size.length);\n        const dtype = getCoordsDataType(size.length);\n        let newCoords = '';\n        if (rank === 1) {\n            newCoords = 'coords * strides + begin';\n        }\n        else {\n            let outputAxis = 0;\n            newCoords =\n                size.map((_, i) => {\n                    outputAxis++;\n                    return size.length === 1 ?\n                        `coords * strides[${i}] + begin[${i}]` :\n                        `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n                })\n                    .join(',');\n        }\n        this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=strided_slice_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TileProgram {\n    constructor(aShape, reps) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[i] * reps[i];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\nfunction getSourceCoords(aShape) {\n    const rank = aShape.length;\n    if (rank > 5) {\n        throw Error(`Tile for rank ${rank} is not yet supported`);\n    }\n    if (rank === 1) {\n        return `imod(resRC, ${aShape[0]})`;\n    }\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=tile_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class UnaryOpProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\nconst CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\nexport const LINEAR = `return x;`;\nexport const ABS = `return abs(x);`;\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nexport const SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\nexport function STEP(alpha = 0.0) {\n    return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\nexport const NEG = `return -x;`;\nexport const CEIL = `return ceil(x);`;\nexport const FLOOR = `return floor(x);`;\nexport const SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\nexport const IS_NAN = `return float(isnan(x));`;\nexport const IS_INF = `return float(isinf(x));`;\nexport const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\nexport const ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\nexport const EXP = `return exp(x);`;\nexport const EXPM1 = `return exp(x) - 1.0;`;\nexport const LOG = `if (x < 0.0) return NAN;\n  return log(x);`;\nexport const LOG1P = `return log(1.0 + x);`;\nexport const SQRT = `return sqrt(x);`;\nexport const RSQRT = `return inversesqrt(x);`;\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n/**\n * mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n *\n * epsilon is the difference between 1.0 and the next representable\n * float. For a single precision 32 bit float this should be 2^-23, see:\n * https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n *\n * too_large = (x > -threshold) is value above which exp(x) may overflow\n * but softplus(x) == x is within machine epsilon\n *\n * too_small = (x < threshold) is value below which exp(x) may underflow,\n * but softplus(x) == exp(x) is within machine epsilon.\n */\nexport const SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\nexport const SIN = CHECK_NAN_SNIPPET + `\n  return sin(x);\n`;\nexport const COS = CHECK_NAN_SNIPPET + `\n  return cos(x);\n`;\nexport const TAN = `return tan(x);`;\nexport const ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\nexport const ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\nexport const ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\nexport const SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\nexport const COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\nexport const TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\nexport const ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\nexport const ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));`;\nexport const ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\nexport const ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\nexport const SQUARE = `return x * x;`;\nexport const RECIPROCAL = `return 1.0 / x;`;\nexport const LOGICAL_NOT = `return float(!(x >= 1.0));`;\nexport const TO_INT = `return float(int(x));`;\nexport const CLONE = 'return x;';\n//# sourceMappingURL=unaryop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const LINEAR = `return x;`;\nexport const LOG = `\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n`;\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\nexport class UnaryOpPackedProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unaryop_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels, getSourceCoords } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class UnpackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        const channels = getChannels('rc', rank);\n        const dtype = getCoordsDataType(rank);\n        const sourceCoords = getSourceCoords(rank, channels);\n        const innerDims = channels.slice(-2);\n        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n        this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unpack_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport * as tf from '@tensorflow/tfjs-core';\nimport { complex, div, engine, env, imag, max, range, real, reshape, scalar, softmax, tensor, tidy, transpose } from '@tensorflow/tfjs-core';\nimport { backend_util, buffer, kernel_impls, slice_util, util } from '@tensorflow/tfjs-core';\nimport { DataStorage, KernelBackend, upcastType } from '@tensorflow/tfjs-core';\nconst { segment_util } = backend_util;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\nimport { AddNProgram } from './addn_gpu';\nimport { AddNPackedProgram } from './addn_packed_gpu';\nimport { ArgMinMaxProgram } from './argminmax_gpu';\nimport { ArgMinMaxPackedProgram } from './argminmax_packed_gpu';\nimport { AvgPool2DBackpropProgram, AvgPool3DBackpropProgram } from './avg_pool_backprop_gpu';\nimport { BatchNormProgram } from './batchnorm_gpu';\nimport { BatchNormPackedProgram } from './batchnorm_packed_gpu';\nimport * as binaryop_complex_gpu from './binaryop_complex_gpu';\nimport { BinaryOpComplexProgram } from './binaryop_complex_gpu';\nimport * as binaryop_gpu from './binaryop_gpu';\nimport { BinaryOpProgram } from './binaryop_gpu';\nimport * as binaryop_packed_gpu from './binaryop_packed_gpu';\nimport { BinaryOpPackedProgram } from './binaryop_packed_gpu';\nimport { getWebGLContext } from './canvas_util';\nimport { ClipProgram } from './clip_gpu';\nimport { ClipPackedProgram } from './clip_packed_gpu';\nimport { ComplexAbsProgram } from './complex_abs_gpu';\nimport { ConcatProgram } from './concat_gpu';\nimport { ConcatPackedProgram } from './concat_packed_gpu';\nimport { Conv2DDerFilterProgram, Conv2DDerInputProgram, Conv3DDerFilterProgram, Conv3DDerInputProgram } from './conv_backprop_gpu';\nimport { DepthwiseConv2DDerFilterProgram, DepthwiseConv2DDerInputProgram } from './conv_backprop_gpu_depthwise';\nimport { Conv2DProgram, Conv3DProgram } from './conv_gpu';\nimport { DepthwiseConv2DProgram } from './conv_gpu_depthwise';\nimport { DepthwiseConvPacked2DProgram } from './conv_packed_gpu_depthwise';\nimport { CropAndResizeProgram } from './crop_and_resize_gpu';\nimport { CumSumProgram } from './cumsum_gpu';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { DepthToSpaceProgram } from './depth_to_space_gpu';\nimport { DiagProgram } from './diag_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport * as fft_gpu from './fft_gpu';\nimport { FFTProgram } from './fft_gpu';\nimport { FillProgram } from './fill_gpu';\nimport { GatherProgram } from './gather_gpu';\nimport { GatherNDProgram } from './gather_nd_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { Im2ColPackedProgram } from './im2col_packed_gpu';\nimport { LRNProgram } from './lrn_gpu';\nimport { LRNGradProgram } from './lrn_grad_gpu';\nimport { LRNPackedProgram } from './lrn_packed_gpu';\nimport { MaxPool2DBackpropProgram, MaxPool3DBackpropProgram } from './max_pool_backprop_gpu';\nimport { MatMulPackedProgram } from './mulmat_packed_gpu';\nimport { MultinomialProgram } from './multinomial_gpu';\nimport { OneHotProgram } from './onehot_gpu';\nimport { PackProgram } from './pack_gpu';\nimport { PadProgram } from './pad_gpu';\nimport { PadPackedProgram } from './pad_packed_gpu';\nimport { Pool2DProgram, Pool3DProgram } from './pool_gpu';\nimport { ReduceProgram } from './reduce_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport { ResizeBilinearBackpropProgram } from './resize_bilinear_backprop_gpu';\nimport { ResizeBilinearProgram } from './resize_bilinear_gpu';\nimport { ResizeBilinearPackedProgram } from './resize_bilinear_packed_gpu';\nimport { ResizeNearestNeigborBackpropProgram } from './resize_nearest_neighbor_backprop_gpu';\nimport { ResizeNearestNeighborProgram } from './resize_nearest_neighbor_gpu';\nimport { ReverseProgram } from './reverse_gpu';\nimport { ReversePackedProgram } from './reverse_packed_gpu';\nimport { ScatterProgram } from './scatter_gpu';\nimport { SegmentOpProgram } from './segment_gpu';\nimport { SelectProgram } from './select_gpu';\nimport { SliceProgram } from './slice_gpu';\nimport { SlicePackedProgram } from './slice_packed_gpu';\nimport { StridedSliceProgram } from './strided_slice_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport { TileProgram } from './tile_gpu';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport * as unary_packed_op from './unaryop_packed_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\nconst binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n    if (webGLVersion in binaryCaches) {\n        return binaryCaches[webGLVersion];\n    }\n    binaryCaches[webGLVersion] = {};\n    return binaryCaches[webGLVersion];\n}\nfunction mapActivationToShaderProgram(activation, packed = false) {\n    if (activation === 'linear') {\n        if (packed) {\n            return unary_packed_op.LINEAR;\n        }\n        return unary_op.LINEAR;\n    }\n    else if (activation === 'relu') {\n        if (packed) {\n            return unary_packed_op.RELU;\n        }\n        return unary_op.RELU;\n    }\n    else if (activation === 'elu') {\n        if (packed) {\n            return unary_packed_op.ELU;\n        }\n        return unary_op.ELU;\n    }\n    else if (activation === 'relu6') {\n        if (packed) {\n            return unary_packed_op.RELU6;\n        }\n        return unary_op.RELU6;\n    }\n    else if (activation === 'prelu') {\n        if (packed) {\n            return binaryop_packed_gpu.PRELU;\n        }\n        return binaryop_gpu.PRELU;\n    }\n    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n    if (env().global.screen == null) {\n        return 1024; // 1 GB.\n    }\n    return (env().global.screen.height * env().global.screen.width *\n        window.devicePixelRatio) *\n        BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\nexport class MathBackendWebGL extends KernelBackend {\n    constructor(gpgpu) {\n        super();\n        // Maps data ids that have a pending read operation, to list of subscribers.\n        this.pendingRead = new WeakMap();\n        // List of data ids that are scheduled for disposal, but are waiting on a\n        // pending read operation.\n        this.pendingDisposal = new WeakSet();\n        // Used to count the number of 'shallow' sliced tensors that point to the\n        // same data id.\n        this.dataRefCount = new WeakMap();\n        this.numBytesInGPU = 0;\n        // Accumulated time spent (including blocking) in uploading data to webgl.\n        this.uploadWaitMs = 0;\n        // Accumulated time spent (including blocking in downloading data from webgl.\n        this.downloadWaitMs = 0;\n        this.warnedAboutMemory = false;\n        this.warnedAboutCPUBackend = false;\n        this.pendingDeletes = 0;\n        this.disposed = false;\n        if (!env().getBool('HAS_WEBGL')) {\n            throw new Error('WebGL is not supported on this device');\n        }\n        if (gpgpu == null) {\n            const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n            this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n            this.gpgpu = new GPGPUContext(gl);\n            this.canvas = gl.canvas;\n            this.gpgpuCreatedLocally = true;\n        }\n        else {\n            this.gpgpu = gpgpu;\n            this.binaryCache = {};\n            this.gpgpuCreatedLocally = false;\n            this.canvas = gpgpu.gl.canvas;\n        }\n        this.textureManager = new TextureManager(this.gpgpu);\n        this.numMBBeforeWarning = numMBBeforeWarning();\n        this.texData = new DataStorage(this, engine());\n    }\n    numDataIds() {\n        return this.texData.numDataIds() +\n            (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) -\n            this.pendingDeletes;\n    }\n    write(values, shape, dtype) {\n        if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n            env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64' && values != null) {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        const dataId = {};\n        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD });\n        return dataId;\n    }\n    move(dataId, values, shape, dtype) {\n        if (env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD });\n    }\n    readSync(dataId) {\n        const texData = this.texData.get(dataId);\n        const { values, dtype, complexTensors, slice, shape, isPacked } = texData;\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.readSync(res.dataId);\n            this.disposeData(res.dataId);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (dtype === 'string') {\n            return values;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let result;\n        if (dtype === 'complex64') {\n            const realValues = complexTensors.real.dataSync();\n            const imagValues = complexTensors.imag.dataSync();\n            result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else {\n            result = this.getValuesFromTexture(dataId);\n        }\n        if (shouldTimeProgram) {\n            this.downloadWaitMs += util.now() - start;\n        }\n        return this.convertAndCacheOnCPU(dataId, result);\n    }\n    async read(dataId) {\n        if (this.pendingRead.has(dataId)) {\n            const subscribers = this.pendingRead.get(dataId);\n            return new Promise(resolve => subscribers.push(resolve));\n        }\n        const texData = this.texData.get(dataId);\n        const { values, shape, slice, dtype, complexTensors, isPacked } = texData;\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.read(res.dataId);\n            this.disposeData(res.dataId);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n            env().getNumber('WEBGL_VERSION') === 2) {\n            throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n                `WEBGL_VERSION=2 not yet supported.`);\n        }\n        let buffer = null;\n        let tmpDownloadTarget;\n        if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n            // Possibly copy the texture into a buffer before inserting a fence.\n            tmpDownloadTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape));\n        }\n        this.pendingRead.set(dataId, []);\n        if (dtype !== 'complex64') {\n            // Create a fence and wait for it to resolve.\n            await this.gpgpu.createAndWaitForFence();\n        }\n        // Download the values from the GPU.\n        let vals;\n        if (dtype === 'complex64') {\n            const ps = await Promise.all([complexTensors.real.data(), complexTensors.imag.data()]);\n            const realValues = ps[0];\n            const imagValues = ps[1];\n            vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else if (buffer == null) {\n            vals = this.getValuesFromTexture(dataId);\n        }\n        else {\n            const size = util.sizeFromShape(shape);\n            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n        }\n        if (tmpDownloadTarget != null) {\n            this.disposeData(tmpDownloadTarget.dataId);\n        }\n        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n        const subscribers = this.pendingRead.get(dataId);\n        this.pendingRead.delete(dataId);\n        // Notify all pending reads.\n        subscribers.forEach(resolve => resolve(dTypeVals));\n        if (this.pendingDisposal.has(dataId)) {\n            this.pendingDisposal.delete(dataId);\n            this.disposeData(dataId);\n            this.pendingDeletes--;\n        }\n        return dTypeVals;\n    }\n    checkNumericalProblems(values) {\n        if (values == null) {\n            return;\n        }\n        for (let i = 0; i < values.length; i++) {\n            const num = values[i];\n            if (!webgl_util.canBeRepresented(num)) {\n                if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n                    throw Error(`The value ${num} cannot be represented with your ` +\n                        `current settings. Consider enabling float32 rendering: ` +\n                        `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n                }\n                throw Error(`The value ${num} cannot be represented on this device.`);\n            }\n        }\n    }\n    getValuesFromTexture(dataId) {\n        const { shape, dtype, isPacked } = this.texData.get(dataId);\n        const size = util.sizeFromShape(shape);\n        if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n            const tmpTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpTarget.dataId);\n            const vals = this.gpgpu\n                .downloadMatrixFromPackedTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                .subarray(0, size);\n            this.disposeData(tmpTarget.dataId);\n            return vals;\n        }\n        const shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n        const outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n        const program = shouldUsePackedProgram ?\n            new EncodeFloatPackedProgram(outputShape) :\n            new EncodeFloatProgram(outputShape);\n        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], 'float32');\n        const tmpData = this.texData.get(output.dataId);\n        const vals = this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n        this.disposeData(output.dataId);\n        return vals;\n    }\n    async time(f) {\n        const oldActiveTimers = this.activeTimers;\n        const newActiveTimers = [];\n        let outerMostTime = false;\n        if (this.programTimersStack == null) {\n            this.programTimersStack = newActiveTimers;\n            outerMostTime = true;\n        }\n        else {\n            this.activeTimers.push(newActiveTimers);\n        }\n        this.activeTimers = newActiveTimers;\n        f();\n        // needing to split these up because util.flatten only accepts certain types\n        const flattenedActiveTimerQueries = util.flatten(this.activeTimers.map((d) => d.query))\n            .filter(d => d != null);\n        const flattenedActiveTimerNames = util.flatten(this.activeTimers.map((d) => d.name))\n            .filter(d => d != null);\n        this.activeTimers = oldActiveTimers;\n        if (outerMostTime) {\n            this.programTimersStack = null;\n        }\n        const res = {\n            uploadWaitMs: this.uploadWaitMs,\n            downloadWaitMs: this.downloadWaitMs,\n            kernelMs: null,\n            wallMs: null // will be filled by the engine\n        };\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n            res['kernelMs'] = util.sum(kernelMs);\n            res['getExtraProfileInfo'] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d }))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n        }\n        else {\n            res['kernelMs'] = {\n                error: 'WebGL query timers are not supported in this environment.'\n            };\n        }\n        this.uploadWaitMs = 0;\n        this.downloadWaitMs = 0;\n        return res;\n    }\n    memory() {\n        return {\n            unreliable: false,\n            numBytesInGPU: this.numBytesInGPU,\n            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n            numBytesInGPUFree: this.textureManager.numBytesFree\n        };\n    }\n    startTimer() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.beginQuery();\n        }\n        return { startMs: util.now(), endMs: null };\n    }\n    endTimer(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            this.gpgpu.endQuery();\n            return query;\n        }\n        query.endMs = util.now();\n        return query;\n    }\n    async getQueryTime(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.waitForQueryAndGetTime(query);\n        }\n        const timerQuery = query;\n        return timerQuery.endMs - timerQuery.startMs;\n    }\n    disposeData(dataId) {\n        if (this.pendingDisposal.has(dataId)) {\n            return;\n        }\n        if (this.pendingRead.has(dataId)) {\n            this.pendingDisposal.add(dataId);\n            this.pendingDeletes++;\n            return;\n        }\n        // No-op if already disposed.\n        if (!this.texData.has(dataId)) {\n            return;\n        }\n        this.releaseGPUData(dataId);\n        const { complexTensors } = this.texData.get(dataId);\n        if (complexTensors != null) {\n            complexTensors.real.dispose();\n            complexTensors.imag.dispose();\n        }\n        this.texData.delete(dataId);\n    }\n    releaseGPUData(dataId) {\n        const { texture, dtype, texShape, usage, isPacked, slice } = this.texData.get(dataId);\n        const key = slice && slice.origDataId || dataId;\n        const refCount = this.dataRefCount.get(key);\n        if (refCount > 1) {\n            this.dataRefCount.set(key, refCount - 1);\n        }\n        else {\n            this.dataRefCount.delete(key);\n            if (texture != null) {\n                this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n            }\n        }\n        const texData = this.texData.get(dataId);\n        texData.texture = null;\n        texData.texShape = null;\n        texData.isPacked = false;\n        texData.slice = null;\n    }\n    getTexture(dataId) {\n        this.uploadToGPU(dataId);\n        return this.texData.get(dataId).texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n    getDataInfo(dataId) {\n        return this.texData.get(dataId);\n    }\n    getCPUBackend() {\n        if (!env().getBool('WEBGL_CPU_FORWARD')) {\n            return null;\n        }\n        if (this.cpuBackend == null) {\n            this.cpuBackend = engine().findBackend('cpu');\n        }\n        return this.cpuBackend;\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {\n        const cpuBackend = this.getCPUBackend();\n        if (!this.warnedAboutCPUBackend && cpuBackend == null &&\n            !env().getBool('IS_TEST')) {\n            console.warn('Your application contains ops that are small enough to be ' +\n                'executed on the CPU backend, however the CPU backend cannot ' +\n                'be found. Consider importing the CPU backend ' +\n                '(@tensorflow/tfjs-backend-cpu) for better performance.');\n            this.warnedAboutCPUBackend = true;\n        }\n        return cpuBackend != null &&\n            inputs.every(input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n    }\n    getGPGPUContext() {\n        return this.gpgpu;\n    }\n    complex(real, imag) {\n        const result = this.makeOutput(real.shape, 'complex64');\n        const resultData = this.texData.get(result.dataId);\n        // The backend owns the reference to the underlying real and imaginary\n        // clones. These will explicitly get disposed when the complex tensor is\n        // disposed.\n        resultData.complexTensors = {\n            real: engine().keep(real.clone()),\n            imag: engine().keep(imag.clone())\n        };\n        return result;\n    }\n    real(input) {\n        const resultData = this.texData.get(input.dataId);\n        return resultData.complexTensors.real.clone();\n    }\n    imag(input) {\n        const resultData = this.texData.get(input.dataId);\n        return resultData.complexTensors.imag.clone();\n    }\n    slice(x, begin, size) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.slice(x, begin, size);\n        }\n        // Short-circuit computation if the slice is zero-sized.\n        if (util.sizeFromShape(size) === 0) {\n            return tensor([], size, x.dtype);\n        }\n        const { isPacked } = this.texData.get(x.dataId);\n        const isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n        if (isPacked || !isContinous) {\n            const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n                new SlicePackedProgram(size) :\n                new SliceProgram(size);\n            const customSetup = program.getCustomSetupFunc(begin);\n            return this.compileAndRun(program, [x], null, customSetup);\n        }\n        this.uploadToGPU(x.dataId);\n        return this.shallowSlice(x, begin, size);\n    }\n    shallowSlice(x, begin, size) {\n        const xTexData = this.texData.get(x.dataId);\n        const t = this.makeOutput(size, x.dtype);\n        const newTexData = this.texData.get(t.dataId);\n        // Copy texture data from the original tensor.\n        Object.assign(newTexData, xTexData);\n        newTexData.shape = size;\n        newTexData.dtype = x.dtype;\n        let flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n        if (xTexData.slice) {\n            // We are slicing an already sliced tensor, so we have to accumulate\n            // the offset.\n            flatOffset += xTexData.slice.flatOffset;\n        }\n        newTexData.slice = {\n            flatOffset,\n            // Point to the original dataId, which is used to do ref counting.\n            origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n        };\n        // Increase the ref count for that data bucket.\n        const refCount = this.dataRefCount.get(newTexData.slice.origDataId) || 1;\n        this.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n        return t;\n    }\n    stridedSlice(x, begin, end, strides) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.stridedSlice(x, begin, end, strides);\n        }\n        const outShape = slice_util.computeOutShape(begin, end, strides);\n        if (outShape.some(axis => axis === 0)) {\n            return tensor([], outShape);\n        }\n        const program = new StridedSliceProgram(begin, strides, outShape);\n        return this.compileAndRun(program, [x]);\n    }\n    reverse(x, axis) {\n        const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new ReversePackedProgram(x.shape, axis) :\n            new ReverseProgram(x.shape, axis);\n        return this.compileAndRun(program, [x]);\n    }\n    concat(tensors, axis) {\n        if (tensors[0].dtype === 'complex64') {\n            const reals = tensors.map((t) => real(t));\n            const imags = tensors.map((t) => imag(t));\n            return complex(this.concat(reals, axis), this.concat(imags, axis));\n        }\n        if (this.shouldExecuteOnCPU(tensors)) {\n            return this.cpuBackend.concat(tensors, axis);\n        }\n        if (tensors.length === 1) {\n            return tensors[0];\n        }\n        if (tensors.length > env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n            const midIndex = Math.floor(tensors.length / 2);\n            const leftSide = this.concat(tensors.slice(0, midIndex), axis);\n            const rightSide = this.concat(tensors.slice(midIndex), axis);\n            return this.concat([leftSide, rightSide], axis);\n        }\n        if (env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') && tensors[0].rank > 1) {\n            const program = new ConcatPackedProgram(tensors.map(t => t.shape), axis);\n            return this.compileAndRun(program, tensors);\n        }\n        // Any concat of n-dimensional tensors across any axis can be reduced to\n        // a concatenation of two-dimensional tensors across the axis 1 by first\n        // partitioning the axes of the original tensors into those less than the\n        // axis to be concatenated and the rest. Then reshape the tensors\n        // into a two-dimensional tensor by collapsing these two sets of axes and\n        // concatenate the resulting matrices across the axis 1, finally reshaping\n        // the result to have the proper shape.\n        const outShape = backend_util.computeOutShape(tensors.map(t => t.shape), axis);\n        const tensors2D = tensors.map(t => t.as2D(-1, util.sizeFromShape(t.shape.slice(axis))));\n        const program = new ConcatProgram(tensors2D.map(t => t.shape));\n        const res = this.compileAndRun(program, tensors2D);\n        return res.reshape(outShape);\n    }\n    neg(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.neg(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.NEG, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.NEG);\n        return this.compileAndRun(program, [x]);\n    }\n    batchMatMul(a, b, transposeA, transposeB) {\n        const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n        const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n        const sharedDim = transposeA ? a.shape[1] : a.shape[2];\n        const [batch, ,] = a.shape;\n        // Since the matrices are vectors, it is faster to call mul().sum()\n        // because sum() is O(sqrt(N)) due to divide-and-conquer.\n        if ((outerShapeA === 1 || outerShapeB === 1) &&\n            sharedDim > MATMUL_SHARED_DIM_THRESHOLD) {\n            if (transposeA) {\n                a = transpose(a, [0, 2, 1]);\n            }\n            if (transposeB) {\n                b = transpose(b, [0, 2, 1]);\n            }\n            const a3D = outerShapeB === 1 ? a : a.as3D(batch, sharedDim, 1);\n            const axis = outerShapeB === 1 ? 2 : 1;\n            const b3D = outerShapeB === 1 ? b.as3D(batch, 1, sharedDim) : b;\n            return this.multiply(a3D, b3D).sum(axis, true /* keepDims */);\n        }\n        const dtype = upcastType(a.dtype, b.dtype);\n        const program = new MatMulPackedProgram(a.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB);\n        return this.compileAndRun(program, [a, b], dtype);\n    }\n    fusedBatchMatMul({ a, b, transposeA, transposeB, bias, activation, preluActivationWeights }) {\n        const outerShapeA = transposeA ? a.shape[2] : a.shape[1];\n        const outerShapeB = transposeB ? b.shape[1] : b.shape[2];\n        const [batch, ,] = a.shape;\n        const dtype = upcastType(a.dtype, b.dtype);\n        const hasBias = bias != null;\n        const hasPreluActivationWeights = preluActivationWeights != null;\n        const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;\n        const program = new MatMulPackedProgram(a.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights);\n        const inputs = [a, b];\n        if (bias) {\n            inputs.push(bias);\n        }\n        if (preluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        return this.compileAndRun(program, inputs, dtype);\n    }\n    multiply(a, b) {\n        if (a.dtype === 'complex64') {\n            const aData = this.texData.get(a.dataId);\n            const bData = this.texData.get(b.dataId);\n            const realProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n            const imagProgram = new BinaryOpComplexProgram(binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n            const inputs = [\n                this.makeComplexComponentTensorInfo(a, aData.complexTensors.real),\n                this.makeComplexComponentTensorInfo(a, aData.complexTensors.imag),\n                this.makeComplexComponentTensorInfo(b, bData.complexTensors.real),\n                this.makeComplexComponentTensorInfo(b, bData.complexTensors.imag)\n            ];\n            const real = this.compileAndRun(realProgram, inputs);\n            const imag = this.compileAndRun(imagProgram, inputs);\n            const complex = this.complex(real, imag);\n            real.dispose();\n            imag.dispose();\n            return complex;\n        }\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.multiply(a, b);\n        }\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_gpu.MUL, a.dtype);\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], a.dtype);\n    }\n    batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n        const inputs = [x, mean, variance];\n        let offsetShape = null;\n        if (offset != null) {\n            offsetShape = offset.shape;\n            inputs.push(offset);\n        }\n        let scaleShape = null;\n        if (scale != null) {\n            scaleShape = scale.shape;\n            inputs.push(scale);\n        }\n        if (env().getBool('WEBGL_PACK_NORMALIZATION')) {\n            const batchNormPackedProgram = new BatchNormPackedProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n            return this.compileAndRun(batchNormPackedProgram, inputs);\n        }\n        const batchNormProgram = new BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n        return this.compileAndRun(batchNormProgram, inputs);\n    }\n    localResponseNormalization4D(x, radius, bias, alpha, beta) {\n        const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n            new LRNPackedProgram(x.shape, radius, bias, alpha, beta) :\n            new LRNProgram(x.shape, radius, bias, alpha, beta);\n        return this.compileAndRun(program, [x]);\n    }\n    LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n        const program = new LRNGradProgram(inputImage.shape, depthRadius, bias, alpha, beta);\n        return this.compileAndRun(program, [inputImage, outputImage, dy]);\n    }\n    tile(x, reps) {\n        if (x.dtype === 'string') {\n            const data = this.readSync(x.dataId);\n            const decodedData = data.map(d => util.decodeString(d));\n            const buf = buffer(x.shape, x.dtype, decodedData);\n            return tile(buf, reps);\n        }\n        const program = new TileProgram(x.shape, reps);\n        return this.compileAndRun(program, [x]);\n    }\n    pad(x, paddings, constantValue) {\n        const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new PadPackedProgram(x.shape, paddings, constantValue) :\n            new PadProgram(x.shape, paddings, constantValue);\n        return this.compileAndRun(program, [x]);\n    }\n    gather(x, indices, axis) {\n        if (this.shouldExecuteOnCPU([x, indices])) {\n            return this.cpuBackend.gather(x, indices, axis);\n        }\n        const program = new GatherProgram(x.shape, indices.size, axis);\n        return this.compileAndRun(program, [x, indices]);\n    }\n    batchToSpaceND(x, blockShape, crops) {\n        util.assert(x.rank <= 4, () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n        const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n        const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n        const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n        const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n        return transpose(x.reshape(reshaped), permuted)\n            .reshape(reshapedPermuted)\n            .slice(sliceBeginCoords, sliceSize);\n    }\n    spaceToBatchND(x, blockShape, paddings) {\n        util.assert(x.rank <= 4, () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n            'implemented yet');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const completePaddings = [[0, 0]];\n        completePaddings.push(...paddings);\n        for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n            completePaddings.push([0, 0]);\n        }\n        const paddedX = x.pad(completePaddings);\n        const reshapedPaddedShape = backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n        const permutedReshapedPaddedPermutation = backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);\n        const flattenShape = backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n        const paddedXT = transpose(paddedX.reshape(reshapedPaddedShape), permutedReshapedPaddedPermutation);\n        return reshape(paddedXT, flattenShape);\n    }\n    reduce(x, reduceType, dtype) {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize = backend_util.computeOptimalWindowSize(inSize);\n        const reduceInfo = { windowSize, inSize, batchSize };\n        const program = new ReduceProgram(reduceInfo, reduceType);\n        const output = this.compileAndRun(program, [x], dtype);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === 1) {\n            return output;\n        }\n        return this.reduce(output, reduceType, dtype);\n    }\n    argReduce(x, reduceType, bestIndicesA = null) {\n        let batchSize = x.shape[0];\n        let inSize = x.shape[1];\n        if (bestIndicesA != null) {\n            batchSize = bestIndicesA.shape[0];\n            inSize = bestIndicesA.shape[1];\n        }\n        const windowSize = backend_util.computeOptimalWindowSize(inSize);\n        const reduceInfo = { windowSize, inSize, batchSize };\n        const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n        const inputs = [x];\n        if (bestIndicesA != null) {\n            inputs.push(bestIndicesA);\n        }\n        const output = this.compileAndRun(program, inputs, 'int32');\n        // No need to run another GPGPU program.\n        if (output.shape[1] === 1) {\n            return output;\n        }\n        return this.argReduce(x, reduceType, output);\n    }\n    argReducePacked(x, reduceType, bestIndicesA = null) {\n        const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n        const inSize = inShape[inShape.length - 1];\n        const windowSize = backend_util.computeOptimalWindowSize(inSize);\n        const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);\n        const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n        const output = this.compileAndRun(program, inputs, 'int32');\n        if (output.rank === x.rank) {\n            return this.argReducePacked(x, reduceType, output);\n        }\n        return output;\n    }\n    sum(x, axes) {\n        backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = x.as2D(-1, inSize);\n        const outputDType = tf.sumOutType(x.dtype);\n        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);\n    }\n    prod(x, axes) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.prod(x, axes);\n        }\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = x.as2D(-1, inSize);\n        const outputDType = tf.sumOutType(x.dtype);\n        return this.reduce(a2D, 'prod', outputDType).reshape(outShape);\n    }\n    unsortedSegmentSum(x, segmentIds, numSegments) {\n        let axis = 0;\n        const permutation = backend_util.getAxesPermutation([axis], x.rank);\n        let permutedX = x;\n        if (permutation != null) {\n            permutedX = transpose(x, permutation);\n            axis = backend_util.getInnerMostAxes(1, x.rank)[0];\n        }\n        const outShape = segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n        const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n        const a2D = permutedX.as2D(-1, inSize);\n        const outputDType = tf.sumOutType(x.dtype);\n        let result = this.segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments)\n            .reshape(outShape);\n        if (permutation != null) {\n            result =\n                transpose(result, backend_util.getUndoAxesPermutation(permutation));\n        }\n        return result;\n    }\n    segOpCompute(x, segOpType, segmentIds, dtype, numSegments) {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize = segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n        const segOpInfo = { windowSize, inSize, batchSize, numSegments };\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = this.compileAndRun(program, [x, segmentIds], dtype);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n            return output;\n        }\n        segmentIds = range(0, numSegments).tile([inSize / windowSize]);\n        return this.segOpCompute(output, segOpType, segmentIds, dtype, numSegments);\n    }\n    argMinMaxReduce(x, axis, reduceType) {\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.rank);\n        if (!env().getBool('WEBGL_PACK_REDUCE') || x.rank <= 2) {\n            const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n            const inSize = util.sizeFromShape(reduceShape);\n            const a2D = x.as2D(-1, inSize);\n            return this.argReduce(a2D, reduceType).reshape(outShape);\n        }\n        return this.argReducePacked(x, reduceType);\n    }\n    argMin(x, axis) {\n        return this.argMinMaxReduce(x, axis, 'min');\n    }\n    argMax(x, axis) {\n        return this.argMinMaxReduce(x, axis, 'max');\n    }\n    cumsum(x, axis, exclusive, reverse) {\n        if (axis !== x.rank - 1) {\n            throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.rank - 1} ` +\n                `but got axis=${axis}`);\n        }\n        const size = x.shape[axis];\n        let result = x;\n        // Use cumsum parallel algorithm, ref:\n        // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n        for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n            const program = new CumSumProgram(x.shape, false, reverse);\n            const customSetup = program.getCustomSetupFunc(i);\n            const prevResult = result;\n            result = this.compileAndRun(program, [result], result.dtype, customSetup);\n            prevResult.dispose();\n        }\n        // For exclusive cumsum, shift the end result in the direction of sum and\n        // add 0 to the front index.\n        if (exclusive) {\n            const program = new CumSumProgram(x.shape, exclusive, reverse);\n            const prevResult = result;\n            result = this.compileAndRun(program, [result]);\n            prevResult.dispose();\n        }\n        return result;\n    }\n    equal(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.EQUAL, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    notEqual(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.NOT_EQUAL, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    less(a, b) {\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.less(a, b);\n        }\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    lessEqual(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.LESS_EQUAL, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    greater(a, b) {\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.greater(a, b);\n        }\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.GREATER, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    greaterEqual(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.GREATER_EQUAL, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    logicalNot(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);\n        return this.compileAndRun(program, [x]);\n    }\n    logicalAnd(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_AND, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    logicalOr(a, b) {\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.LOGICAL_OR, 'bool');\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], 'bool');\n    }\n    select(condition, a, b) {\n        const program = new SelectProgram(condition.rank, a.shape, a.rank);\n        return this.compileAndRun(program, [condition, a, b], upcastType(a.dtype, b.dtype));\n    }\n    where(condition) {\n        backend_util.warn('tf.where() in webgl locks the UI thread. ' +\n            'Call tf.whereAsync() instead');\n        const condVals = condition.dataSync();\n        return whereImpl(condition.shape, condVals);\n    }\n    topk(x, k, sorted) {\n        const xVals = x.dataSync();\n        return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n    }\n    min(x, axes) {\n        backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = x.as2D(-1, inSize);\n        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);\n    }\n    minimum(a, b) {\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.minimum(a, b);\n        }\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.MIN, a.shape, b.shape) :\n            new BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    }\n    mod(a, b) {\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.MOD, a.shape, b.shape) :\n            new BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    }\n    maximum(a, b) {\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.maximum(a, b);\n        }\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.MAX, a.shape, b.shape) :\n            new BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    }\n    all(x, axes) {\n        backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = x.as2D(-1, inSize);\n        return this.reduce(a2D, 'all', a2D.dtype).reshape(outShape);\n    }\n    any(x, axes) {\n        backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const inSize = util.sizeFromShape(reduceShape);\n        const a2D = x.as2D(-1, inSize);\n        return this.reduce(a2D, 'any', a2D.dtype).reshape(outShape);\n    }\n    floorDiv(a, b) {\n        const op = binaryop_gpu.INT_DIV;\n        const outputDtype = 'int32';\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_packed_gpu.INT_DIV, outputDtype);\n        }\n        const program = new BinaryOpProgram(op, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], outputDtype);\n    }\n    add(a, b) {\n        if (a.dtype === 'complex64' && b.dtype === 'complex64') {\n            return this.complexSeparableBinaryOp(a, b, binaryop_gpu.ADD);\n        }\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.add(a, b);\n        }\n        const dtype = upcastType(a.dtype, b.dtype);\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_gpu.ADD, dtype);\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], dtype);\n    }\n    packedUnaryOp(x, op, dtype) {\n        const program = new UnaryOpPackedProgram(x.shape, op);\n        return this.compileAndRun(program, [x], dtype);\n    }\n    packedBinaryOp(a, b, op, dtype, checkOutOfBounds = false) {\n        const program = new BinaryOpPackedProgram(op, a.shape, b.shape, checkOutOfBounds);\n        return this.compileAndRun(program, [a, b], dtype);\n    }\n    /**\n     * Computes a complex binary operation that can be decomposed into a simple\n     * binary operation on both the real and imagary parts.\n     */\n    complexSeparableBinaryOp(a, b, op) {\n        const aData = this.texData.get(a.dataId);\n        const bData = this.texData.get(b.dataId);\n        const [real, imag] = [\n            [aData.complexTensors.real, bData.complexTensors.real],\n            [aData.complexTensors.imag, bData.complexTensors.imag]\n        ].map(complexParts => {\n            const [aPart, bPart] = complexParts;\n            const aHandle = this.makeComplexComponentTensorInfo(a, aPart);\n            const bHandle = this.makeComplexComponentTensorInfo(b, bPart);\n            const program = new BinaryOpProgram(op, a.shape, b.shape);\n            return this.compileAndRun(program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n        });\n        const complex = this.complex(real, imag);\n        real.dispose();\n        imag.dispose();\n        return complex;\n    }\n    // Returns a TensorInfo with the complex shape and the dataId of the\n    // underlying part. We need to do this because a reshaped complex tensor is\n    // not reflected in its parts.\n    makeComplexComponentTensorInfo(complexTensor, complexPart) {\n        return {\n            dataId: complexPart.dataId,\n            dtype: complexPart.dtype,\n            shape: complexTensor.shape\n        };\n    }\n    addN(tensors) {\n        if (tensors.length === 1) {\n            return tensors[0];\n        }\n        // Limit the number of uploaded textures for optimization.\n        if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n            const midIndex = Math.floor(tensors.length / 2);\n            const leftSide = this.addN(tensors.slice(0, midIndex));\n            const rightSide = this.addN(tensors.slice(midIndex));\n            return this.addN([leftSide, rightSide]);\n        }\n        const dtype = tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n        const shapes = tensors.map(t => t.shape);\n        // We can make sure shapes are identical in op level.\n        const usePackedOp = env().getBool('WEBGL_PACK');\n        const program = usePackedOp ?\n            new AddNPackedProgram(tensors[0].shape, shapes) :\n            new AddNProgram(tensors[0].shape, shapes);\n        return this.compileAndRun(program, tensors, dtype);\n    }\n    subtract(a, b) {\n        if (a.dtype === 'complex64' && b.dtype === 'complex64') {\n            return this.complexSeparableBinaryOp(a, b, binaryop_gpu.SUB);\n        }\n        if (this.shouldExecuteOnCPU([a, b])) {\n            return this.cpuBackend.subtract(a, b);\n        }\n        const dtype = upcastType(a.dtype, b.dtype);\n        if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n            return this.packedBinaryOp(a, b, binaryop_gpu.SUB, a.dtype);\n        }\n        const program = new BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b], dtype);\n    }\n    pow(a, b) {\n        const usePackedOp = env().getBool('WEBGL_PACK_BINARY_OPERATIONS');\n        const program = usePackedOp ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.POW, a.shape, b.shape) :\n            new BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);\n        const dtype = upcastType(a.dtype, b.dtype);\n        return this.compileAndRun(program, [a, b], dtype);\n    }\n    ceil(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.ceil(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.CEIL, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.CEIL);\n        return this.compileAndRun(program, [x]);\n    }\n    floor(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.floor(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.FLOOR, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.FLOOR);\n        return this.compileAndRun(program, [x]);\n    }\n    sign(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SIGN);\n        return this.compileAndRun(program, [x]);\n    }\n    isNaN(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.IS_NAN);\n        return this.compileAndRun(program, [x], 'bool');\n    }\n    isInf(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.IS_INF);\n        return this.compileAndRun(program, [x], 'bool');\n    }\n    isFinite(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.IS_FINITE);\n        return this.compileAndRun(program, [x], 'bool');\n    }\n    round(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ROUND);\n        return this.compileAndRun(program, [x]);\n    }\n    exp(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.exp(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.EXP, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.EXP);\n        return this.compileAndRun(program, [x]);\n    }\n    expm1(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.expm1(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.EXPM1, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.EXPM1);\n        return this.compileAndRun(program, [x]);\n    }\n    softmax(logits, dim) {\n        const axes = util.parseAxisParam([dim], logits.shape);\n        // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n        // modularization.\n        const maxLogit = max(logits, axes);\n        const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n        const a = this.subtract(logits, maxLogit.reshape(expandedShape));\n        const b = this.exp(a);\n        const sumExp = this.sum(b, axes).reshape(expandedShape);\n        // TODO(annxingyuan): Call divImpl rather than op as part of softmax kernel\n        // modularization.\n        return div(b, sumExp);\n    }\n    log(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.log(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_packed_op.LOG, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.LOG);\n        return this.compileAndRun(program, [x]);\n    }\n    log1p(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.LOG1P);\n        return this.compileAndRun(program, [x]);\n    }\n    sqrt(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SQRT);\n        return this.compileAndRun(program, [x]);\n    }\n    rsqrt(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.rsqrt(x);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.RSQRT);\n        return this.compileAndRun(program, [x]);\n    }\n    reciprocal(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.RECIPROCAL);\n        return this.compileAndRun(program, [x]);\n    }\n    relu(x) {\n        let program;\n        if (env().getBool('WEBGL_PACK')) {\n            program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU);\n        }\n        else {\n            program = new UnaryOpProgram(x.shape, unary_op.RELU);\n        }\n        return this.compileAndRun(program, [x]);\n    }\n    relu6(x) {\n        let program;\n        if (env().getBool('WEBGL_PACK')) {\n            program = new UnaryOpPackedProgram(x.shape, unary_packed_op.RELU6);\n        }\n        else {\n            program = new UnaryOpProgram(x.shape, unary_op.RELU6);\n        }\n        return this.compileAndRun(program, [x]);\n    }\n    prelu(x, alpha) {\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.PRELU, x.shape, alpha.shape) :\n            new BinaryOpProgram(binaryop_gpu.PRELU, x.shape, alpha.shape);\n        return this.compileAndRun(program, [x, alpha]);\n    }\n    elu(x) {\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_packed_op.ELU, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.ELU);\n        return this.compileAndRun(program, [x]);\n    }\n    eluDer(dy, y) {\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.ELU_DER, dy.shape, y.shape) :\n            new BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);\n        return this.compileAndRun(program, [dy, y]);\n    }\n    selu(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SELU);\n        return this.compileAndRun(program, [x]);\n    }\n    int(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.TO_INT);\n        return this.compileAndRun(program, [x], 'int32');\n    }\n    clip(x, min, max) {\n        let program;\n        if (env().getBool('WEBGL_PACK_CLIP')) {\n            program = new ClipPackedProgram(x.shape);\n        }\n        else {\n            program = new ClipProgram(x.shape);\n        }\n        const customSetup = program.getCustomSetupFunc(min, max);\n        return this.compileAndRun(program, [x], null, customSetup);\n    }\n    abs(x) {\n        if (this.shouldExecuteOnCPU([x])) {\n            return this.cpuBackend.abs(x);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n        return this.compileAndRun(program, [x]);\n    }\n    complexAbs(x) {\n        const xData = this.texData.get(x.dataId);\n        const program = new ComplexAbsProgram(x.shape);\n        const inputs = [\n            this.makeComplexComponentTensorInfo(x, xData.complexTensors.real),\n            this.makeComplexComponentTensorInfo(x, xData.complexTensors.imag),\n        ];\n        return this.compileAndRun(program, inputs);\n    }\n    sigmoid(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SIGMOID);\n        return this.compileAndRun(program, [x]);\n    }\n    softplus(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SOFTPLUS);\n        return this.compileAndRun(program, [x]);\n    }\n    sin(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SIN);\n        return this.compileAndRun(program, [x]);\n    }\n    cos(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.COS);\n        return this.compileAndRun(program, [x]);\n    }\n    tan(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.TAN);\n        return this.compileAndRun(program, [x]);\n    }\n    asin(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ASIN);\n        return this.compileAndRun(program, [x]);\n    }\n    acos(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ACOS);\n        return this.compileAndRun(program, [x]);\n    }\n    atan(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ATAN);\n        return this.compileAndRun(program, [x]);\n    }\n    atan2(a, b) {\n        const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n            new BinaryOpPackedProgram(binaryop_packed_gpu.ATAN2, a.shape, b.shape) :\n            new BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    }\n    sinh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.SINH);\n        return this.compileAndRun(program, [x]);\n    }\n    cosh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.COSH);\n        return this.compileAndRun(program, [x]);\n    }\n    tanh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.TANH);\n        return this.compileAndRun(program, [x]);\n    }\n    asinh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ASINH);\n        return this.compileAndRun(program, [x]);\n    }\n    acosh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ACOSH);\n        return this.compileAndRun(program, [x]);\n    }\n    atanh(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ATANH);\n        return this.compileAndRun(program, [x]);\n    }\n    erf(x) {\n        const program = new UnaryOpProgram(x.shape, unary_op.ERF);\n        return this.compileAndRun(program, [x]);\n    }\n    step(x, alpha) {\n        const program = new UnaryOpProgram(x.shape, unary_op.STEP(alpha));\n        return this.compileAndRun(program, [x]);\n    }\n    conv2dByMatMul(x, filter, convInfo, bias, activation, preluActivationWeights) {\n        // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n        // result from 2D to 4D.\n        const xShape = x.shape;\n        const xTexData = this.texData.get(x.dataId);\n        const sharedMatMulDim = convInfo.inChannels;\n        const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n        const outerShapeFilter = convInfo.outChannels;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const transposeA = false;\n        const transposeB = false;\n        // TODO: Once reduction ops are packed, batchMatMul will always be packed\n        // and we can remove this condition.\n        const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&\n            sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n        const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;\n        if (batchMatMulWillBeUnpacked || !env().getBool('WEBGL_LAZILY_UNPACK') ||\n            !env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ||\n            !reshapeWillBeExpensive) {\n            const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n                xShape[0] * xShape[2] * xShape[3];\n            const xReshaped = this.reshape(x, [1, targetShape, convInfo.inChannels]);\n            const filterReshaped = this.reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n            return this.reshape(this.fusedBatchMatMul({\n                a: xReshaped,\n                b: filterReshaped,\n                transposeA,\n                transposeB,\n                bias,\n                activation,\n                preluActivationWeights\n            }), convInfo.outShape);\n        }\n        // Following optimization is specific to packed |x| with odd row count\n        // (For example, in channelLast mode, 'row count' refers to x.shape[2]):\n        // we avoid expensive packed 2x2 reshape by padding row count to next,\n        // even number. When x.shape[2] is odd, the result of packed batchMatMul is\n        // the same (has the same texture layout and and values in the texture) as\n        // it is for even x.shape[2] + 1. We make the odd-rows tensor to look like\n        // even-rows tensor before the operation and, after the batchMatMul,\n        // fix the even-rows result to have odd number of rows.\n        const targetShape = isChannelsLast ?\n            xShape[0] * xShape[1] * (xShape[2] + 1) :\n            xShape[0] * xShape[2] * (xShape[3] + 1);\n        const xReshaped = {\n            dataId: x.dataId,\n            shape: [1, targetShape, convInfo.inChannels],\n            dtype: x.dtype\n        };\n        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n        // Decrementing row count, after batchMatMul->...->compileProgram leads to\n        // invalid row count within the reference in GPGPUBinary.inShapeInfos.\n        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n        // in compileProgram method, but that would affect compilation of all\n        // programs - instead, provide a copy here, with even row count, before\n        // calling batchMatMul->...->compileProgram and after that, the original\n        // xTexData.shape is restored.\n        const originalXTexDataShape = xTexData.shape;\n        xTexData.shape = xTexData.shape.slice();\n        xTexData.shape[xTexData.shape.length - 2]++;\n        util.assert(webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);\n        const filterReshaped = this.reshape(filter, [1, convInfo.inChannels, convInfo.outChannels]);\n        const pointwiseConv = this.fusedBatchMatMul({\n            a: xReshaped,\n            b: filterReshaped,\n            transposeA,\n            transposeB,\n            bias,\n            activation,\n            preluActivationWeights\n        });\n        const pointwiseConvTexData = this.texData.get(pointwiseConv.dataId);\n        util.assert(pointwiseConvTexData.isPacked, () => 'batchMatMul result is expected to be packed');\n        // Restore the input shape to original.\n        xTexData.shape = originalXTexDataShape;\n        // Set the output shape - there is no need for expensive reshape as data\n        // layout is already correct.\n        pointwiseConvTexData.shape = convInfo.outShape;\n        return engine().makeTensorFromDataId(pointwiseConv.dataId, convInfo.outShape, pointwiseConv.dtype);\n    }\n    conv2dWithIm2Row(x, filter, convInfo, bias, activation, preluActivationWeights) {\n        // Rearranges conv2d input so each block to be convolved over forms the\n        // column of a new matrix with shape [filterWidth * filterHeight *\n        // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n        // output channel forms a row of a new matrix with shape [outChannels,\n        // filterWidth * filterHeight * inChannels]. The convolution is then\n        // computed by multiplying these matrices and reshaping the result.\n        const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const sharedDim = filterWidth * filterHeight * inChannels;\n        const numCols = outHeight * outWidth;\n        const x2ColShape = [sharedDim, numCols];\n        const transposeA = true;\n        const transposeB = false;\n        const xSqueezed = x.squeeze([0]);\n        const w2Row = filter.reshape([1, sharedDim, -1]);\n        const im2ColProgram = new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);\n        const im2Col = this.compileAndRun(im2ColProgram, [xSqueezed]).reshape([\n            1, x2ColShape[0], x2ColShape[1]\n        ]);\n        const hasBias = bias != null;\n        const hasPreluActivationWeights = preluActivationWeights != null;\n        const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;\n        const matmulProgram = new MatMulPackedProgram(im2Col.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights);\n        const inputs = [im2Col, w2Row];\n        if (bias) {\n            inputs.push(bias);\n        }\n        if (hasPreluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        const product = this.compileAndRun(matmulProgram, inputs);\n        if (isChannelsLast) {\n            return product.reshape([1, outHeight, outWidth, convInfo.outChannels]);\n        }\n        else {\n            return product.reshape([1, convInfo.outChannels, outHeight, outWidth]);\n        }\n    }\n    fusedConv2d({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n            convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n            convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n            (convInfo.padInfo.type === 'SAME' ||\n                convInfo.padInfo.type === 'VALID')) {\n            return this.conv2dByMatMul(input, filter, convInfo, bias, activation, preluActivationWeights);\n        }\n        if (env().getBool('WEBGL_CONV_IM2COL') && input.shape[0] === 1) {\n            return this.conv2dWithIm2Row(input, filter, convInfo, bias, activation, preluActivationWeights);\n        }\n        const hasBias = bias != null;\n        const hasPreluActivationWeights = preluActivationWeights != null;\n        const fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;\n        const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n        const inputs = [input, filter];\n        if (bias) {\n            inputs.push(bias);\n        }\n        if (preluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        return this.compileAndRun(program, inputs);\n    }\n    conv2d(x, filter, convInfo) {\n        if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n            convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n            convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n            (convInfo.padInfo.type === 'SAME' ||\n                convInfo.padInfo.type === 'VALID')) {\n            return this.conv2dByMatMul(x, filter, convInfo);\n        }\n        if (env().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) {\n            return this.conv2dWithIm2Row(x, filter, convInfo);\n        }\n        const program = new Conv2DProgram(convInfo);\n        return this.compileAndRun(program, [x, filter]);\n    }\n    conv2dDerInput(dy, filter, convInfo) {\n        const program = new Conv2DDerInputProgram(convInfo);\n        return this.compileAndRun(program, [dy, filter]);\n    }\n    conv2dDerFilter(x, dy, convInfo) {\n        const program = new Conv2DDerFilterProgram(convInfo);\n        return this.compileAndRun(program, [x, dy]);\n    }\n    fusedDepthwiseConv2D({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n            convInfo.strideWidth <= 2 &&\n            convInfo.outChannels / convInfo.inChannels === 1;\n        const fusedActivation = activation ?\n            mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n            null;\n        const inputs = [input, filter];\n        const hasBias = bias != null;\n        const hasPreluActivationWeights = preluActivationWeights != null;\n        if (hasBias) {\n            inputs.push(bias);\n        }\n        if (hasPreluActivationWeights) {\n            inputs.push(preluActivationWeights);\n        }\n        let program;\n        if (shouldPackDepthwiseConv) {\n            program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n            return this.compileAndRun(program, inputs);\n        }\n        program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);\n        return this.compileAndRun(program, inputs);\n    }\n    depthwiseConv2D(x, filter, convInfo) {\n        let program;\n        if (env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n            convInfo.strideWidth <= 2 &&\n            convInfo.outChannels / convInfo.inChannels === 1) {\n            program = new DepthwiseConvPacked2DProgram(convInfo);\n            return this.compileAndRun(program, [x, filter]);\n        }\n        program = new DepthwiseConv2DProgram(convInfo);\n        return this.compileAndRun(program, [x, filter]);\n    }\n    depthwiseConv2DDerInput(dy, filter, convInfo) {\n        const program = new DepthwiseConv2DDerInputProgram(convInfo);\n        return this.compileAndRun(program, [dy, filter]);\n    }\n    depthwiseConv2DDerFilter(x, dy, convInfo) {\n        const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n        return this.compileAndRun(program, [x, dy]);\n    }\n    conv3d(x, filter, convInfo) {\n        const program = new Conv3DProgram(convInfo);\n        return this.compileAndRun(program, [x, filter]);\n    }\n    conv3dDerInput(dy, filter, convInfo) {\n        const program = new Conv3DDerInputProgram(convInfo);\n        return this.compileAndRun(program, [dy, filter]);\n    }\n    conv3dDerFilter(x, dy, convInfo) {\n        const program = new Conv3DDerFilterProgram(convInfo);\n        return this.compileAndRun(program, [x, dy]);\n    }\n    maxPool(x, convInfo) {\n        const program = new Pool2DProgram(convInfo, 'max', false);\n        return this.compileAndRun(program, [x]);\n    }\n    avgPool(x, convInfo) {\n        const program = new Pool2DProgram(convInfo, 'avg', false);\n        return this.compileAndRun(program, [x], 'float32');\n    }\n    maxPoolBackprop(dy, x, y, convInfo) {\n        const getPositions = true;\n        const maxPoolPositionsProgram = new Pool2DProgram(convInfo, 'max', getPositions);\n        const maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);\n        const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n        const result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n        maxPoolPositions.dispose();\n        return result;\n    }\n    avgPoolBackprop(dy, x, convInfo) {\n        const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n        return this.compileAndRun(avgPoolBackpropProgram, [dy], x.dtype);\n    }\n    cast(x, dtype) {\n        return backend_util.castTensor(x, dtype, this);\n    }\n    unstack(x, axis) {\n        const num = x.shape[axis];\n        const outShape = new Array(x.rank - 1);\n        let outIndex = 0;\n        for (let i = 0; i < x.rank; i++) {\n            if (i !== axis) {\n                outShape[outIndex++] = x.shape[i];\n            }\n        }\n        const begin = new Array(x.rank).fill(0);\n        const size = x.shape.slice();\n        size[axis] = 1;\n        const res = new Array(num);\n        for (let i = 0; i < res.length; i++) {\n            begin[axis] = i;\n            res[i] = this.slice(x, begin, size).reshape(outShape);\n        }\n        return res;\n    }\n    avgPool3d(x, convInfo) {\n        const program = new Pool3DProgram(convInfo, 'avg', false);\n        return this.compileAndRun(program, [x], 'float32');\n    }\n    avgPool3dBackprop(dy, x, convInfo) {\n        const avgPool3dBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n        return this.compileAndRun(avgPool3dBackpropProgram, [dy], x.dtype);\n    }\n    maxPool3d(x, convInfo) {\n        const program = new Pool3DProgram(convInfo, 'max', false);\n        return this.compileAndRun(program, [x], 'float32');\n    }\n    maxPool3dBackprop(dy, x, y, convInfo) {\n        const getPositions = true;\n        const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, 'max', getPositions);\n        const maxPool3dPositions = this.compileAndRun(maxPool3dPositionsProgram, [x]);\n        const maxPool3dBackPropProgram = new MaxPool3DBackpropProgram(convInfo);\n        const result = this.compileAndRun(maxPool3dBackPropProgram, [dy, maxPool3dPositions], x.dtype);\n        maxPool3dPositions.dispose();\n        return result;\n    }\n    reshape(x, shape) {\n        const texData = this.texData.get(x.dataId);\n        if (texData.isPacked && !webgl_util.isReshapeFree(x.shape, shape) &&\n            !(texData.texture !== null &&\n                webgl_util.isReshapeFree(texData.shape, shape))) {\n            const info = this.packedReshape(x, shape);\n            return engine().makeTensorFromDataId(info.dataId, info.shape, info.dtype);\n        }\n        return backend_util.reshapeTensor(x, shape);\n    }\n    resizeBilinear(x, newHeight, newWidth, alignCorners) {\n        const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n            new ResizeBilinearPackedProgram(x.shape, newHeight, newWidth, alignCorners) :\n            new ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);\n        return this.compileAndRun(program, [x], 'float32');\n    }\n    resizeBilinearBackprop(dy, x, alignCorners) {\n        const program = new ResizeBilinearBackpropProgram(dy, x, alignCorners);\n        return this.compileAndRun(program, [dy]);\n    }\n    resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n        const program = new ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);\n        return this.compileAndRun(program, [x]);\n    }\n    resizeNearestNeighborBackprop(dy, x, alignCorners) {\n        const program = new ResizeNearestNeigborBackpropProgram(dy, x, alignCorners);\n        return this.compileAndRun(program, [dy]);\n    }\n    multinomial(logits, normalized, numSamples, seed) {\n        const probs = normalized ? logits : softmax(logits);\n        const batchSize = probs.shape[0];\n        const numOutcomes = probs.shape[1];\n        const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n        const customSetup = program.getCustomSetupFunc(seed);\n        return this.compileAndRun(program, [probs], 'int32', customSetup);\n    }\n    oneHot(indices, depth, onValue, offValue) {\n        const program = new OneHotProgram(indices.size, depth, onValue, offValue);\n        return this.compileAndRun(program, [indices]);\n    }\n    diag(x) {\n        const program = new DiagProgram(x.size);\n        return this.compileAndRun(program, [x]);\n    }\n    cropAndResize(image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        const program = new CropAndResizeProgram(image.shape, boxes.shape, cropSize, method, extrapolationValue);\n        return this.compileAndRun(program, [image, boxes, boxIndex], 'float32');\n    }\n    depthToSpace(x, blockSize, dataFormat) {\n        util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n        const batchSize = x.shape[0];\n        const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n        const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n        const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n        const outputHeight = inputHeight * blockSize;\n        const outputWidth = inputWidth * blockSize;\n        const outputDepth = inputDepth / (blockSize * blockSize);\n        const outputShape = (dataFormat === 'NHWC') ?\n            [batchSize, outputHeight, outputWidth, outputDepth] :\n            [batchSize, outputDepth, outputHeight, outputWidth];\n        const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n        return this.compileAndRun(program, [x]);\n    }\n    split(x, sizeSplits, axis) {\n        return split(x, sizeSplits, axis);\n    }\n    scatterND(indices, updates, shape) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(updates, indices, shape);\n        const flattenShape = [outputSize / sliceSize, sliceSize];\n        const flattenIndices = indices.reshape([numUpdates, sliceRank]);\n        const flattenX = updates.reshape([numUpdates, sliceSize]);\n        if (outputSize === 0) {\n            return backend_util.reshapeTensor(tensor([]), shape);\n        }\n        const defaultValue = scalar(0);\n        const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.rank, flattenX.rank, strides, flattenShape);\n        const res = this.compileAndRun(program, [flattenX, flattenIndices, defaultValue]);\n        return res.reshape(shape);\n    }\n    sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n        const { sliceRank, numUpdates, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n        const sumDupeIndices = false;\n        const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.rank, sparseValues.rank, strides, [outputSize, 1], sumDupeIndices);\n        const res = this.compileAndRun(program, [sparseValues, sparseIndices, defaultValue]);\n        return res.reshape(outputShape);\n    }\n    fft(x) {\n        const inverse = false;\n        return this.fftImpl(x, inverse);\n    }\n    ifft(x) {\n        const inverse = true;\n        return this.fftImpl(x, inverse);\n    }\n    fftImpl(x, inverse) {\n        const xData = this.texData.get(x.dataId);\n        const realProgram = new FFTProgram(fft_gpu.COMPLEX_FFT.REAL, x.shape, inverse);\n        const imagProgram = new FFTProgram(fft_gpu.COMPLEX_FFT.IMAG, x.shape, inverse);\n        const inputs = [\n            this.makeComplexComponentTensorInfo(x, xData.complexTensors.real),\n            this.makeComplexComponentTensorInfo(x, xData.complexTensors.imag),\n        ];\n        const real = this.compileAndRun(realProgram, inputs);\n        const imag = this.compileAndRun(imagProgram, inputs);\n        const complex = this.complex(real, imag).as2D(x.shape[0], x.shape[1]);\n        real.dispose();\n        imag.dispose();\n        return complex;\n    }\n    gatherND(x, indices) {\n        const indicesShape = indices.shape;\n        const sliceRank = indicesShape[indicesShape.length - 1];\n        const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(x, indices);\n        const flattenIndices = indices.reshape([numSlices, sliceRank]);\n        const flattenX = x.reshape([x.size / sliceSize, sliceSize]);\n        const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);\n        const res = this.compileAndRun(program, [flattenX, flattenIndices]);\n        return res.reshape(resultShape);\n    }\n    fill(shape, value, dtype) {\n        dtype = dtype || util.inferDtype(value);\n        if (dtype === 'string') {\n            // String type should be handled in CPU memory.\n            const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n            values.fill(value);\n            return engine().makeTensor(values, shape, dtype, this);\n        }\n        else {\n            const program = new FillProgram(shape, value);\n            const customSetup = program.getCustomSetupFunc(value);\n            return this.compileAndRun(program, [], dtype, customSetup);\n        }\n    }\n    onesLike(x) {\n        if (x.dtype === 'string') {\n            throw new Error('onesLike is not supported under string dtype');\n        }\n        else {\n            // TODO(cais, smilkov): Add WebGL shader for onesLike:\n            //   https://github.com/tensorflow/tfjs/issues/1293\n            return this.fill(x.shape, 1, x.dtype);\n        }\n    }\n    zerosLike(x) {\n        return this.fill(x.shape, x.dtype === 'string' ? '' : 0, x.dtype);\n    }\n    linspace(start, stop, num) {\n        // TODO: Use CPU implementation due to the precision problem in Safari.\n        return backend_util.linspaceImpl(start, stop, num);\n    }\n    makeTensorInfo(shape, dtype) {\n        const dataId = this.write(null /* values */, shape, dtype);\n        this.texData.get(dataId).usage = null;\n        return { dataId, shape, dtype };\n    }\n    makeOutput(shape, dtype) {\n        const { dataId } = this.makeTensorInfo(shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    unpackTensor(input) {\n        const program = new UnpackProgram(input.shape);\n        return this.runWebGLProgram(program, [input], input.dtype);\n    }\n    packTensor(input) {\n        const program = new PackProgram(input.shape);\n        const preventEagerUnpackingOutput = true;\n        return this.runWebGLProgram(program, [input], input.dtype, null /* customSetup */, preventEagerUnpackingOutput);\n    }\n    packedReshape(input, afterShape) {\n        const input3DShape = [\n            webgl_util.getBatchDim(input.shape),\n            ...webgl_util.getRowsCols(input.shape)\n        ];\n        const input3D = {\n            dtype: input.dtype,\n            shape: input3DShape,\n            dataId: input.dataId\n        };\n        const afterShapeAs3D = [\n            webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n        ];\n        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n        const preventEagerUnpackingOfOutput = true;\n        const output = this.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n    }\n    decode(dataId) {\n        const texData = this.texData.get(dataId);\n        const { isPacked, shape, dtype } = texData;\n        const shapeAs3D = webgl_util.getShapeAs3D(shape);\n        let program;\n        if (isPacked) {\n            program = new DecodeMatrixPackedProgram(shapeAs3D);\n        }\n        else {\n            program = new DecodeMatrixProgram(shapeAs3D);\n        }\n        const preventEagerUnpackingOfOutput = true;\n        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dtype, shape, dataId: out.dataId };\n    }\n    runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        const output = this.makeTensorInfo(program.outputShape, outputDtype);\n        const outData = this.texData.get(output.dataId);\n        if (program.packedOutput) {\n            outData.isPacked = true;\n        }\n        if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n            const texelShape = tex_util.getDenseTexShape(program.outputShape);\n            // For a densely packed output, we explicitly set texShape\n            // so it doesn't get assigned later according to our typical packing\n            // scheme wherein a single texel can only contain values from adjacent\n            // rows/cols.\n            outData.texShape = texelShape.map(d => d * 2);\n        }\n        if (program.outTexUsage != null) {\n            outData.usage = program.outTexUsage;\n        }\n        if (util.sizeFromShape(output.shape) === 0) {\n            // Short-circuit the computation since the result is empty (has 0 in its\n            // shape).\n            outData.values =\n                util.getTypedArrayFromDType(output.dtype, 0);\n            return output;\n        }\n        const dataToDispose = [];\n        const inputsData = inputs.map(input => {\n            if (input.dtype === 'complex64') {\n                throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` +\n                    `dtypes, please separate the program into real and imaginary ` +\n                    `parts.`);\n            }\n            let texData = this.texData.get(input.dataId);\n            if (texData.texture == null) {\n                if (!program.packedInputs &&\n                    util.sizeFromShape(input.shape) <=\n                        env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n                    // Upload small tensors that live on the CPU as uniforms, not as\n                    // textures. Do this only when the environment supports 32bit floats\n                    // due to problems when comparing 16bit floats with 32bit floats.\n                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n                    // possible for packed shaders to sample from uniforms.\n                    return {\n                        shape: input.shape,\n                        texData: null,\n                        isUniform: true,\n                        uniformValues: texData.values\n                    };\n                }\n                // This ensures that if a packed program's inputs have not yet been\n                // uploaded to the GPU, they get uploaded as packed right off the bat.\n                if (program.packedInputs) {\n                    texData.isPacked = true;\n                    texData.shape = input.shape;\n                }\n            }\n            else if (!!texData.isPacked !== !!program.packedInputs) {\n                input = texData.isPacked ? this.unpackTensor(input) :\n                    this.packTensor(input);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n            }\n            else if (texData.isPacked &&\n                !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n                // This is a special case where a texture exists for a tensor\n                // but the shapes are incompatible (due to packing constraints) because\n                // the tensor did not have a chance to go through the packed reshape\n                // shader. This only happens when we reshape the *same* tensor to form\n                // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n                // case will disappear once packed uploading is the default.\n                const savedInput = input;\n                const targetShape = input.shape;\n                input.shape = texData.shape;\n                input = this.packedReshape(input, targetShape);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n                savedInput.shape = targetShape;\n            }\n            this.uploadToGPU(input.dataId);\n            return { shape: input.shape, texData, isUniform: false };\n        });\n        this.uploadToGPU(output.dataId);\n        const outputData = { shape: output.shape, texData: outData, isUniform: false };\n        const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n        const binary = this.getAndSaveBinary(key, () => {\n            return gpgpu_math.compileProgram(this.gpgpu, program, inputsData, outputData);\n        });\n        const shouldTimeProgram = this.activeTimers != null;\n        let query;\n        if (shouldTimeProgram) {\n            query = this.startTimer();\n        }\n        gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);\n        dataToDispose.forEach(info => this.disposeData(info.dataId));\n        if (shouldTimeProgram) {\n            query = this.endTimer(query);\n            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });\n        }\n        if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n            preventEagerUnpackingOfOutput === false) {\n            const unpacked = this.unpackTensor(output);\n            this.disposeData(output.dataId);\n            return unpacked;\n        }\n        return output;\n    }\n    compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        outputDtype = outputDtype || inputs[0].dtype;\n        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);\n        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    }\n    getAndSaveBinary(key, getBinary) {\n        if (!(key in this.binaryCache)) {\n            this.binaryCache[key] = getBinary();\n        }\n        return this.binaryCache[key];\n    }\n    getTextureManager() {\n        return this.textureManager;\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        // Avoid disposing the compiled webgl programs during unit testing because\n        // it slows down test execution.\n        if (!env().getBool('IS_TEST')) {\n            const allKeys = Object.keys(this.binaryCache);\n            allKeys.forEach(key => {\n                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n                delete this.binaryCache[key];\n            });\n        }\n        this.textureManager.dispose();\n        if (this.canvas != null &&\n            (typeof (HTMLCanvasElement) !== 'undefined' &&\n                this.canvas instanceof HTMLCanvasElement)) {\n            this.canvas.remove();\n        }\n        else {\n            this.canvas = null;\n        }\n        if (this.gpgpuCreatedLocally) {\n            this.gpgpu.program = null;\n            this.gpgpu.dispose();\n        }\n        this.disposed = true;\n    }\n    floatPrecision() {\n        if (this.floatPrecisionValue == null) {\n            this.floatPrecisionValue = tidy(() => {\n                if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n                    // Momentarily switching DEBUG flag to false so we don't throw an\n                    // error trying to upload a small value.\n                    const debugFlag = env().getBool('DEBUG');\n                    env().set('DEBUG', false);\n                    const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n                    env().set('DEBUG', debugFlag);\n                    if (underflowCheckValue > 0) {\n                        return 32;\n                    }\n                }\n                return 16;\n            });\n        }\n        return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    uploadToGPU(dataId) {\n        const texData = this.texData.get(dataId);\n        const { shape, dtype, values, texture, usage, isPacked } = texData;\n        if (texture != null) {\n            // Array is already on GPU. No-op.\n            return;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let texShape = texData.texShape;\n        if (texShape == null) {\n            texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n            texData.texShape = texShape;\n        }\n        if (values != null) {\n            const shapeAs3D = webgl_util.getShapeAs3D(shape);\n            let program;\n            let width = texShape[1], height = texShape[0];\n            const isByteArray = values instanceof Uint8Array;\n            if (isPacked) {\n                [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n                program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            else {\n                program =\n                    new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n            if (isByteArray) {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.PIXELS;\n            }\n            else {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.UPLOAD;\n            }\n            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n            // We want the output to remain packed regardless of the value of\n            // WEBGL_PACK.\n            const preventEagerUnpacking = true;\n            const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n            // Have the original texture assume the identity of the encoded output.\n            const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n            texData.texture = outputTexData.texture;\n            texData.texShape = outputTexData.texShape;\n            texData.isPacked = outputTexData.isPacked;\n            texData.usage = outputTexData.usage;\n            this.disposeData(tempDenseInputHandle.dataId);\n            this.texData.delete(encodedOutputTarget.dataId);\n            // Once uploaded, don't store the values on cpu.\n            texData.values = null;\n            if (shouldTimeProgram) {\n                this.uploadWaitMs += util.now() - start;\n            }\n        }\n        else {\n            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n            texData.texture = newTexture;\n        }\n    }\n    convertAndCacheOnCPU(dataId, float32Values) {\n        const texData = this.texData.get(dataId);\n        const { dtype } = texData;\n        this.releaseGPUData(dataId);\n        if (float32Values != null) {\n            texData.values = float32ToTypedArray(float32Values, dtype);\n        }\n        return texData.values;\n    }\n    acquireTexture(texShape, texType, dtype, isPacked) {\n        this.numBytesInGPU += this.computeBytes(texShape, dtype);\n        if (!this.warnedAboutMemory &&\n            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = true;\n            console.warn(`High memory usage in GPU: ${mb} MB, ` +\n                `most likely due to a memory leak`);\n        }\n        return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n    computeBytes(shape, dtype) {\n        return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n}\nfunction float32ToTypedArray(a, dtype) {\n    if (dtype === 'float32' || dtype === 'complex64') {\n        return a;\n    }\n    else if (dtype === 'int32' || dtype === 'bool') {\n        const result = (dtype === 'int32') ? new Int32Array(a.length) :\n            new Uint8Array(a.length);\n        for (let i = 0; i < result.length; ++i) {\n            result[i] = Math.round(a[i]);\n        }\n        return result;\n    }\n    else {\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\n//# sourceMappingURL=backend_webgl.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { slice } from '../ops/slice';\n// TODO(annxingyuan): Use this helper in WASM Split kernel once intermediate\n// kernels have been modularized in WebGL and CPU\n// https://github.com/tensorflow/tfjs/issues/2822.\n/** Shared implementation of the split kernel across WebGL and CPU. */\nexport function split(x, sizeSplits, axis) {\n    const begin = new Array(x.rank).fill(0);\n    const size = x.shape.slice();\n    return sizeSplits.map(s => {\n        const sliceSize = [...size];\n        sliceSize[axis] = s;\n        const sliceT = slice(x, begin, sliceSize);\n        begin[axis] += s;\n        return sliceT;\n    });\n}\n//# sourceMappingURL=split_shared.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\nimport { buffer } from '../ops/buffer';\nexport function tile(xBuf, reps) {\n    const newShape = new Array(xBuf.rank);\n    for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = xBuf.shape[i] * reps[i];\n    }\n    const result = buffer(newShape, xBuf.dtype);\n    for (let i = 0; i < result.values.length; ++i) {\n        const newLoc = result.indexToLoc(i);\n        const originalLoc = new Array(xBuf.rank);\n        for (let j = 0; j < originalLoc.length; j++) {\n            originalLoc[j] = newLoc[j] % xBuf.shape[j];\n        }\n        const originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n    }\n    return result.toTensor();\n}\n//# sourceMappingURL=tile_impl.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/** An implementation of the TopK kernel shared between webgl and cpu. */\nimport { tensor } from '../ops/tensor';\nimport { getTypedArrayFromDType } from '../util';\nexport function topkImpl(x, xShape, xDtype, k, sorted) {\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    const lastDim = xShape[xShape.length - 1];\n    const [batch, size] = [x.length / lastDim, lastDim];\n    const allTopKVals = getTypedArrayFromDType(xDtype, batch * k);\n    const allTopKIndices = getTypedArrayFromDType('int32', batch * k);\n    for (let b = 0; b < batch; b++) {\n        const offset = b * size;\n        const vals = x.subarray(offset, offset + size);\n        const valAndInd = [];\n        for (let i = 0; i < vals.length; i++) {\n            valAndInd.push({ value: vals[i], index: i });\n        }\n        valAndInd.sort((a, b) => b.value - a.value);\n        const outOffset = b * k;\n        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n        for (let i = 0; i < k; i++) {\n            topKVals[i] = valAndInd[i].value;\n            topKIndices[i] = valAndInd[i].index;\n        }\n    }\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    const outputShape = xShape.slice();\n    outputShape[outputShape.length - 1] = k;\n    return [\n        tensor(allTopKVals, outputShape, xDtype),\n        tensor(allTopKIndices, outputShape, 'int32')\n    ];\n}\n//# sourceMappingURL=topk_impl.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/** An implementation of the Where kernel shared between cpu and webgl */\nimport { buffer } from '../ops/buffer';\nexport function whereImpl(condShape, condVals) {\n    const indices = [];\n    for (let i = 0; i < condVals.length; i++) {\n        if (condVals[i]) {\n            indices.push(i);\n        }\n    }\n    const inBuffer = buffer(condShape, 'int32');\n    const out = buffer([indices.length, condShape.length], 'int32');\n    for (let i = 0; i < indices.length; i++) {\n        const loc = inBuffer.indexToLoc(indices[i]);\n        const offset = i * condShape.length;\n        out.values.set(loc, offset);\n    }\n    return out.toTensor();\n}\n//# sourceMappingURL=where_impl.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\nimport { makeZerosTypedArray } from '../util';\nimport { tensor1d } from './tensor1d';\nimport { zeros } from './zeros';\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n */\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\nexport function range(start, stop, step = 1, dtype = 'float32') {\n    if (step === 0) {\n        throw new Error('Cannot have a step of zero');\n    }\n    const forward = () => {\n        const sameStartStop = start === stop;\n        const increasingRangeNegativeStep = start < stop && step < 0;\n        const decreasingRangePositiveStep = stop < start && step > 1;\n        if (sameStartStop || increasingRangeNegativeStep ||\n            decreasingRangePositiveStep) {\n            return zeros([0], dtype);\n        }\n        const numElements = Math.abs(Math.ceil((stop - start) / step));\n        const values = makeZerosTypedArray(numElements, dtype);\n        if (stop < start && step === 1) {\n            // Auto adjust the step's sign if it hasn't been set\n            // (or was set to 1)\n            step = -1;\n        }\n        values[0] = start;\n        for (let i = 1; i < values.length; i++) {\n            values[i] = values[i - 1] + step;\n        }\n        return tensor1d(values, dtype);\n    };\n    const attrs = { start, stop, step, dtype };\n    return ENGINE.runKernelFunc(forward, {} /* inputs */, null /* grad */, Range, attrs);\n}\n//# sourceMappingURL=range.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// base.ts is the webgl backend without auto kernel registration.\nimport { device_util, registerBackend } from '@tensorflow/tfjs-core';\nimport { MathBackendWebGL } from './backend_webgl';\nexport { version as version_webgl } from './version';\nif (device_util.isBrowser()) {\n    registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n// Export webgl utilities\nexport * from './webgl';\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport { forceHalfFloat } from './webgl';\nexport const webgl = { forceHalfFloat };\n//# sourceMappingURL=base.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function maxImpl(aVals, reduceSize, outShape, dtype) {\n    const vals = util.getTypedArrayFromDType(dtype, util.sizeFromShape(outShape));\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let max = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            if (value > max) {\n                max = value;\n            }\n        }\n        vals[i] = max;\n    }\n    return vals;\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function transposeImpl(xVals, xShape, dtype, perm, newShape) {\n    const xRank = xShape.length;\n    const xSize = util.sizeFromShape(xShape);\n    const xStrides = util.computeStrides(xShape);\n    const newStrides = util.computeStrides(newShape);\n    const result = util.getTypedArrayFromDType(dtype, util.sizeFromShape(newShape));\n    for (let i = 0; i < xSize; ++i) {\n        const loc = util.indexToLoc(i, xRank, xStrides);\n        // Permute location.\n        const newLoc = new Array(loc.length);\n        for (let i = 0; i < newLoc.length; i++) {\n            newLoc[i] = loc[perm[i]];\n        }\n        const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n        result[newIndex] = xVals[i];\n    }\n    return result;\n}\n//# sourceMappingURL=Transpose_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\nconst { maxImpl: maxImplCPU, transposeImpl: transposeImplCPU } = shared;\nexport { maxImplCPU, transposeImplCPU };\n//# sourceMappingURL=shared.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ReshapePackedProgram } from '../reshape_packed_gpu';\nimport { getBatchDim, getRowsCols, isReshapeFree } from '../webgl_util';\nfunction packedReshape(input, afterShape, backend) {\n    const input3DShape = [getBatchDim(input.shape),\n        ...getRowsCols(input.shape)];\n    const input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n    };\n    const afterShapeAs3D = [getBatchDim(afterShape),\n        ...getRowsCols(afterShape)];\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const output = backend.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n}\nexport function reshape(x, afterShape, backend) {\n    const xTexData = backend.texData.get(x.dataId);\n    if (xTexData.isPacked && !isReshapeFree(x.shape, afterShape) &&\n        !(xTexData.texture !== null &&\n            isReshapeFree(xTexData.shape, afterShape))) {\n        return packedReshape(x, afterShape, backend);\n    }\n    return { dataId: x.dataId, shape: afterShape, dtype: x.dtype };\n}\n//# sourceMappingURL=reshape.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { reduce } from '../kernel_utils/reduce';\nimport { reshape } from '../kernel_utils/reshape';\nexport function maxImpl(x, reduceShape, outShape, backend) {\n    const inSize = util.sizeFromShape(reduceShape);\n    const xSize = util.sizeFromShape(x.shape);\n    const batchSize = xSize / inSize;\n    const reshapedInput = reshape(x, [batchSize, inSize], backend);\n    const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n    if (reshapedInput.dataId !== x.dataId) {\n        // dispose the output of the packed reshape.\n        backend.disposeData(reshapedInput.dataId);\n    }\n    return reshape(reduced, outShape, backend);\n}\n//# sourceMappingURL=Max_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { ReduceProgram } from '../reduce_gpu';\nexport function reduce(x, dtype, reductionType, backend) {\n    const [batchSize, inSize] = x.shape;\n    const windowSize = backend_util.computeOptimalWindowSize(inSize);\n    const reduceInfo = { windowSize, inSize, batchSize };\n    const program = new ReduceProgram(reduceInfo, reductionType);\n    const output = backend.runWebGLProgram(program, [x], dtype);\n    if (output.shape[1] === 1) {\n        return output;\n    }\n    return reduce(output, dtype, reductionType, backend);\n}\n//# sourceMappingURL=reduce.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposeProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const switched = getSwitchedCoords(newDim);\n        this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n    }\n}\nfunction getSwitchedCoords(newDim) {\n    const rank = newDim.length;\n    if (rank > 6) {\n        throw Error(`Transpose for rank ${rank} is not yet supported`);\n    }\n    const originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n    const switchedCoords = new Array(rank);\n    for (let i = 0; i < newDim.length; i++) {\n        switchedCoords[newDim[i]] = originalOrder[i];\n    }\n    return switchedCoords.join();\n}\n//# sourceMappingURL=transpose_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getVecChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposePackedProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        if (this.rank > 6) {\n            throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);\n        }\n        const dtype = getCoordsDataType(this.rank);\n        const outputOrder = getVecChannels('rc', this.rank);\n        const switchedOrder = new Array(this.rank);\n        for (let i = 0; i < newDim.length; i++) {\n            switchedOrder[newDim[i]] = outputOrder[i];\n        }\n        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n        this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n    }\n}\n//# sourceMappingURL=transpose_packed_gpu.js.map","\nimport {registerKernel, registerGradient} from '@tensorflow/tfjs-core/dist/base';\nimport '@tensorflow/tfjs-core/dist/base_side_effects';\nexport * from '@tensorflow/tfjs-core/dist/base';\n  \nexport * from '@tensorflow/tfjs-converter';\n\n//backend = webgl\nexport * from '@tensorflow/tfjs-backend-webgl/dist/base';\nimport {maxConfig as Max_webgl} from '@tensorflow/tfjs-backend-webgl/dist/kernels/Max';\nregisterKernel(Max_webgl);","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Max } from '@tensorflow/tfjs-core';\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { maxImplCPU } from '../kernel_utils/shared';\nimport { maxImpl } from './Max_impl';\nimport { transposeImpl, transposeImplCPU } from './Transpose_impl';\nexport const maxConfig = {\n    kernelName: Max,\n    backendName: 'webgl',\n    kernelFunc: ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        const { reductionIndices, keepDims } = attrs;\n        const webglBackend = backend;\n        const xRank = x.shape.length;\n        const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n        let axes = origAxes;\n        const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n        const maxInputIsTransposed = permutedAxes != null;\n        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n        let maxInput = x;\n        if (maxInputIsTransposed) {\n            if (shouldExecuteOnCPU) {\n                const xTexData = webglBackend.texData.get(maxInput.dataId);\n                const values = xTexData.values;\n                const newShape = new Array(xRank);\n                for (let i = 0; i < newShape.length; i++) {\n                    newShape[i] = x.shape[permutedAxes[i]];\n                }\n                const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n                maxInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n                const maxInputData = webglBackend.texData.get(maxInput.dataId);\n                maxInputData.values = maxInputValues;\n            }\n            else {\n                maxInput = transposeImpl(x, permutedAxes, webglBackend);\n            }\n            axes = backend_util.getInnerMostAxes(axes.length, xRank);\n        }\n        backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n        const [maxOutShape, reduceShape] = backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n        let outShape = maxOutShape;\n        if (keepDims) {\n            // rather than reshape at the end, set the target shape here.\n            outShape = backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n        }\n        let out;\n        if (shouldExecuteOnCPU) {\n            const xTexData = webglBackend.texData.get(maxInput.dataId);\n            const values = xTexData.values;\n            const outValues = maxImplCPU(values, util.sizeFromShape(reduceShape), outShape, x.dtype);\n            out = webglBackend.makeTensorInfo(outShape, x.dtype);\n            const outData = webglBackend.texData.get(out.dataId);\n            outData.values = outValues;\n        }\n        else {\n            out = maxImpl(maxInput, reduceShape, outShape, webglBackend);\n        }\n        if (maxInputIsTransposed) {\n            webglBackend.disposeData(maxInput.dataId);\n        }\n        return out;\n    }\n};\n//# sourceMappingURL=Max.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { transposeImplCPU } from '../kernel_utils/shared';\nimport { TransposeProgram } from '../transpose_gpu';\nimport { TransposePackedProgram } from '../transpose_packed_gpu';\nexport function transposeImpl(x, perm, backend) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new TransposePackedProgram(x.shape, perm) :\n        new TransposeProgram(x.shape, perm);\n    return backend.runWebGLProgram(program, [x], x.dtype);\n}\nexport { transposeImplCPU };\n//# sourceMappingURL=Transpose_impl.js.map","import * as tf from './custom_tfjs_webgl.js';\n\nconst res = tf.max([1, 2, 3, 4]);\nconsole.log('Max result', res.dataSync());"],"names":["Environment","[object Object]","global","this","flags","flagRegistry","urlFlags","populateURLFlags","platformName","platform","console","warn","flagName","evaluationFn","setHook","flagValue","set","evaluateFlag","Promise","Error","get","features","value","Object","assign","location","search","urlParams","queryString","params","replace","s","t","name","decodeURIComponent","decodeParam","join","getQueryParams","split","forEach","keyValue","key","toLowerCase","parseValue","env","ENV","globalNameSpace","getGlobalNamespace","ns","window","process","self","getGlobal","init","globalMap","_tfGlobals","Map","getGlobalMap","has","singleton","kernelRegistry","gradRegistry","getGradient","kernelName","getKernelsForBackend","backendName","it","entries","result","done","next","config","backend","push","makeKey","nearestLargerEven","val","assert","expr","msg","flatten","arr","skipTypedArray","Array","isArray","isTypedArray","i","length","sizeFromShape","shape","size","arraysEqual","n1","n2","isInt","a","sizeToSquarishShape","width","Math","ceil","sqrt","rightPad","repeat","repeatedTry","checkFn","delayFn","counter","maxCounter","resolve","reject","tryCount","tryFn","nextBackoff","setTimeout","parseAxisParam","axis","rank","map","concat","every","ax","squeezeShape","newShape","keptDims","isEmptyArray","axes","sort","j","getTypedArrayFromDType","dtype","values","Float32Array","Int32Array","Uint8Array","getArrayFromDType","bytesPerElement","isString","String","inferDtype","isBoolean","isFunction","f","constructor","call","apply","nearestDivisor","start","computeStrides","strides","toTypedArray","getBool","vals","num","isNaN","isFinite","checkConversionForErrors","noConversionNeeded","bool","round","toNestedArray","reduce","acc","c","createNestedArray","offset","ret","d","rest","slice","len","makeZerosTypedArray","now","assertNonNegativeIntegerDimensions","dimSize","Number","isInteger","decodeString","bytes","encoding","decode","locToIndex","locs","index","indexToLoc","floor","Profiler","backendTimer","logger","Logger","inputs","outputs","timer","time","r","data","then","tensorVals","checkComputationForErrors","timeMs","timing","kernelMs","extraInfo","getExtraProfileInfo","kernelProfile","all","valueContainer","logKernelProfile","util.rightPad","paddedName","toString","inputShapesDescription","inputShape","inputRank","log","tensorToString","verbose","padPerCol","n","numCols","fill","valuesOrTuples","createComplexTuples","row","max","valToString","computeMaxSizePerColumn","valsLines","subTensorToString","isLast","storagePerElement","boolNumToString","firstValsSize","firstVals","from","lastVals","x","subshape","substrides","stride","lines","end","sep","newLineSep","l","pad","valStr","parseFloat","toFixed","v","complexTuples","TensorBuffer","util.sizeFromShape","util.assert","util.getArrayFromDType","loc","trackerFn","makeTensor","Tensor","dataId","id","kept","isDisposedInternal","rankType","buffer","dataSync","throwIfDisposed","read","b","util.decodeString","_a","readSync","isDisposed","disposeTensor","print","clone","cast","trainable","makeVariable","defineProperty","Symbol","hasInstance","instance","Variable","initialValue","tensorId","super","newValue","util.arraysEqual","incRef","disposeVariable","Rank","UpcastInt32AndMap","UpcastBoolAndMap","UpcastFloat32AndMap","UpcastComplex64AndMap","Function","upcastTypeMap","float32","int32","complex64","upcastType","typeA","typeB","sumOutType","type","makeTypesMatch","getTensorsInContainer","list","walkTensorContainer","container","seen","obj","iterable","k","add","Set","EngineState","registeredVariables","nextTapeNodeId","numBytes","numTensors","numStringTensors","numDataBuffers","gradientDepth","kernelDepth","scopeStack","numDataMovesStack","nextScopeId","tensorInfo","WeakMap","profiling","activeProfile","newBytes","newTensors","peakBytes","kernels","variableName","dispose","Engine","registry","registryFactory","pendingBackendInitId","state","pendingBackendInit","backendInstance","sortedBackends","getSortedBackends","initializeBackend","success","setBackend","asyncInit","initializeBackendsAndReturnBest","keys","factory","priority","setupRegisteredKernels","profiler","kernel","setupFunc","disposeFunc","registryFactoryEntry","promiseId","catch","err","stack","message","disposeRegisteredKernels","info","srcBackend","disposeData","move","shouldCheckForMemLeaks","nameOrFn","fn","scopedRun","startScope","endScope","error","res","ex","nextTensorId","nextVariableId","y","makeTensorFromDataId","addTapeNode","activeScope","dy","gradInputs","attrs","ENGINE","runKernelFunc","inputsToSave","outputsToSave","numDataIdsBefore","outInfos","numDataIdsAfter","numDataIds","numOutputDataIds","numMoves","dataIdsLeaked","forwardFunc","backwardsFunc","saved","isTapeOn","startingBytecount","startingNumTensors","kernelFunc","getKernel","out","checkKernelForMemLeak","outTensors","tensorsToSave","getTensorsForGradient","outsToSave","filter","_","saveTensorsForBackwardMode","saveFunc","tensors","tensor","keep","tidy","outs","profileKernel","bytesAdded","totalBytesSnapshot","tensorsAdded","totalTensorsSnapshot","inputShapes","outputShapes","item","kernelTimeMs","gradConfig","inputTensorsToSave","saveAllInputs","inputName","outputTensorsToSave","backendVals","util.isString","encode","util.encodeString","write","bytesFromStringArray","refCount","util.bytesPerElement","track","delete","varName","memory","unreliable","reasons","query","startBytes","startNumTensors","gradientsFunc","tapeNode","gradFunc","gradient","dys","output","util.makeZerosTypedArray","activeTape","scopeInfo","tensorsToTrackInParent","tensorsToTrackInParentSet","oldScope","pop","scopeId","xs","allowNoGradients","startTape","endTape","filteredTape","tape","tensorsFromX","nodesFromX","node","nodeInputs","input","anyInputFromX","tensorsLeadToY","nodesToY","prunedInputs","nodeInput","prunedNode","getFilteredNodesXToY","accumulatedGradientMap","array","makeOnesTypedArray","ones","tensorAccumulatedGradientMap","o","gradTensor","inputGradients","dx","curGradient","backpropagateGradients","grads","util.isFunction","inputMap","save","gradRes","gradMap","grad","timingInfo","wallMs","reset","_tfengine","environment","getOrMakeEngine","inferShape","firstElem","deepAssertShapeConsistency","indices","subShape","assertDtype","expectedDtype","actualDType","argName","functionName","convertToTensor","parseAsDtype","inferredDtype","indexOf","inferredShape","op","opName","endsWith","substring","f2","args","configurable","complex","complex_","real","imag","$real","$imag","shapeA","shapeB","errorMessagePrefix","util.assertShapesMatch","providedSize","inferredSize","inferred","flatDimsDontMatch","cast_","$x","util.isValidDtype","reshape","reshape_","shapeProd","implicitIdx","util.inferFromImplicitShape","transpose","transpose_","perm","reverse","axesAreInnerMostDims","combineLocations","outputLoc","reduceLoc","outIdx","reduceIdx","dim","computeOutAndReduceShapes","aShape","outShape","expandShapeToKeepDim","assertAxesAreInnerMostDims","getAxesPermutation","getUndoAxesPermutation","getInnerMostAxes","numAxes","max_","keepDims","reductionIndices","util.parseAxisParam","permutedAxes","axis_util.getAxesPermutation","maxInput","axis_util.getInnerMostAxes","expandedShape","axis_util.expandShapeToKeepDim","prepareAndValidate","indicesShape","sliceRank","nResult","resultShape","sliceSize","validateUpdateShape","updates","sliceDim","batchDim","shapeError","calculateShapes","indicesRank","totalNd","safeSliceDim","numUpdates","outputSize","engine","floorDiv","floorDiv_","$a","$b","div","div_","realDivide","mul","mul_","multiply","computeConv2DInfo","inShape","filterShape","dilations","roundingMode","depthwise","dataFormat","batchSize","inHeight","inWidth","inChannels","filterHeight","filterWidth","filterChannels","strideHeight","strideWidth","parseTupleParam","dilationHeight","dilationWidth","effectiveFilterHeight","getEffectiveFilterSize","effectiveFilterWidth","padInfo","outHeight","outWidth","top","bottom","left","right","fieldSize","zeroPad","computeDefaultPad","inputRows","inputCols","outputRows","conditionalRound","util.isInt","outputCols","computeOutputShape2D","padAlongHeight","padAlongWidth","getPadAndOutInfo","outChannels","computeConv3DInfo","inDepth","filterDepth","strideDepth","parse3TupleParam","dilationDepth","effectiveFilterDepth","outDepth","front","back","inputDepth","outputDepths","computeOutputShape4D","padAlongDepth","get3DPadAndOutInfo","dilation","effectiveFieldSize","param","filterSize","tupleValuesAreOne","dimA","dimB","dimC","convertConv2DDataFormat","computeOutShape","shapes","outputShape","slice_","begin","begin_","size_","slice_util.parseSliceParams","slice_util.assertParamsValid","util.assertNonNegativeIntegerDimensions","getReductionAxes","inDim","outAxis","outDim","unshift","assertAndGetBroadcastShape","elu","elu_","computeOptimalWindowSize","inSize","numSegments","imag_","$input","real_","scalar","sum","sum_","permutation","reductionAxes","permutedX","zeros","prelu","prelu_","alpha","$alpha","tensor1d","relu","relu_","relu6","relu6_","softmax","softmax_","logits","$logits","step","step_","getReshaped","blockShape","prod","batchToSpace","reshaped","spatialLength","getPermuted","reshapedRank","blockShapeRank","permuted","permutedBeforeBatch","permutedAfterBatch","getReshapedPermuted","reshapedPermuted","getSliceBeginCoords","crops","sliceBeginCoords","getSliceSize","uncroppedShape","mergeRealAndImagArrays","castTensor","zerosTensor","floatX","oldType","newType","int","zero","notEqual","reshapeTensor","linspaceImpl","stop","inRank","dims","firstShape","$dataFormat","activation","bias","dyActivation","reduceAxes","broadcast_util.getReductionAxes","preluActivationWeights","center","imageHeight","imageWidth","inverse","PI","cos","sin","numOrSizeSplits","splitSizes","count","negIndex","total","isMobile","navigator","userAgent","vendor","opera","test","substr","isBrowser","document","WorkerGlobalScope","DataStorage","dataMover","dataIdsCount","moveData","notYetImplemented","registerFlag","debugValue","device_util.isBrowser","versions","PlatformBrowser","path","fetch","performance","text","textEncoder","TextEncoder","TextDecoder","setPlatform","getNodeFetch","require","systemFetch","PlatformNode","util","requestInits","hrtime","DataType","SaverDef","CheckpointFormatVersion","contexts","WEBGL_ATTRIBUTES","antialias","premultipliedAlpha","preserveDrawingBuffer","depth","stencil","failIfMajorPerformanceCaveat","getWebGLContext","webGLVersion","canvas","OffscreenCanvas","createElement","createCanvas","addEventListener","ev","preventDefault","getContext","getWebGLRenderingContext","gl","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","PackingScheme","TextureUsage","PhysicalTextureType","getUnpackedMatrixTextureShapeWidthHeight","rows","columns","getDenseTexShape","util.sizeToSquarishShape","getPackedMatrixTextureShapeWidthHeight","getTextureConfig","textureHalfFloatExtension","glany","internalFormatFloat","internalFormatHalfFloat","internalFormatPackedHalfFloat","internalFormatPackedFloat","textureFormatFloat","downloadTextureFormat","downloadUnpackNumChannels","defaultNumChannels","textureTypeHalfFloat","textureTypeFloat","getNumber","R32F","R16F","RGBA16F","RGBA32F","RED","HALF_FLOAT","FLOAT","RGBA","HALF_FLOAT_OES","callAndCheck","func","returnValue","getError","NO_ERROR","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getWebGLErrorMessage","checkWebGLError","canBeRepresented","abs","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createFragmentShader","fragmentShaderSource","fragmentShader","createShader","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","shaderInfoLog","lineNumberRegexResult","lineNumberRegex","exec","lineNumber","shaderLines","linesWithLineNumbers","line","maxLineLength","beforeErrorLines","errorLine","afterErrorLines","logShaderSourceAndInfoLog","getShaderInfoLog","validateProgram","program","getProgramParameter","VALIDATE_STATUS","getProgramInfoLog","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","getAttribLocation","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","TEXTURE0","validateTextureUnit","activeTexture","bindTexture","TEXTURE_2D","bindColorTextureToFramebuffer","framebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","getFramebufferErrorMessage","returnTOrNull","failureMessage","tOrNull","getBatchDim","dimsToSkip","getRowsCols","getShapeAs3D","shapeAs3D","isEven","isReshapeFree","shape1","shape2","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","hasExtension","isWebGLVersionEnabled","e","isDownloadFloatTextureEnabled","createFloatTextureAndBindToFramebuffer","COLOR_BUFFER_HALF_FLOAT","texConfig","createTexture","texImage2D","frameBuffer","createFramebuffer","isFrameBufferComplete","deleteTexture","deleteFramebuffer","createHalfFloatTextureAndBindToFramebuffer","getParameter","getWebGLMaxTextureSize","MAX_TEXTURE_IMAGE_UNITS","min","getMaxTexturesInShader","queryTimerVersion","getWebGLDisjointQueryTimerVersion","device_util.isMobile","isCapableOfRenderingToFloatTexture","isWebGLFenceEnabled","fenceSync","threshold","AddNProgram","variableNames","snippets","variable","operation","userCode","AddNPackedProgram","packedInputs","packedOutput","ArgMinMaxProgram","reduceInfo","firstPass","windowSize","outSize","compOp","indexSnippet","getVecChannels","getChannels","getGlslDifferences","version","varyingVs","varyingFs","texture2D","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","getLogicalCoordinatesFromFlatIndex","coords","util.computeStrides","getFlatIndexFrom3D","ENCODE_FLOAT_SNIPPET","getBroadcastDims","backend_util","makeShader","inputsInfo","usesPackedTextures","prefixSnippets","shapeInfo","logicalShape","isUniform","inputPrefixSnippet","inputSamplingSnippet","inInfo","outShapeInfo","getPackedSamplerFromInInfo","getSamplerFromInInfo","inputInfo","texName","texFuncSnippet","charAt","toUpperCase","funcName","outRank","broadcastDims","getCoordsDataType","rankDiff","coordsSnippet","fields","unpackedCoordsSnippet","isInputScalar","isOutputScalar","cols","getPackedSamplerAtOutputCoords","outTexShape","texShape","inTexShape","flatOffset","getSamplerAtOutputCoords","getInputSamplingSnippet","glsl","floatTextureSampleSnippet","getFloatTextureSampleSnippet","outputSamplingSnippet","floatTextureSetOutputSnippet","shaderPrefix","SAMPLE_1D_SNIPPET","SAMPLE_2D_SNIPPET","SAMPLE_3D_SNIPPET","getShaderPrefix","isPacked","getOutputScalarCoords","packedTexShape","getOutputPacked1DCoords","texelsInLogicalRow","getOutputPacked2DCoords","texelsInBatch","getOutputPacked3DCoords","texelsInBatchN","batches","getOutputPackedNDCoords","getPackedOutputSamplingSnippet","getFloatTextureSetRGBASnippet","getOutput1DCoords","getOutput2DCoords","coordsFromIndexSnippet","shader_util.getLogicalCoordinatesFromFlatIndex","getOutput3DCoords","getOutput4DCoords","getOutput5DCoords","getOutput6DCoords","getOutputSamplingSnippet","getFloatTextureSetRSnippet","SHADER_PACKED_PREFIX","texNumR","texNumC","tNumR","tNumC","getFlatOffsetUniformName","getSamplerScalar","getUniformSampler","getSampler1D","util.squeezeShape","squeezedShape","newInputInfo","squeezeInputInfo","getSqueezedParams","getSampler2D","stride0","stride1","getSampler3D","stride2","getSampler4D","stride3","getSampler5D","stride4","getSampler6D","getPackedSamplerScalar","getPackedSampler1D","valuesPerRow","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","JSON","parse","stringify","ArgMinMaxPackedProgram","sourceLocSetup","sourceRank","sourceLocDType","channels","inChannel","intChannels","srcRCoords","srcGCoords","srcBCoords","srcACoords","fetchCandidateIdx","fetchValue","getBestIndicesAChannelSnippet","AvgPool2DBackpropProgram","convInfo","padTop","padLeft","avgMultiplier","AvgPool3DBackpropProgram","padFront","BatchNormProgram","xShape","meanShape","varianceShape","offsetShape","scaleShape","varianceEpsilon","backend_util.assertAndGetBroadcastShape","offsetSnippet","scaleSnippet","BatchNormPackedProgram","COMPLEX_MULTIPLY","BinaryOpComplexProgram","bShape","ADD","SUB","MUL","PRELU","BinaryOpProgram","BinaryOpPackedProgram","checkOutOfBounds","supportsBroadcasting","checkOutOfBoundsString","ClipProgram","gpgpu","webGLProgram","minLoc","getUniformLocationNoThrow","maxLoc","uniform1f","ClipPackedProgram","ComplexAbsProgram","ConcatProgram","backend_util.computeOutShape","offsets","shift","lastIndex","lastShift","ConcatPackedProgram","channel","lastChannels","allChannels","getValueSnippet","shiftedChannels","channelIdx","idx","Conv2DDerFilterProgram","isChannelsLast","Conv2DDerInputProgram","rowDim","colDim","channelDim","Conv3DDerFilterProgram","Conv3DDerInputProgram","DepthwiseConv2DDerFilterProgram","channelMul","DepthwiseConv2DDerInputProgram","Conv2DProgram","addBias","hasPreluActivationWeights","inputDepthNearestVec4","inputDepthVec4Remainder","activationSnippet","applyActivationSnippet","addBiasSnippet","Conv3DProgram","DepthwiseConv2DProgram","hasPreluActivation","xNumRows","xNumCols","DepthwiseConvPacked2DProgram","texelsAcross","mainLoop","texelC","nextTexelOffset","util.nearestLargerEven","CropAndResizeProgram","imageShape","boxShape","cropSize","method","extrapolationValue","batch","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","CumSumProgram","exclusive","getCoords","condition","idxString","getFinalCoord","getUniformLocation","DecodeMatrixProgram","outPackingScheme","DENSE","DecodeMatrixPackedProgram","DepthToSpaceProgram","blockSize","getHeightCoordString","getWidthCoordString","getDepthCoordString","getOutputDepthSize","getInputSamplingString","DiagProgram","EncodeFloatProgram","outTexUsage","DOWNLOAD","EncodeFloatPackedProgram","EncodeMatrixProgram","inputIsUnsignedByte","height","shader_util.getFlatIndexFrom3D","EncodeMatrixPackedProgram","col","COMPLEX_FFT","FFTProgram","innerDim","exponentMultiplierSnippet","resultDenominator","FillProgram","valueLoc","GatherProgram","indicesLength","sourceCoords","currentCoords","getSourceCoords","GatherNDProgram","stridesType","strideString","createVertexShader","vertexShaderSource","vertexShader","VERTEX_SHADER","webgl_util.createVertexShader","createVertexBuffer","createBuffer","bufferData","STATIC_DRAW","webgl_util.createStaticVertexBuffer","createIndexBuffer","ELEMENT_ARRAY_BUFFER","webgl_util.createStaticIndexBuffer","Uint16Array","createAndConfigureTexture","internalFormat","textureFormat","textureType","maxTextureSize","webgl_util.validateTextureSize","webgl_util.createTexture","tex2d","webgl_util.callAndCheck","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","getInternalFormatForFloat32MatrixTexture","textureConfig","getInternalFormatForFloat16MatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","downloadPackedMatrixFromBuffer","physicalRows","physicalCols","gl2","downloadTarget","w","h","tex_util.getPackedRGBAArraySizeFromMatrixShape","PIXEL_PACK_BUFFER","getBufferSubData","GPGPUContext","outputTexture","disposed","vertexAttrsAreBound","itemsToPoll","glVersion","setWebGLContext","COLOR_BUFFER_FLOAT","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","webgl_util.getExtensionOrThrow","webgl_util.hasExtension","colorBufferFloatExtension","colorBufferHalfFloatExtension","vertexBuffer","gpgpu_util.createVertexBuffer","indexBuffer","gpgpu_util.createIndexBuffer","webgl_util.createFramebuffer","tex_util.getTextureConfig","debug","finish","deleteBuffer","tex_util.getUnpackedMatrixTextureShapeWidthHeight","gpgpu_util.createFloat32MatrixTexture","gpgpu_util.createFloat16MatrixTexture","UNSIGNED_BYTE","gpgpu_util.createUnsignedBytesMatrixTexture","pixels","gpgpu_util.uploadPixelDataToTexture","dataForUpload","texelDataType","gpgpu_util.uploadDenseMatrixToTexture","tex_util.getPackedMatrixTextureShapeWidthHeight","gpgpu_util.createFloat16PackedMatrixTexture","gpgpu_util.createPackedMatrixTexture","webgl_util.unbindColorTextureFromFramebuffer","downloadMatrixDriver","readPixels","gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture","gpgpu_util.downloadPackedMatrixFromBuffer","gpgpu_util.downloadFloat32MatrixFromBuffer","bindTextureToFrameBuffer","bufferSizeBytes","bytesPerFloat","STREAM_READ","gpgpu_util.createBufferFromOutputTexture","unbindTextureToFrameBuffer","fenceContext","createFence","pollFence","isFencePassed","sync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","packedRGBA","gpgpu_util.downloadMatrixFromPackedOutputTexture","webgl_util.createFragmentShader","gpgpu_util.createVertexShader","createProgram","webgl_util.createProgram","attachShader","linkProgram","LINK_STATUS","webgl_util.linkProgram","webgl_util.validateProgram","setProgram","webgl_util.bindVertexBufferToProgramAttribute","gpgpu_util.bindVertexProgramAttributeStreams","deleteProgram","useProgram","uniformName","shouldThrow","webgl_util.getProgramUniformLocationOrThrow","webgl_util.getProgramUniformLocation","inputMatrixTexture","uniformLocation","throwIfNoProgram","uniformSamplerLocation","uniform1i","webgl_util.bindTextureToProgramUniformSampler","outputMatrixTexture","setOutputMatrixTextureDriver","outputPackedMatrixTexture","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","webgl_util.validateFramebuffer","debugValidate","drawElements","TRIANGLES","UNSIGNED_SHORT","disjointQueryTimerExtension","getQueryTimerExtension","ext","getQueryTimerExtensionWebGL2","createQuery","TIME_ELAPSED_EXT","getQueryTimerExtensionWebGL1","createQueryEXT","beginQueryEXT","endQueryEXT","util.repeatedTry","getQueryTime","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","addItemToPoll","linearSearchLastTrue","isDoneFn","resolveFn","pollItems","webgl_util.bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","validateBinaryAndProgram","shapeInfos","texShapeA","texShapeB","texData","Im2ColPackedProgram","itemsPerBlockRow","unrolled","LRNProgram","radius","beta","rad","maxD","powOperator","basis","LRNGradProgram","depthRadius","LRNPackedProgram","MaxPool2DBackpropProgram","MaxPool3DBackpropProgram","MatMulPackedProgram","transposeA","transposeB","sharedDim","sharedDimensionPacked","aSample","bSample","aSwizzle","bSwizzle","MultinomialProgram","numOutcomes","numSamples","seed","seedLoc","OneHotProgram","numIndices","onValue","offValue","PackProgram","outOfBoundsCondition","cond","getOutOfBoundsCondition","setup","innerDims","getSetup","coord","getSourceCoordsArr","getOutput","PadProgram","paddings","constantValue","p","unpackedCoords","PadPackedProgram","source","cLimit","componentSetup","paddingArea","Pool2DProgram","poolType","computePositions","flattenPositions","includeBatchInIndex","isAvgPool","batchFlattenPositionStr","flattenPositionStr","initializationValue","compareOp","filterWidthNearestVec4","filterWidthVec4Remainder","updateSnippet","Pool3DProgram","ReduceProgram","reduceType","windowSizeNearestVec4","windowSizeVec4Remainder","vecType","ReshapePackedProgram","thisRC","ResizeBilinearBackpropProgram","alignCorners","xHeight","xWidth","yHeight","yWidth","effectiveXSize","effectiveYSize","invHeightScale","invWidthScale","winHeight","winWidth","ResizeBilinearProgram","newHeight","newWidth","oldHeight","oldWidth","effectiveInSize","effectiveOutSize","ResizeBilinearPackedProgram","ResizeNearestNeigborBackpropProgram","ResizeNearestNeighborProgram","roundBase","ReverseProgram","inCoords","getInCoord","ReversePackedProgram","nextColumn","nextRow","getChannel","inCoordsArray","channels1","getR","getG","getB","getA","ScatterProgram","updateSize","updatesRank","summingDupeIndex","indicesString","indicesSnippet","updatesString","updatesSnippet","SegmentOpProgram","segOpInfo","segOpType","checkValueOutOfBounds","checkSegmentIdOutOfBounds","SelectProgram","cRank","cCoords","abCoords","cCoordVars","abCoordVars","SliceProgram","destSize","uniformPart","body","startLoc","uniform1iv","SlicePackedProgram","sourceLoc","upperRow","lowerRow","StridedSliceProgram","inputDtype","newCoords","outputAxis","TextureManager","numUsedTextures","numFreeTextures","_numBytesAllocated","_numBytesFree","freeTextures","logEnabled","usedTextures","shapeRC","usage","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","texBytes","computeBytes","newTexture","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","logicalTexType","deleteTexThreshold","deleteMatrixTexture","texList","texIndex","splice","freeRatio","numBytesAllocated","numBytesFree","tex","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","numBytesForInternalFormat","UPLOAD","RENDER","getPhysicalTextureForRendering","PIXELS","shapeRowsCol","TileProgram","reps","UnaryOpProgram","opSnippet","CHECK_NAN_SNIPPET","ABS","RELU","RELU6","ELU","NEG","CEIL","FLOOR","EXP","EXPM1","CLONE","UnaryOpPackedProgram","UnpackProgram","segment_util","sizeSplits","sliceT","tile","xBuf","newLoc","originalLoc","originalIndex","toTensor","topkImpl","xDtype","sorted","lastDim","allTopKVals","allTopKIndices","subarray","valAndInd","outOffset","topKVals","topKIndices","whereImpl","condShape","condVals","inBuffer","binaryCaches","mapActivationToShaderProgram","packed","unary_packed_op.RELU","unary_op.RELU","unary_packed_op.ELU","unary_op.ELU","unary_packed_op.RELU6","unary_op.RELU6","binaryop_packed_gpu.PRELU","binaryop_gpu.PRELU","MathBackendWebGL","floatPrecision","segmentIds","dY","newHEight","mean","variance","scale","inputImage","outputImage","normalized","boxes","scores","maxOutputSize","iouThreshold","scoreThreshold","image","boxIndex","sparseIndices","sparseValues","defaultValue","pendingRead","pendingDisposal","WeakSet","dataRefCount","numBytesInGPU","uploadWaitMs","downloadWaitMs","warnedAboutMemory","warnedAboutCPUBackend","pendingDeletes","binaryCache","gpgpuCreatedLocally","textureManager","numMBBeforeWarning","screen","devicePixelRatio","cpuBackend","checkNumericalProblems","complexTensors","unary_op.CLONE","runWebGLProgram","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","util.now","backend_util.mergeRealAndImagArrays","getValuesFromTexture","subscribers","tmpDownloadTarget","tmpData","createBufferFromTexture","tex_util.getDenseTexShape","createAndWaitForFence","ps","downloadFloat32MatrixFromBuffer","dTypeVals","webgl_util.canBeRepresented","tmpTarget","downloadMatrixFromPackedTexture","shouldUsePackedProgram","webgl_util.getShapeAs3D","downloadByteEncodedFloatMatrixFromOutputTexture","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","util.flatten","flattenedActiveTimerNames","util.sum","ms","numBytesInGPUAllocated","numBytesInGPUFree","startMs","endMs","waitForQueryAndGetTime","timerQuery","releaseGPUData","origDataId","releaseTexture","uploadToGPU","findBackend","sizeThreshold","getCPUBackend","makeOutput","shouldExecuteOnCPU","isContinous","firstNonOneAxis","slice_util.isSliceContinous","customSetup","getCustomSetupFunc","compileAndRun","shallowSlice","xTexData","newTexData","slice_util.computeFlatOffset","stridedSlice","slice_util.computeOutShape","some","reals","imags","midIndex","leftSide","rightSide","tensors2D","as2D","neg","packedUnaryOp","unary_op.NEG","outerShapeA","outerShapeB","a3D","as3D","b3D","hasBias","fusedActivation","aData","bData","realProgram","binaryop_complex_gpu.COMPLEX_MULTIPLY","imagProgram","makeComplexComponentTensorInfo","packedBinaryOp","binaryop_gpu.MUL","batchNormPackedProgram","batchNormProgram","decodedData","buf","gather","backend_util.getReshaped","backend_util.getPermuted","backend_util.getReshapedPermuted","backend_util.getSliceBeginCoords","backend_util.getSliceSize","completePaddings","paddedX","reshapedPaddedShape","permutedReshapedPaddedPermutation","flattenShape","paddedXT","backend_util.computeOptimalWindowSize","bestIndicesA","argReduce","argReducePacked","backend_util.assertAxesAreInnerMostDims","reduceShape","backend_util.computeOutAndReduceShapes","a2D","outputDType","tf.sumOutType","backend_util.getAxesPermutation","backend_util.getInnerMostAxes","segOpCompute","backend_util.getUndoAxesPermutation","segOpComputeOptimalWindowSize","range","argMinMaxReduce","log2","prevResult","less","greater","backend_util.warn","xVals","minimum","maximum","complexSeparableBinaryOp","binaryop_gpu.ADD","complexParts","aPart","bPart","aHandle","bHandle","complexTensor","complexPart","addN","d1","d2","binaryop_gpu.SUB","subtract","unary_op.CEIL","unary_op.FLOOR","exp","unary_op.EXP","expm1","unary_op.EXPM1","maxLogit","backend_util.expandShapeToKeepDim","sumExp","rsqrt","unary_op.ABS","xData","unary_op.STEP","sharedMatMulDim","outerShapeX","outerShapeFilter","batchMatMulWillBeUnpacked","reshapeWillBeExpensive","targetShape","xReshaped","filterReshaped","fusedBatchMatMul","originalXTexDataShape","webgl_util.isReshapeFree","pointwiseConv","pointwiseConvTexData","x2ColShape","xSqueezed","squeeze","w2Row","im2ColProgram","im2Col","matmulProgram","product","conv2dByMatMul","conv2dWithIm2Row","shouldPackDepthwiseConv","maxPoolPositionsProgram","maxPoolPositions","maxPoolBackPropProgram","avgPoolBackpropProgram","backend_util.castTensor","outIndex","avgPool3dBackpropProgram","maxPool3dPositionsProgram","maxPool3dPositions","maxPool3dBackPropProgram","packedReshape","backend_util.reshapeTensor","probs","inputHeight","inputWidth","outputHeight","outputWidth","outputDepth","backend_util.calculateShapes","flattenIndices","flattenX","fftImpl","fft_gpu.COMPLEX_FFT","numSlices","backend_util.prepareAndValidate","util.inferDtype","backend_util.linspaceImpl","makeTensorInfo","afterShape","input3DShape","webgl_util.getBatchDim","webgl_util.getRowsCols","input3D","afterShapeAs3D","outputDtype","preventEagerUnpackingOfOutput","outData","tex_util.PackingScheme","texelShape","util.getTypedArrayFromDType","dataToDispose","inputsData","uniformValues","unpackTensor","packTensor","savedInput","outputData","keyInputs","hasOffset","keyUserCode","gpgpu_math.makeShaderKey","binary","getAndSaveBinary","inputInfos","inShapeInfos","shader_compiler.makeShader","infLoc","nanLoc","uniformLocations","gpgpu_math.compileProgram","startTimer","outTex","setOutputPackedMatrixTexture","setOutputMatrixTexture","Infinity","NaN","varLoc","varOffsetLoc","uniform1fv","setInputMatrixTexture","executeProgram","gpgpu_math.runProgram","endTimer","unpacked","outInfo","getBinary","HTMLCanvasElement","remove","floatPrecisionValue","debugFlag","underflowCheckValue","logShape","maxTexSize","squeezeResult","webgl_util.getTextureShapeFromLogicalShape","isByteArray","tempDenseInputHandle","uploadDenseMatrixToTexture","getTexture","preventEagerUnpacking","encodedOutputTarget","outputTexData","acquireTexture","float32Values","float32ToTypedArray","texType","mb","registerBackend","aVals","reduceSize","xRank","xSize","xStrides","newStrides","util.indexToLoc","util.locToIndex","maxImpl","maxImplCPU","transposeImpl","transposeImplCPU","shared","reshapedInput","reduced","reductionType","TransposeProgram","newDim","switched","originalOrder","switchedCoords","getSwitchedCoords","TransposePackedProgram","outputOrder","switchedOrder","getc","registerKernel","webglBackend","origAxes","maxInputIsTransposed","maxInputValues","maxOutShape","outValues","tf.max"],"mappings":"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"}