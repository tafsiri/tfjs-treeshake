!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("crypto"),require("path"),require("fs"),require("worker_threads"),require("perf_hooks")):"function"==typeof define&&define.amd?define(["crypto","path","fs","worker_threads","perf_hooks"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).crypto,e.path,e.fs,e.worker_threads,e.perf_hooks)}(this,(function(e,t,n,r,o){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t,n=n&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n,r=r&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r,o=o&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o;class a{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(t instanceof Promise)throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=function(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}(this.global.location.search);if("tfjsflags"in e){e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}}function s(){return u}let i,u=null;function l(){if(null==i){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}i=e}return i}function c(e,t){const n=function(){const e=l();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const d=c("kernelRegistry",()=>new Map),h=c("gradRegistry",()=>new Map);function f(e){return h.get(e)}function p(e){const t=d.entries(),n=[];for(;;){const{done:r,value:o}=t.next();if(r)break;const[a,s]=o,[i]=a.split("_");i===e&&n.push(s)}return n}function m(e){const{kernelName:t,backendName:n}=e,r=g(t,n);d.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),d.set(r,e)}function g(e,t){return`${t}_${e}`}function x(e){return e%2==0?e:e+1}function y(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function v(e,t,n=""){y(_(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function C(e){y(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function w(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||k(e)&&!n)for(let r=0;r<e.length;++r)w(e[r],t,n);else t.push(e);return t}function b(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function _(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function R(e){return e%1==0}function E(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function $(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function I(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function A(e,t=(e=>0),n){return new Promise((r,o)=>{let a=0;const s=()=>{if(e())return void r();a++;const i=t(a);null!=n&&a>=n?o():setTimeout(s,i)};s()})}function T(e,t){const n=t.length;return y((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+e),y(e.every(e=>R(e)),()=>"All values in axis param must be integers but got axis "+e),e.map(e=>e<0?n+e:e)}function S(e,t){const n=[],r=[],o=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||o?null:T(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[s]||a[s]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[s]<=t&&s++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function O(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type "+e);n=new Uint8Array(t)}return n}function N(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type "+e);n=new Array(t)}return n}function k(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function D(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype "+e)}function F(e){return"string"==typeof e||e instanceof String}function M(e){return Array.isArray(e)?M(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":"number"==typeof e?"float32":F(e)?"string":function(e){return"boolean"==typeof e}(e)?"bool":"float32"}function B(e){return!!(e&&e.constructor&&e.call&&e.apply)}function P(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function L(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function W(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=w(e)),s().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type "+t)}function U(e,t){if(0===e.length)return t[0];const n=e.reduce((e,t)=>e*t);if(0===n)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}.`);return function e(t,n,r){const o=new Array;if(1===n.length){const e=n[0];for(let n=0;n<e;n++)o[n]=r[t+n]}else{const a=n[0],s=n.slice(1),i=s.reduce((e,t)=>e*t);for(let n=0;n<a;n++)o[n]=e(t+n*i,s,r)}return o}(0,e,t)}function V(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type "+t)}function G(){return s().platform.now()}function z(e){e.forEach(t=>{y(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function H(e,t="utf-8"){return t=t||"utf-8",s().platform.decode(e,t)}function X(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function j(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}class q{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new K)}profileKernel(e,t,n){let r;const o=this.backendTimer.time(()=>{r=n()});r.map(t=>{t.data().then(n=>{!function(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}}(n,t.dtype,e)})});return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(e=>e.kernelMs),extraInfo:o.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:o,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),r,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],o,n[2])})})}}class K{logKernelProfile(e,t,n,r,o,a){const s="number"==typeof r?I(r+"ms",9):r.error,i=I(e,25),u=t.rank,l=t.size,c=I(t.shape.toString(),14);let d="";for(const e in o){const n=o[e].shape||t.shape,r=n.length;d+=`${e}: ${r}D ${r>0?n:""} `}console.log(`%c${i}\t%c${s}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Y(e,t,n,r){const o=L(t),a=function(e,t,n,r){const o=b(t),a=r[r.length-1],s=new Array(a).fill(0),i=t.length,u="complex64"===n?J(e):e;if(i>1)for(let e=0;e<o/a;e++){const t=e*a;for(let e=0;e<a;e++)s[e]=Math.max(s[e],Q(u[t+e],0,n).length)}return s}(e,t,n,o),s=t.length,i=function e(t,n,r,o,a,s=!0){const i="complex64"===r?2:1,u=n[0],l=n.length;if(0===l){if("complex64"===r){return[Q(J(t)[0],0,r)]}return"bool"===r?[Z(t[0])]:[t[0].toString()]}if(1===l){if(u>20){const e=3*i;let n=Array.from(t.slice(0,e)),o=Array.from(t.slice((u-3)*i,u*i));return"complex64"===r&&(n=J(n),o=J(o)),["["+n.map((e,t)=>Q(e,a[t],r)).join(", ")+", ..., "+o.map((e,t)=>Q(e,a[u-3+t],r)).join(", ")+"]"]}return["["+("complex64"===r?J(t):Array.from(t)).map((e,t)=>Q(e,a[t],r)).join(", ")+"]"]}const c=n.slice(1),d=o.slice(1),h=o[0]*i,f=[];if(u>20){for(let n=0;n<3;n++){const o=n*h,s=o+h;f.push(...e(t.slice(o,s),c,r,d,a,!1))}f.push("...");for(let n=u-3;n<u;n++){const o=n*h,s=o+h;f.push(...e(t.slice(o,s),c,r,d,a,n===u-1))}}else for(let n=0;n<u;n++){const o=n*h,s=o+h;f.push(...e(t.slice(o,s),c,r,d,a,n===u-1))}const p=2===l?",":"";f[0]="["+f[0]+p;for(let e=1;e<f.length-1;e++)f[e]=" "+f[e]+p;let m=",\n";for(let e=2;e<l;e++)m+="\n";return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":m),f}(e,t,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+s),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(e=>"    "+e).join("\n")),u.join("\n")}function Q(e,t,n){let r;return r=Array.isArray(e)?parseFloat(e[0].toFixed(7))+" + "+parseFloat(e[1].toFixed(7))+"j":F(e)?`'${e}'`:"bool"===n?Z(e):parseFloat(e.toFixed(7)).toString(),I(r,t)}function Z(e){return 0===e?"false":"true"}function J(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class ee{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=b(e),null!=n){const e=n.length;y(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||N(t,this.size),this.strides=L(e)}set(e,...t){0===t.length&&(t=[0]),y(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=`+this.shape;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return te().makeTensor(this.values,this.shape,this.dtype)}}let te=null;class ne{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=b(e),this.strides=L(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return null.buffer(this.shape,this.dtype,e)}bufferSync(){return null.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return U(this.shape,e)}arraySync(){return U(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const e=te().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map(e=>H(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=te().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>H(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await te().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(te().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return null.print(this,e)}clone(){return this.throwIfDisposed(),null.clone(this)}toString(e=!1){return Y(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),null.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),te().makeVariable(this,e,t,n)}}Object.defineProperty(ne,Symbol.hasInstance,{value:e=>!!e&&null!=e.dataId&&null!=e.shape&&null!=e.dtype});class re extends ne{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!_(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);te().disposeTensor(this),this.dataId=e.dataId,te().incRef(this,null)}dispose(){te().disposeVariable(this),this.isDisposedInternal=!0}}var oe,ae,se,ie,ue;Object.defineProperty(re,Symbol.hasInstance,{value:e=>e instanceof ne&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(oe||(oe={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(ae||(ae={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(se||(se={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(ie||(ie={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(ue||(ue={}));const le={float32:ie,int32:ae,bool:se,complex64:ue};function ce(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return le[e][t]}function de(e){return ce(e,"int32")}function he(e,t){if(e.dtype===t.dtype)return[e,t];const n=ce(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function fe(e){const t=[];return function e(t,n,r){if(null==t)return;if(t instanceof ne)return void n.push(t);if(o=t,!Array.isArray(o)&&"object"!=typeof o)return;var o;const a=t;for(const t in a){const o=a[t];r.has(o)||(r.add(o),e(o,n,r))}}(e,t,new Set),t}class pe{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class me{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new pe}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(e+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new q(this.backendInstance),!0}setupRegisteredKernels(){p(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){p(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(Promise.resolve(n)===n){const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(t){return console.warn(`Initialization of backend ${e} failed`),console.warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(e+" backend not found in registry");this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:o}=this.initializeBackend(n);if(o||r)return{name:n,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,o=this.readSync(t);r.disposeData(t),n.backend=e,e.move(t,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return me.nextTensorId++}nextVariableId(){return me.nextVariableId++}clone(e){const t=this.makeTensorFromDataId(e.dataId,e.shape,e.dtype),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ge.runKernelFunc(t=>t.cast(e,"float32"),t,null,"Cast",n)}}),[],{}),t}runKernel(e,t,n,r,o){return this.runKernelFunc(null,t,null,e,n,r,o)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let o=0;n.forEach(e=>{o+="complex64"===e.dtype?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=r-t-o-a;if(s>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${s} data ids) after running '${e}'`)}runKernelFunc(e,t,n,r,o,a,s){let i,u=[];const l=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const c=this.state.numBytes,h=this.state.numTensors;let f;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=function(e,t){const n=g(e,t);return d.get(n)}(r,this.backendName);let m,x;if(null!=p)f=()=>{const e=this.backend.numDataIds();m=p.kernelFunc({inputs:t,attrs:o,backend:this.backend});const n=Array.isArray(m)?m:[m];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,e,n);const i=n.map(({dataId:e,shape:t,dtype:n})=>this.makeTensorFromDataId(e,t,n));if(l){let e=this.getTensorsForGradient(r,t,i);if(null==e){null==s&&(s=[]);const t=i.filter((e,t)=>s[t]);e=(a||[]).slice().concat(t)}u=this.saveTensorsForBackwardMode(e)}return i};else{const t=e=>{l&&(u=e.map(e=>this.keep(this.clone(e))))};f=()=>{const n=this.backend.numDataIds();m=this.tidy(()=>e(this.backend,t));const o=Array.isArray(m)?m:[m];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,o),o}}return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(x=this.profiler.profileKernel(r,t,()=>f()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(x),i=x.outputs):i=f()}),l&&this.addTapeNode(r,t,i,n,u,o),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-c,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(t).map(e=>null!=t[e]?t[e].shape:null),outputShapes:i.map(e=>e.shape),kernelTimeMs:x.timeMs,extraInfo:x.extraInfo}),Array.isArray(m)?i:i[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const r=f(e);if(null!=r){const e=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(y(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const s=n.filter((e,t)=>o[t]);return a.concat(s)}return null}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=e;"string"===n&&F(e[0])&&(o=e.map(e=>function(e,t="utf-8"){return t=t||"utf-8",s().platform.encode(e,t)}(e)));const a=r.write(o,t,n),i=new ne(t,n,a,this.nextTensorId());if(this.incRef(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const o=new ne(t,n=n||"float32",e,this.nextTensorId());return this.incRef(o,r),o}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const o=new re(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}incRef(e,t){const n=this.state.tensorInfo.has(e.dataId)?this.state.tensorInfo.get(e.dataId).refCount:0;if(this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*D(e.dtype)),this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(e.dataId).refCount++,e instanceof re||this.track(e)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;this.state.numTensors--,"string"===e.dtype&&this.state.numStringTensors--;const t=this.state.tensorInfo.get(e.dataId);t.refCount<=1?("complex64"!==e.dtype&&(this.state.numBytes-=t.bytes),this.state.numDataBuffers--,t.backend.disposeData(e.dataId),this.state.tensorInfo.delete(e.dataId)):this.state.tensorInfo.get(e.dataId).refCount--}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,o,a){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:o},i=f(e);null!=i&&(r=i.gradFunc),null!=r&&(s.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=V(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],o,a))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=fe(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(y(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));y(o instanceof ne,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const r={},o={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],s=a.inputs;for(const e in s){const n=s[e];let i=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach(e=>r[e.id]=!0),i=!0,o[a.id]=!0;break}if(i)break}}const a={};a[n.id]=!0;const s={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,s[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(o[n.id]&&s[n.id]){const e={};for(const t in n.inputs){const o=n.inputs[t];r[o.id]&&(e[t]=o)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}(this.state.activeTape,t,o);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[o.id]=null==n?function(e){const t=function(e,t){const n=V(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}(b(e),"float32");return ge.makeTensor(t,e,"float32")}(o.shape):n,function(e,t,n,r){for(let o=t.length-1;o>=0;o--){const a=t[o],s=[];if(a.outputs.forEach(t=>{const n=e[t.id];null!=n?s.push(n):s.push(null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(s);for(const t in a.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const o=n(()=>i[t]());if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${o.dtype}'`);const s=a.inputs[t];if(!_(o.shape,s.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${o.shape}', which does not match the shape of the input '${s.shape}'`);if(null==e[s.id])e[s.id]=o;else{const t=e[s.id];e[s.id]=r(t,o),t.dispose()}}}}(e,a,e=>this.tidy(e),xe);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:o,grads:r}})}customGrad(e){return y(B(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;y(t.every(e=>e instanceof ne),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc((r,o)=>(n=e(...t,o),y(n.value instanceof ne,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),y(B(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),r,(e,r)=>{const o=n.gradFunc(e,r),a=Array.isArray(o)?o:[o];y(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),y(a.every(e=>e instanceof ne),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const s={};return a.forEach((e,t)=>{s[t]=()=>e}),s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=G(),n=await this.backend.time(e);return n.wallMs=G()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new pe;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}me.nextTensorId=0,me.nextVariableId=0;const ge=function(){const e=l();if(null==e._tfengine){const t=new a(e);e._tfengine=new me(t)}var t;return t=e._tfengine.ENV,u=t,te=()=>e._tfengine,e._tfengine}();function xe(e,t){const n={a:e,b:t};return ge.runKernelFunc((n,r)=>{const o=n.add(e,t);return r([e,t]),o},n,null,"Add")}function ye(e,t){let n=e;if(k(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||k(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&s().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,n,r){if(r=r||[],!Array.isArray(t)&&!k(t))return void y(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);y(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${t.length} elements`),y(t.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);const o=n.slice(1);for(let n=0;n<t.length;++n)e(t[n],o,r.concat(n))}(e,r,[]),r}function ve(e,t,n,r){if(null!=e&&("numeric"!==e&&e!==t||"numeric"===e&&"string"===t))throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}function Ce(e,t,n,r="numeric"){if(e instanceof ne)return ve(r,e.dtype,t,n),e;let o=M(e);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),ve(r,o,t,n),null==e||!k(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=ye(e,o);k(e)||Array.isArray(e)||(e=[e]);const s="string"!==o?W(e,o):w(e,[],!0);return ge.makeTensor(s,a,o)}function we(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,r)=>Ce(e,`${t}[${r}]`,n),r)}function be(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+t.length+" keys.");let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));const o=(...e)=>{ge.startScope(n);try{const t=r(...e);return t instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ge.endScope(t),t}catch(e){throw ge.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}const _e=be({complex_:function(e,t){const n=Ce(e,"real","complex"),r=Ce(t,"imag","complex");v(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const o={real:n,imag:r};return ge.runKernelFunc(e=>e.complex(n,r),o,null,"Complex")}});function Re(e,t,n,r){if(null==r&&(r=M(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!k(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){z(t);const e=b(t),r=b(n);y(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){const r=n[e],o=e!==n.length-1||r!==b(t.slice(e));y(n[e]===t[e]||!o,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return k(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?W(e,r):w(e,[],!0),ge.makeTensor(e,t,r)}function Ee(e,t,n){return Re(e,t,ye(e,n),n)}const $e=be({cast_:function(e,t){const n=Ce(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype "+t);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},o={dtype:t};return ge.runKernelFunc(e=>e.cast(n,t),r,null,"Cast",o)}});const Ie=be({reshape_:function(e,t){const n=Ce(e,"x","reshape",null);t=function(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const o=e.slice();return o[r]=t/n,o}(t,n.size),y(n.size===b(t),()=>"new shape and old shape must have the same number of elements.");const r={x:n},o={shape:t};return ge.runKernelFunc((e,r)=>(r([n]),e.reshape(n,t)),r,null,"Reshape",o)}});const Ae=be({transpose_:function(e,t){const n=Ce(e,"x","transpose");if(null==t&&(t=n.shape.map((e,t)=>t).reverse()),y(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{y(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+t)}),n.rank<=1)return n.clone();const r={x:n},o={perm:t};return ge.runKernelFunc(e=>e.transpose(n,t),r,null,"Transpose",o)}});function Te(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Se(e,t,n){const r=e.length+t.length,o=[];let a=0,s=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?o.push(e[a++]):o.push(t[s++]);return o}function Oe(e,t){const n=[],r=e.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&n.push(e[o]);return[n,t.map(t=>e[t])]}function Ne(e,t){return Se(e,t.map(e=>1),t)}function ke(e,t,n){y(Te(t,n),()=>e+" supports only inner-most axes for now. "+`Got axes ${t} and rank-${n} input.`)}function De(e,t){if(Te(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function Fe(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Me(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Be=be({max_:function(e,t=null,n=!1){const r=Ce(e,"x","max"),o={x:r},a={reductionIndices:t,keepDims:n};return ge.runKernelFunc((e,o)=>{let a=T(t,r.shape);const s=De(a,r.rank);let i=r;null!=s&&(i=Ae(r,s),a=Me(a.length,i.rank));const u=e.max(i,a);null!=s&&i.dispose();let l=u;if(n){const e=Ne(l.shape,T(t,r.shape));l=Ie(l,e),u.dispose()}return o([r,l]),l},o,null,"Max",a)}});function Pe(e,t){if(e.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[t.rank-1]>e.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[t.rank-1]} vs. ${e.rank}`);if(0===e.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const n=t.shape,r=n[n.length-1];let o=1;for(let e=0;e<n.length-1;++e)o*=n[e];const a=e.shape,s=n.slice();s.pop();let i=1;for(let t=r;t<e.rank;++t)i*=a[t],s.push(a[t]);const u=[...L(e.shape).map(e=>e/i),1].slice(0,r);return[s,o,i,u]}function Le(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${t.shape}, shape: ${e}`+`, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(a+` update.rank < ${o}. `);if(e.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+e.length-r)throw new Error(a+" update.rank != "+(o+e.length-r));for(let e=0;e<o;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-o;++t)if(n.shape[t+o]!==e[t+r])throw new Error(a+` updates.shape[${t+o}] (${n.shape[t+o]}) != shape[${t+o}] (${e[t+o]})`)}function We(e,t,n){const r=t.shape.length,o=r>1?t.shape[r-1]:1,a=n.length;let s=1;for(let e=o;e<a;++e)s*=n[e];const i=o<1?1:o;return{sliceRank:o,numUpdates:b(t.shape)/i,sliceSize:s,strides:[...L(n.slice(0,o)),1],outputSize:b(n)}}function Ue(e,t,n){const r=[];for(let o=0;o<e.length;o++)r[o]=Math.ceil((t[o]-e[o])/n[o]);return r}function Ve(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let o=r+1;o<n.length;o++)if(t[o]>0||n[o]!==e[o])return!1;return!0}function Ge(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function ze(){return ge}function He(e,t,n=1){return ge.registerBackend(e,t,n)}const Xe=be({floorDiv_:function(e,t){let n=Ce(e,"a","floorDiv"),r=Ce(t,"b","floorDiv");[n,r]=he(n,r);const o={a:n,b:r};return ge.runKernelFunc((e,t)=>{const o=e.floorDiv(n,r);return t([n,r]),o},o,null,"FloorDiv")}});const je=be({div_:function(e,t){let n=Ce(e,"a","div"),r=Ce(t,"b","div");if([n,r]=he(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Xe(n,r);const o={a:n,b:r};return ge.runKernelFunc((e,t)=>{const o=e.realDivide(n,r);return t([n,r]),o},o,null,"Div",{})}});const qe=be({mul_:function(e,t){let n=Ce(e,"a","mul"),r=Ce(t,"b","mul");[n,r]=he(n,r);const o={a:n,b:r};return ge.runKernelFunc((e,t)=>{const o=e.multiply(n,r);return t([n,r]),o},o,null,"Multiply")}});function Ke(e,t,n,r,o,a,s=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);[u,d,l,c]=e}const[h,f,,p]=t,[m,g]=Ze(n),[x,v]=Ze(r),C=et(h,x),w=et(f,v),{padInfo:b,outHeight:_,outWidth:E}=function(e,t,n,r,o,a,s,i,u){let l,c,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,r,o){null==r&&(r=Qe(e,t,n));const a=e[0],s=e[1],i=tt((a-t+2*r)/n+1,o);y(R(i),()=>`The output # of rows (${i}) must be an integer. Change the stride and/or zero pad parameters`);const u=tt((s-t+2*r)/n+1,o);return y(R(u),()=>`The output # of columns (${u}) must be an integer. Change the stride and/or zero pad parameters`),[i,u]}([t,n],a,r,e,i);c=o[0],d=o[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/o);const e=Math.max(0,(c-1)*r+a-t),i=Math.max(0,(d-1)*o+s-n),u=Math.floor(e/2),h=e-u,f=Math.floor(i/2);l={top:u,bottom:h,left:f,right:i-f,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-s+1)/o);else{if("object"!=typeof e)throw Error("Unknown padding parameter: "+e);{const h="channelsLast"===u?e[1][0]:e[2][0],f="channelsLast"===u?e[1][1]:e[2][1],p="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},c=tt((t-a+h+f)/r+1,i),d=tt((n-s+p+m)/o+1,i)}}return{padInfo:l,outHeight:c,outWidth:d}}(o,l,c,m,g,C,w,a,i),$=s?p*d:p;let I;return"channelsFirst"===i?I=[u,$,_,E]:"channelsLast"===i&&(I=[u,_,E,$]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:_,outWidth:E,outChannels:$,padInfo:b,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:C,effectiveFilterWidth:w,dilationHeight:x,dilationWidth:v,inShape:e,outShape:I,filterShape:t}}function Ye(e,t,n,r,o,a=!1,s="channelsLast",i){let[u,l,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[u,l,c,d,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);[u,h,l,c,d]=e}const[f,p,m,,g]=t,[x,v,C]=Je(n),[w,b,_]=Je(r),E=et(f,w),$=et(p,b),I=et(m,_),{padInfo:A,outDepth:T,outHeight:S,outWidth:O}=function(e,t,n,r,o,a,s,i,u,l,c){let d,h,f,p;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,o,a){null==o&&(o=Qe(e,t,r));const s=e[0],i=e[1],u=e[2],l=tt((s-t+2*o)/r+1,a);y(R(l),()=>`The output # of depths (${l}) must be an integer. Change the stride and/or zero pad parameters`);const c=tt((i-t+2*o)/r+1,a);y(R(c),()=>`The output # of rows (${c}) must be an integer. Change the stride and/or zero pad parameters`);const d=tt((u-t+2*o)/r+1,a);return y(R(d),()=>`The output # of columns (${d}) must be an integer. Change the stride and/or zero pad parameters`),[l,c,d,n]}([t,n,r,1],i,1,o,e,c);h=a[0],f=a[1],p=a[2]}else if("same"===e){h=Math.ceil(t/o),f=Math.ceil(n/a),p=Math.ceil(r/s);const e=(h-1)*o+i-t,c=(f-1)*a+u-n,m=(p-1)*s+l-r,g=Math.floor(e/2),x=e-g,y=Math.floor(c/2),v=c-y,C=Math.floor(m/2);d={top:y,bottom:v,left:C,right:m-C,front:g,back:x,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: "+e);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-i+1)/o),f=Math.ceil((n-u+1)/a),p=Math.ceil((r-l+1)/s)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(o,l,c,d,x,v,C,E,$,I,i),N=a?g*h:g;let k;return"channelsFirst"===s?k=[u,N,T,S,O]:"channelsLast"===s&&(k=[u,T,S,O,N]),{batchSize:u,dataFormat:s,inDepth:l,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:S,outWidth:O,outChannels:N,padInfo:A,strideDepth:x,strideHeight:v,strideWidth:C,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:E,effectiveFilterHeight:$,effectiveFilterWidth:I,dilationDepth:w,dilationHeight:b,dilationWidth:_,inShape:e,outShape:k,filterShape:t}}function Qe(e,t,n,r=1){const o=et(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)}function Ze(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Je(e){return"number"==typeof e?[e,e,e]:e}function et(e,t){return t<=1?e:e+(e-1)*(t-1)}function tt(e,t){if(!t)return e;switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode "+t)}}function nt(e){const[t,n,r]=Ze(e);return 1===t&&1===n&&1===r}function rt(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat "+e)}function ot(e,t){const n=e[0].length;e.forEach((e,t)=>{y(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),y(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,o)=>{for(let a=0;a<n;a++)y(a===t||e[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function at(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}const st=be({concat_:function(e,t=0){y(e.length>=1,()=>"Pass at least one tensor to concat");let n=we(e,"tensors","concat");"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)});const r=T(t,n[0].shape)[0],o=at(n.map(e=>e.shape),r);if(0===b(o))return Ee([],o);if(n=n.filter(e=>e.size>0),1===n.length)return n[0];ot(n.map(e=>e.shape),r);const a=n,s={axis:t};return ge.runKernelFunc((e,t)=>{const o=e.concat(n,r);return t(n),o},a,null,"Concat",s)}});const it=be({slice_:function(e,t,n){const r=Ce(e,"x","slice");if(0===r.rank)throw new Error("Slicing scalar is not possible");const[o,a]=function(e,t,n){let r,o;return r="number"==typeof t?[t,...new Array(e.rank-1).fill(0)]:t.length<e.rank?t.concat(new Array(e.rank-t.length).fill(0)):t.slice(),r.forEach(e=>{y(-1!==e,()=>"slice() does not support negative begin indexing.")}),o=null==n?new Array(e.rank).fill(-1):"number"==typeof n?[n,...new Array(e.rank-1).fill(-1)]:n.length<e.rank?n.concat(new Array(e.rank-n.length).fill(-1)):n,o=o.map((t,n)=>t>=0?t:(y(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,o]}(r,t,n);!function(e,t,n){y(e.rank===t.length,()=>`Error in slice${e.rank}D: Length of begin ${t} must match the rank of the array (${e.rank}).`),y(e.rank===n.length,()=>`Error in slice${e.rank}D: Length of size ${n} must match the rank of the array (${e.rank}).`);for(let r=0;r<e.rank;++r)y(t[r]+n[r]<=e.shape[r],()=>`Error in slice${e.rank}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}(r,o,a);const s={x:r},i={begin:t,size:n};return ge.runKernelFunc((e,t)=>(t([r]),e.slice(r,o,a)),s,null,"Slice",i)}});function ut(e,t="float32",n){return t=t||"float32",z(e),new ee(e,t,n)}function lt(e,t){const n=e.length,r=[];for(let o=0;o<n;o++){const a=n-1-o,s=e[a]||1;(t[t.length-1-o]||1)>1&&1===s&&r.unshift(a)}return r}function ct(e,t){const n=[];for(let r=0;r<t.length;r++){const o=e[e.length-r-1],a=t.length-r-1,s=t[a];(null==o||1===o&&s>1)&&n.unshift(a)}return n}function dt(e,t){const n=[],r=Math.max(e.length,t.length);for(let o=0;o<r;o++){let r=e[e.length-o-1];null==r&&(r=1);let a=t[t.length-o-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(r)}}return n}const ht=be({equal_:function(e,t){let n=Ce(e,"a","equal"),r=Ce(t,"b","equal");[n,r]=he(n,r),dt(n.shape,r.shape);const o={a:n,b:r};return ge.runKernelFunc(e=>e.equal(n,r),o,null,"Equal")}});const ft=be({elu_:function(e){const t=Ce(e,"x","elu"),n={x:t};return ge.runKernelFunc((e,n)=>{const r=e.elu(t);return n([r]),r},n,null,"Elu")}});const pt=be({expandDims_:function(e,t=0){const n=Ce(e,"x","expandDims",null);y(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r=n.shape.slice();return t<0&&(y(-(n.rank+1)<=t,()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`),t=n.rank+t+1),r.splice(t,0,1),Ie(n,r)}});function mt(e){return e<=30?e:P(e,Math.floor(Math.sqrt(e)))}var gt=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:function(e,t){let n,r=!1;for(e<=30?(n=e,r=!0):n=P(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=P(e,n+1);return n},computeOutShape:function(e,t,n){const r=[],o=e.length;for(let a=0;a<o;a++)a!==t?r.push(e[a]):r.push(n);return r},collectGatherOpShapeInfo:function(e,t,n){const r=e.shape[n],o=[];let a=1,s=1;for(let t=0;t<n;t++)o.push(e.shape[t]),a*=e.shape[t];for(let e=0;e<t.rank;e++)o.push(t.shape[e]);for(let t=n+1;t<e.rank;t++)o.push(e.shape[t]),s*=e.shape[t];return{batchSize:a,sliceSize:s,dimSize:r,outputShape:o}}});const xt=be({imag_:function(e){const t=Ce(e,"input","imag"),n={input:t};return ge.runKernelFunc(e=>e.imag(t),n,null,"Imag")}});const yt=be({real_:function(e){const t=Ce(e,"input","real"),n={input:t};return ge.runKernelFunc(e=>e.real(t),n,null,"Real")}});function vt(e,t){if((k(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&k(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Re(e,[],[],t)}const Ct=be({sum_:function(e,t=null,n=!1){let r=Ce(e,"x","sum");"bool"===r.dtype&&(r=$e(r,"int32"));const o={x:r},a={axis:t,keepDims:n};return ge.runKernelFunc((e,o)=>{o([r]);const a=T(t,r.shape),s=De(a,r.rank);let i=a,u=r;null!=s&&(u=Ae(r,s),i=Me(i.length,r.rank));let l=e.sum(u,i);if(n){const e=Ne(l.shape,a);l=Ie(l,e)}return l},o,null,"Sum",a)}});function wt(e,t="float32"){if("complex64"===t){const t=wt(e,"float32"),n=wt(e,"float32");return _e(t,n)}const n=V(b(e),t);return ge.makeTensor(n,e,t)}const bt=be({prelu_:function(e,t){const n=Ce(e,"x","prelu"),r=Ce(t,"alpha","prelu"),o={x:n,alpha:r};return ge.runKernelFunc((e,t)=>{const o=e.prelu(n,r);return t([n,r]),o},o,null,"Prelu")}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function _t(e,t,n){return e(n={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&n.path)}},n.exports),n.exports}var Rt=_t((function(e){!function(e,t,n){function r(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),a=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,a&&("object"==typeof a&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.alea=a}(0,e,!1)})),Et=_t((function(e){!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.xor128=a}(0,e,!1)})),$t=_t((function(e){!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.xorwow=a}(0,e,!1)})),It=_t((function(e){!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.x&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.xorshift7=a}(0,e,!1)})),At=_t((function(e){!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,s,i=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),o=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(s=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(s=s+1640531527|0,o=0==(n=i[127&a]^=r+s)?o+1:0);for(o>=128&&(i[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=i[o+34&127],n=i[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[o]=r^n;e.w=s,e.X=i,e.i=o}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){null==e&&(e=+new Date);var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&(a.X&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.xor4096=a}(0,e,!1)})),Tt=_t((function(e){!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,a&&("object"==typeof a&&o(a,n),s.state=function(){return o(n,{})}),s}t&&t.exports?t.exports=a:n&&n.amd?n((function(){return a})):this.tychei=a}(0,e,!1)})),St=_t((function(t){!function(n,r){var o,a=this,s=r.pow(256,6),i=r.pow(2,52),u=2*i;function l(e,t,l){var p=[],m=h(function e(t,n){var r,o=[],a=typeof t;if(n&&"object"==a)for(r in t)try{o.push(e(t[r],n-1))}catch(e){}return o.length?o:"string"==a?t:t+"\0"}((t=1==t?{entropy:!0}:t||{}).entropy?[e,f(n)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(256):(e=new Uint8Array(256),(a.crypto||a.msCrypto).getRandomValues(e)),f(e)}catch(e){var t=a.navigator,r=t&&t.plugins;return[+new Date,a,r,a.screen,f(n)]}}():e,3),p),g=new c(p),x=function(){for(var e=g.g(6),t=s,n=0;e<i;)e=256*(e+n),t*=256,n=g.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|g.g(4)},x.quick=function(){return g.g(4)/4294967296},x.double=x,h(f(g.S),n),(t.pass||l||function(e,t,n,o){return o&&(o.S&&d(o,g),e.state=function(){return d(g,{})}),n?(r.random=e,t):e})(x,m,"global"in t?t.global:this==r,t.state)}function c(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);o<256;)s[o]=o++;for(o=0;o<256;o++)s[o]=s[a=255&a+e[o%n]+(t=s[o])],s[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,s=r.S;e--;)t=s[o=255&o+1],n=256*n+s[255&(s[o]=s[a=255&a+t])+(s[a]=t)];return r.i=o,r.j=a,n})(256)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){for(var n,r=e+"",o=0;o<r.length;)t[255&o]=255&(n^=19*t[255&o])+r.charCodeAt(o++);return f(t)}function f(e){return String.fromCharCode.apply(0,e)}if(r.seedrandom=l,h(r.random(),n),t.exports){t.exports=l;try{o=e}catch(e){}}}([],Math)}));St.alea=Rt,St.xor128=Et,St.xorwow=$t,St.xorshift7=It,St.xor4096=At,St.tychei=Tt;var Ot=St;function Nt(e,t){C(e);const n=ye(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Re(e,null,n,t)}const kt=be({relu_:function(e){const t=Ce(e,"x","relu"),n={x:t};return ge.runKernelFunc((e,n)=>(n([t]),"bool"===t.dtype?$e(t,"int32"):e.relu(t)),n,null,"Relu")}});const Dt=be({relu6_:function(e){const t=Ce(e,"x","relu6"),n={x:t};return ge.runKernelFunc((e,n)=>(n([t]),"bool"===t.dtype?$e(t,"int32"):e.relu6(t)),n,null,"Relu6")}});const Ft=be({softmax_:function(e,t=-1){const n=Ce(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},o={dim:t};return ge.runKernelFunc((e,r)=>{const o=e.softmax(n,t);return r([o]),o},r,null,"Softmax",o)}});const Mt=be({stack_:function(e,t=0){const n=we(e,"tensors","stack");if(y(n.length>=1,()=>"Pass at least one tensor to tf.stack"),1===n.length)return pt(n[0],t);const r=n[0].rank,o=n[0].shape,a=n[0].dtype;y(t<=r,()=>"Axis must be <= rank of the tensor"),n.forEach(e=>{v(o,e.shape,"All tensors passed to stack must have matching shapes"),y(a===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const s=n.map(e=>pt(e,t));return st(s,t)}});const Bt=be({step_:function(e,t=0){const n=Ce(e,"x","step"),r={x:n},o={alpha:t};return ge.runKernelFunc(e=>e.step(n,t),r,null,"Step",o)}});function Pt(e,t,n){if(C(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=ye(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Re(e,t,r,n)}function Lt(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=ut(e,"int32"),o=ut([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),s=t*e.length;o.values.set(a,s)}return o.toTensor()}function Wt(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,o=e.length,a=0,s=!1;for(;r<o;){a=r+(o-r>>>1);const i=n(t,e[a]);i>0?r=a+1:(o=a,s=!i)}return s?r:-r-1}(e,t,n||Ut)}(e,t,n),o=r<0?-(r+1):r;e.splice(o,0,t)}function Ut(e,t){return e>t?1:e<t?-1:0}function Vt(e,t,n){const r=e.subarray(4*t,4*t+4),o=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),s=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),d=Math.max(o[0],o[2]),h=Math.max(o[1],o[3]),f=(i-a)*(u-s),p=(d-l)*(h-c);if(f<=0||p<=0)return 0;const m=Math.max(a,l),g=Math.max(s,c),x=Math.min(i,d),y=Math.min(u,h),v=Math.max(x-m,0)*Math.max(y-g,0);return v/(f+p-v)}function Gt(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function zt(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function Ht(e,t,n,r=!0){let o=[];if(r)o=o.concat(t.slice(0)),o.push(e[0]/n),o=o.concat(e.slice(1));else{o=o.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)o=o.concat([e[r+1]/t[r],t[r]]);o=o.concat(e.slice(n+1))}return o}function Xt(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],o=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?o.push(r):n.push(r);r.push(...n),r.push(0),r.push(...o)}return r}function jt(e,t,n,r=!0){const o=[];r?o.push(e[0]/n):o.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?o.push(t[n-1]*e[n]):o.push(e[n]/t[n-1]):o.push(e[n]);return o}function qt(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Kt(e,t,n){const r=e.slice(0,1);for(let o=0;o<n;++o)r.push(e[o+1]-t[o][0]-t[o][1]);return r}function Yt(...e){s().getBool("IS_TEST")||console.warn(...e)}function Qt(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Zt(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Jt(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function en(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function tn(e,t){return{real:e[2*t],imag:e[2*t+1]}}function nn(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function rn(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let o=0;o<Math.ceil(e/2);o++){const a=(t?2:-2)*Math.PI*(o/e);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}function on(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}function an(e,t,n){if("complex64"===t){if("complex64"===e.dtype)return e.clone();const t=wt(e.shape),r=$e(e,"float32"),o=n.complex(r,t);return t.dispose(),r.dispose(),o}if(r=e.dtype,"complex64"===(o=t)||"float32"===o&&"complex64"!==r||"int32"===o&&"float32"!==r&&"complex64"!==r||"bool"===o&&"bool"===r)return ge.makeTensorFromDataId(e.dataId,e.shape,t);var r,o;if("complex64"===e.dtype){const r=n.real(e),o=$e(r,t);return r.dispose(),o}if("int32"===t)return n.int(e);if("bool"===t){const t=vt(0,e.dtype),r=n.notEqual(e,t);return t.dispose(),r}throw new Error(`Error in Cast: failed to cast ${e.dtype} to ${t}`)}function sn(e,t){return ge.makeTensorFromDataId(e.dataId,t,e.dtype)}function un(e,t,n){const r=(t-e)/(n-1),o=V(n,"float32");o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+r;return Nt(o,"float32")}var ln=Object.freeze({__proto__:null,segment_util:gt,castTensor:an,reshapeTensor:sn,linspaceImpl:un,upcastType:ce,axesAreInnerMostDims:Te,combineLocations:Se,computeOutAndReduceShapes:Oe,expandShapeToKeepDim:Ne,assertAxesAreInnerMostDims:ke,getAxesPermutation:De,getUndoAxesPermutation:Fe,getInnerMostAxes:Me,getBroadcastDims:lt,getReductionAxes:ct,assertAndGetBroadcastShape:dt,assertParamsConsistent:ot,computeOutShape:at,computeDilation2DInfo:function(e,t,n,r,o="NHWC",a){return Ke(e,[...t,e[3]],n,a,r,null,null,rt(o))},computePool2DInfo:function(e,t,n,r,o,a,s="channelsLast"){const[i,u]=Ze(t);let l;if("channelsLast"===s)l=[i,u,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);l=[i,u,e[1],e[1]]}return Ke(e,l,n,r,o,a,!1,s)},computePool3DInfo:function(e,t,n,r,o,a,s="NDHWC"){const[i,u,l]=Je(t);let c,d;if("NDHWC"===s)d="channelsLast",c=[i,u,l,e[4],e[4]];else{if("NCDHW"!==s)throw new Error("Unknown dataFormat "+s);d="channelsFirst",c=[i,u,l,e[1],e[1]]}return Ye(e,c,n,r,o,!1,d,a)},computeConv2DInfo:Ke,computeConv3DInfo:Ye,computeDefaultPad:Qe,tupleValuesAreOne:nt,eitherStridesOrDilationsAreOne:function(e,t){return nt(e)||nt(t)},convertConv2DDataFormat:rt,getFusedDyActivation:function(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return qe(e,Bt(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)},getFusedBiasGradient:function(e,t){let n=t;const r=ct(e.shape,t.shape);return r.length>0&&(n=Ct(n,r)),Ie(n,e.shape)},applyActivation:function(e,t,n){if("linear"===t)return e;if("relu"===t)return kt(e);if("elu"===t)return ft(e);if("relu6"===t)return Dt(e);if("prelu"===t)return bt(e,n);throw new Error(`Unknown fused activation ${t}.`)},shouldFuse:(e,t)=>!(e>0)||"linear"===t,PARALLELIZE_THRESHOLD:30,computeOptimalWindowSize:mt,getImageCenter:function(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]},getReshaped:Ht,getPermuted:Xt,getReshapedPermuted:jt,getSliceBeginCoords:qt,getSliceSize:Kt,prepareAndValidate:Pe,validateUpdateShape:Le,validateInput:function(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: "+t.shape);if(0===e.size)throw new Error("Updates specified for empty output. updates shape: "+e.shape)}Le(n,t,e)},calculateShapes:We,SELU_SCALEALPHA:1.7580993408473768,SELU_SCALE:1.0507009873554805,ERF_P:.3275911,ERF_A1:.254829592,ERF_A2:-.284496736,ERF_A3:1.421413741,ERF_A4:-1.453152027,ERF_A5:1.061405429,warn:Yt,log:function(...e){s().getBool("IS_TEST")||console.log(...e)},mergeRealAndImagArrays:Qt,splitRealAndImagArrays:Zt,complexWithEvenIndex:Jt,complexWithOddIndex:en,getComplexWithIndex:tn,assignToTypedArray:nn,exponents:rn,exponent:on,prepareSplitSize:function(e,t,n=0){let r=[];if("number"==typeof t)y(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{y(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(-1!==o){const r=t.reduce((e,t)=>t>0?e+t:e);t[o]=e.shape[n]-r}y(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}});function cn(){if("undefined"!=typeof navigator&&null!=navigator){const e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function dn(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}function hn(e,t,n){const r=new Array(e.rank).fill(0),o=e.shape.slice();return t.map(t=>{const a=[...o];a[n]=t;const s=it(e,r,a);return r[n]+=t,s})}function fn(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=ut(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),o=new Array(e.rank);for(let t=0;t<o.length;t++)o[t]=n[t]%e.shape[t];const a=e.locToIndex(o);r.values[t]=e.values[a]}return r.toTensor()}function pn(e,t,n,r,o){const a=t[t.length-1],[s,i]=[e.length/a,a],u=O(n,s*r),l=O("int32",s*r);for(let t=0;t<s;t++){const n=t*i,o=e.subarray(n,n+i),a=[];for(let e=0;e<o.length;e++)a.push({value:o[e],index:e});a.sort((e,t)=>t.value-e.value);const s=t*r,c=u.subarray(s,s+r),d=l.subarray(s,s+r);for(let e=0;e<r;e++)c[e]=a[e].value,d[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[Ee(u,c,n),Ee(l,c,"int32")]}class mn{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class gn{time(e){return xn("time")}read(e){return xn("read")}readSync(e){return xn("readSync")}numDataIds(){return xn("numDataIds")}disposeData(e){return xn("disposeData")}write(e,t,n){return xn("write")}move(e,t,n,r){return xn("move")}memory(){return xn("memory")}floatPrecision(){return xn("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(e,t,n,r){return xn("batchMatMul")}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:r,bias:o,activation:a,preluActivationWeights:s}){return xn("fusedBatchMatMul")}slice(e,t,n){return xn("slice")}stridedSlice(e,t,n,r){return xn("stridedSlice")}unstack(e,t){return xn("unstack")}reverse(e,t){return xn("reverse")}concat(e,t){return xn("concat")}neg(e){return xn("neg")}add(e,t){return xn("add")}addN(e){return xn("addN")}subtract(e,t){return xn("subtract")}multiply(e,t){return xn("multiply")}realDivide(e,t){return xn("realDivide")}floorDiv(e,t){return xn("floorDiv")}sum(e,t){return xn("sum")}prod(e,t){return xn("prod")}unsortedSegmentSum(e,t,n){return xn("unsortedSegmentSum")}argMin(e,t){return xn("argMin")}argMax(e,t){return xn("argMax")}equal(e,t){return xn("equal")}notEqual(e,t){return xn("notEqual")}less(e,t){return xn("less")}lessEqual(e,t){return xn("lessEqual")}greater(e,t){return xn("greater")}greaterEqual(e,t){return xn("greaterEqual")}logicalNot(e){return xn("logicalNot")}logicalAnd(e,t){return xn("logicalAnd")}logicalOr(e,t){return xn("logicalOr")}where(e){return xn("where")}select(e,t,n){return xn("select")}topk(e,t,n){return xn("topk")}min(e,t){return xn("min")}minimum(e,t){return xn("minimum")}mod(e,t){return xn("mod")}max(e,t){return xn("max")}maximum(e,t){return xn("maximum")}all(e,t){return xn("all")}any(e,t){return xn("any")}squaredDifference(e,t){return xn("squaredDifference")}ceil(e){return xn("ceil")}floor(e){return xn("floor")}round(e){return xn("round")}sign(e){return xn("sign")}isNaN(e){return xn("isNaN")}isInf(e){return xn("isInf")}isFinite(e){return xn("isFinite")}pow(e,t){return xn("pow")}exp(e){return xn("exp")}expm1(e){return xn("expm1")}softmax(e,t){return xn("softmax")}log(e){return xn("log")}log1p(e){return xn("log1p")}sqrt(e){return xn("sqrt")}rsqrt(e){return xn("rsqrt")}square(e){return xn("square")}reciprocal(e){return xn("reciprocal")}relu(e){return xn("relu")}relu6(e){return xn("relu6")}prelu(e,t){return xn("prelu")}elu(e){return xn("elu")}eluDer(e,t){return xn("eluDer")}selu(e){return xn("selu")}int(e){return xn("int")}clip(e,t,n){return xn("clip")}abs(e){return xn("abs")}complexAbs(e){return xn("complexAbs")}sigmoid(e){return xn("sigmoid")}softplus(e){return xn("softplus")}sin(e){return xn("sin")}cos(e){return xn("cos")}tan(e){return xn("tan")}asin(e){return xn("asin")}acos(e){return xn("acos")}atan(e){return xn("atan")}atan2(e,t){return xn("atan2")}sinh(e){return xn("sinh")}cosh(e){return xn("cosh")}tanh(e){return xn("tanh")}asinh(e){return xn("asinh")}acosh(e){return xn("acosh")}atanh(e){return xn("atanh")}erf(e){return xn("erf")}step(e,t){return xn("step")}fusedConv2d({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){return xn("fusedConv2d")}conv2d(e,t,n){return xn("conv2d")}conv2dDerInput(e,t,n){return xn("conv2dDerInput")}conv2dDerFilter(e,t,n){return xn("conv2dDerFilter")}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){return xn("fusedDepthwiseConv2D")}depthwiseConv2D(e,t,n){return xn("depthwiseConv2D")}depthwiseConv2DDerInput(e,t,n){return xn("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(e,t,n){return xn("depthwiseConv2DDerFilter")}conv3d(e,t,n){return xn("conv3d")}conv3dDerInput(e,t,n){return xn("conv3dDerInput")}conv3dDerFilter(e,t,n){return xn("conv3dDerFilter")}maxPool(e,t){return xn("maxPool")}maxPoolBackprop(e,t,n,r){return xn("maxPoolBackprop")}avgPool(e,t){return xn("avgPool")}avgPoolBackprop(e,t,n){return xn("avgPoolBackprop")}avgPool3d(e,t){return xn("avgPool3d")}avgPool3dBackprop(e,t,n){return xn("avgPool3dBackprop")}maxPool3d(e,t){return xn("maxPool3d")}maxPool3dBackprop(e,t,n,r){return xn("maxPool3dBackprop")}reshape(e,t){return xn("reshape")}cast(e,t){return xn("cast")}tile(e,t){return xn("tile")}pad(e,t,n){return xn("pad")}transpose(e,t){return xn("transpose")}gather(e,t,n){return xn("gather")}gatherND(e,t){return xn("gatherND")}scatterND(e,t,n){return xn("scatterND")}batchToSpaceND(e,t,n){return xn("batchToSpaceND")}spaceToBatchND(e,t,n){return xn("spaceToBatchND")}resizeBilinear(e,t,n,r){return xn("resizeBilinear")}resizeBilinearBackprop(e,t,n){return xn("resizeBilinearBackprop")}resizeNearestNeighbor(e,t,n,r){return xn("resizeNearestNeighbor")}resizeNearestNeighborBackprop(e,t,n){return xn("resizeNearestNeighborBackprop")}batchNorm(e,t,n,r,o,a){return xn("batchNorm")}localResponseNormalization4D(e,t,n,r,o){return xn("localResponseNormalization4D")}LRNGrad(e,t,n,r,o,a,s){return xn("LRNGrad")}multinomial(e,t,n,r){return xn("multinomial")}oneHot(e,t,n,r){return xn("oneHot")}cumsum(e,t,n,r){return xn("cumsum")}nonMaxSuppression(e,t,n,r,o){return xn("nonMaxSuppression")}fft(e){return xn("fft")}ifft(e){return xn("ifft")}complex(e,t){return xn("complex")}real(e){return xn("real")}imag(e){return xn("imag")}cropAndResize(e,t,n,r,o,a){return xn("cropAndResize")}depthToSpace(e,t,n){return xn("depthToSpace")}split(e,t,n){return xn("split")}sparseToDense(e,t,n,r){return xn("sparseToDense")}diag(e){return xn("diag")}fill(e,t,n){return xn("fill")}onesLike(e){return xn("onesLike")}zerosLike(e){return xn("zerosLike")}linspace(e,t,n){return xn("linspace")}dispose(){return xn("dispose")}}function xn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. Did you forget to import the kernel?`)}const yn=s();yn.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),yn.registerFlag("IS_BROWSER",()=>dn()),yn.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),yn.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),yn.registerFlag("PROD",()=>!1),yn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>yn.getBool("DEBUG")),yn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),yn.registerFlag("IS_TEST",()=>!1);class vn{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got "+t);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}s().get("IS_BROWSER")&&s().setPlatform("browser",new vn);const Cn=()=>require("node-fetch");let wn;class bn{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=s().global.fetch?s().global.fetch(e,t):(null==wn&&(wn=Cn()),wn(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got "+t);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}var _n,Rn;function En(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&y("complex64"!==e.dtype,()=>t+" does not support complex64 tensors in the CPU backend.")})}function $n(e,t,n,r,o,a){const s=o.strideHeight,i=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.top,f=o.padInfo.left,p="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ut(o.outShape,n),g=m.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],y=o.outShape[2]*o.outShape[3],v=o.outShape[3];for(let t=0;t<o.batchSize;++t){const n=t*x,m=t*r[0];for(let t=0;t<o.inChannels;++t)for(let x=0;x<o.outHeight;++x){const C=x*s-h,w=Math.max(0,C),b=Math.min(o.inHeight,c+C),_=n+x*y;for(let n=0;n<o.outWidth;++n){const s=n*i-f,c=Math.max(0,s),h=Math.min(o.inWidth,d+s);let x=p,y=0,C=0;for(let n=w;n<b;n+=u){const o=m+n*r[1];for(let n=c;n<h;n+=l){const s=e[o+n*r[2]+t];"max"===a&&s>x?x=s:"avg"===a&&(y+=s,C++)}if(isNaN(x))break}g[_+n*v+t]="avg"===a?y/C:x}}}return m}s().get("IS_NODE")&&s().setPlatform("node",new bn),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(_n||(_n={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Rn||(Rn={}));const In=function(e,t,n,r,o){return function(e,t,n,r,o,a,s=!1,i=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>o&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(zt);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:s}=t;if(n<o)break;let i=!1;for(let n=d.length-1;n>=s;--n){const s=Vt(e,a,d[n]);if(s>=r){i=!0;break}if(t.score=t.score*Gt(r,c,s),t.score<=o)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(a),h.push(t.score)):t.score>o&&Wt(l,t,zt))}const f=d.length,p=n-f;i&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:Nt(d,"int32")};s&&(m.selectedScores=Nt(h,"float32"));u&&(m.validOutputs=vt(f,"int32"));return m}(e,t,n,r,o,0).selectedIndices},An=hn,Tn=fn,Sn=pn,On=Lt;function Nn(e,t,n,r){if("linear"===n)return e.linear(t);if("relu"===n)return e.relu(t);if("elu"===n)return e.elu(t);if("relu6"===n)return e.relu6(t);if("prelu"===n)return e.prelu(t,r);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class kn extends gn{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new mn(this,ze())}write(e,t,n){this.firstUse&&(this.firstUse=!1,s().get("IS_NODE")&&Yt("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:e,dtype:n}),r}move(e,t,n,r){this.data.set(e,{values:t,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensors:n}=this.data.get(e);if("complex64"===t){return Qt(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>H(e))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return ut(e.shape,e.dtype,n)}makeOutput(e,t,n){const r=this.write(e,t,n);return ze().makeTensorFromDataId(r,t,n,this)}disposeData(e){if(this.data.has(e)){const{complexTensors:t}=this.data.get(e);null!=t&&(t.real.dispose(),t.imag.dispose()),this.data.delete(e)}}async time(e){const t=G();e();return{kernelMs:G()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(e,t){const n=this.makeOutput(null,e.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:ze().keep(e.clone()),imag:ze().keep(t.clone())},n}real(e){return this.data.get(e.dataId).complexTensors.real.clone()}imag(e){return this.data.get(e.dataId).complexTensors.imag.clone()}slice(e,t,n){En(e,"slice");if(Ve(e.shape,t,n)){const r=Ge(t,e.strides),o=b(n);return Ee(this.readSync(e.dataId).subarray(r,r+o),n,e.dtype)}const r=ut(n,e.dtype),o=this.bufferSync(e);for(let e=0;e<r.size;++e){const n=r.indexToLoc(e).map((e,n)=>e+t[n]);r.values[e]=o.get(...n)}return r.toTensor()}stridedSlice(e,t,n,r){En(e,"stridedSlice");const o=Ue(t,n,r);if(o.some(e=>0===e))return Ee([],o);const a=ut(o,e.dtype),s=this.bufferSync(e);for(let e=0;e<a.size;e++){const n=a.indexToLoc(e),o=new Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[e]*r[e]+t[e];a.set(s.get(...o),...n)}return a.toTensor()}diag(e){const t=this.readSync(e.dataId),n=ut([e.size,e.size],e.dtype),r=n.values;for(let n=0;n<t.length;n++)r[n*e.size+n]=t[n];return n.toTensor()}unstack(e,t){const n=e.shape[t],r=new Array(e.rank-1);let o=0;for(let n=0;n<e.rank;n++)n!==t&&(r[o++]=e.shape[n]);const a=new Array(e.rank).fill(0),s=e.shape.slice();s[t]=1;const i=new Array(n);for(let n=0;n<i.length;n++)a[t]=n,i[n]=this.slice(e,a,s).reshape(r);return i}reverse(e,t){En(e,"reverse");const n=ut(e.shape,e.dtype),r=this.bufferSync(e);for(let o=0;o<n.size;o++){const a=n.indexToLoc(o),s=a.slice();t.forEach(t=>s[t]=e.shape[t]-1-s[t]),n.set(r.get(...s),...a)}return n.toTensor()}concat(e,t){if("complex64"===e[0].dtype){const n=e.map(e=>yt(e)),r=e.map(e=>xt(e));return _e(this.concat(n,t),this.concat(r,t))}const n=e.map(e=>{const n=b(e.shape.slice(t));return e.as2D(-1,n)}),r=at(n.map(e=>e.shape),1),o=ut(r,e[0].dtype).values;if(1===n[0].shape[0]){let e=0;n.forEach(t=>{o.set(this.readSync(t.dataId),e),e+=t.size})}else{let e=0;n.forEach(t=>{const n=this.readSync(t.dataId);let a=0;for(let s=0;s<t.shape[0];++s){const i=s*r[1]+e;for(let e=0;e<t.shape[1];++e)o[i+e]=n[a++]}e+=t.shape[1]})}const a=at(e.map(e=>e.shape),t);return Ee(o,a,e[0].dtype)}neg(e){return En(e,"neg"),this.multiply(vt(-1),e)}add(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),(e,t,n,r)=>({real:e+n,imag:t+r})):this.broadcastedBinaryOp(e,t,ce(e.dtype,t.dtype),(e,t)=>e+t)}addN(e){En(e,"addN");const t=e.map(e=>this.readSync(e.dataId)),n=ut(e[0].shape,e[0].dtype),r=n.values;for(let n=0;n<e.length;n++){const e=t[n];for(let t=0;t<r.length;t++)r[t]+=e[t]}return n.toTensor()}softmax(e,t){const n=T([t],e.shape),r=Be(e,n),o=Ne(r.shape,n),a=this.subtract(e,r.reshape(o)),s=this.exp(a),i=this.sum(s,n).reshape(o);return je(s,i)}subtract(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),(e,t,n,r)=>({real:e-n,imag:t-r})):this.broadcastedBinaryOp(e,t,ce(e.dtype,t.dtype),(e,t)=>e-t)}pow(e,t){return En([e,t],"pow"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.pow(e,t))}batchMatMul(e,t,n,r){En([e,t],"matMul");const o=n?e.shape[1]:e.shape[2],a=n?e.shape[2]:e.shape[1],s=r?t.shape[1]:t.shape[2],i=e.shape[0],u=this.readSync(e.dataId),l=this.readSync(t.dataId),[c,d,h]=n?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],[f,p,m]=r?[1,t.strides[1],t.strides[0]]:[t.strides[1],1,t.strides[0]],g=a*s,x=ut([i,a,s],e.dtype),y=x.values,v=this.blockSize;for(let e=0;e<i;e++)for(let t=0;t<a;t+=v)for(let n=0;n<s;n+=v)for(let r=0;r<o;r+=v){const i=Math.min(t+v,a),x=Math.min(n+v,s),C=Math.min(r+v,o);for(let o=t;o<i;o++)for(let t=n;t<x;t++){let n=0;for(let a=r;a<C;a++)n+=u[e*c+o*d+a*h]*l[a*f+t*p+e*m];y[e*g+(o*s+t)]+=n}}return x.toTensor()}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:r,bias:o,activation:a,preluActivationWeights:s}){let i=this.batchMatMul(e,t,n,r);return o&&(i=this.add(i,o)),a&&(i=Nn(this,i,a,s)),i}multiply(e,t){return"complex64"===e.dtype||"complex64"===t.dtype?this.broadcastedBinaryComplexOp(e.cast("complex64"),t.cast("complex64"),(e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})):this.broadcastedBinaryOp(e,t,ce(e.dtype,t.dtype),(e,t)=>e*t)}floorDiv(e,t){En([e,t],"floorDiv");return this.broadcastedBinaryOp(e,t,"int32",(e,t)=>Math.floor(e/t))}sum(e,t){En(e,"sum"),ke("sum",t,e.rank);const[n,r]=Oe(e.shape,t),o=wt(n,ce(e.dtype,"int32")),a=b(r),s=this.readSync(o.dataId),i=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=e*a;let n=0;for(let e=0;e<a;++e)n+=i[t+e];s[e]=n}return o}prod(e,t){En(e,"sum");const[n,r]=Oe(e.shape,t),o=wt(n,ce(e.dtype,"int32")),a=b(r),s=this.readSync(o.dataId),i=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=e*a;let n=1;for(let e=0;e<a;++e)n*=i[t+e];s[e]=n}return o}unsortedSegmentSum(e,t,n){En(e,"unsortedSegmentSum");const r=[],o=e.rank-t.rank;for(let e=0;e<o;++e)t=t.expandDims(e+1);for(let o=0;o<n;++o){const n=vt(o,"int32"),a=ht(n,t).asType("float32").mul(e).sum(0);r.push(a)}return Mt(r)}argMin(e,t){En(e,"argMin");const n=[t];ke("argMin",n,e.rank);const[r,o]=Oe(e.shape,n),a=wt(r,"int32"),s=b(o),i=this.readSync(a.dataId),u=this.readSync(e.dataId);for(let e=0;e<i.length;++e){const t=e*s;let n=u[t],r=0;for(let e=0;e<s;++e){const o=u[t+e];o<n&&(n=o,r=e)}i[e]=r}return a}argMax(e,t){En(e,"argMax");const n=[t];ke("argMax",n,e.rank);const[r,o]=Oe(e.shape,n),a=wt(r,"int32"),s=b(o),i=this.readSync(a.dataId),u=this.readSync(e.dataId);for(let e=0;e<i.length;++e){const t=e*s;let n=u[t],r=0;for(let e=0;e<s;++e){const o=u[t+e];o>n&&(n=o,r=e)}i[e]=r}return a}cumsum(e,t,n,r){if(En(e,"cumsum"),t!==e.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${e.rank-1} but got axis=`+t);const o=ce(e.dtype,"int32"),a=wt(e.shape,o),s=this.readSync(a.dataId),i=this.readSync(e.dataId),u=e.shape[e.rank-1],l=r?(e,t)=>e+u-t-1:(e,t)=>e+t;for(let e=0;e<i.length;e+=u)for(let t=0;t<u;t++){const r=l(e,t);if(0===t)s[r]=n?0:i[r];else{const o=l(e,t-1);s[r]=n?i[o]+s[o]:i[r]+s[o]}}return a}equal(e,t){return En([e,t],"equal"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e===t?1:0)}notEqual(e,t){return En([e,t],"notEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e!==t?1:0)}less(e,t){return En([e,t],"less"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e<t?1:0)}lessEqual(e,t){return En([e,t],"lessEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e<=t?1:0)}greater(e,t){return En([e,t],"greater"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e>t?1:0)}greaterEqual(e,t){return En([e,t],"greaterEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e>=t?1:0)}logicalNot(e){En(e,"logicalNot");const t=this.readSync(e.dataId),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n[e]=t[e]?0:1;return this.makeOutput(n,e.shape,"bool")}logicalAnd(e,t){return En([e,t],"logicalAnd"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e&&t)}logicalOr(e,t){return En([e,t],"logicalOr"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e||t)}select(e,t,n){En([e,t,n],"select");const r=this.readSync(e.dataId),o=this.readSync(t.dataId),a=this.readSync(n.dataId),s=wt(t.shape,ce(t.dtype,n.dtype)),i=this.readSync(s.dataId);let u=0;const l=0===e.rank||e.rank>1||1===t.rank?1:b(t.shape.slice(1));for(let e=0;e<r.length;e++)for(let t=0;t<l;t++)1===r[e]?i[u++]=o[e]:i[u++]=a[e];return s}where(e){En([e],"where");const t=this.readSync(e.dataId);return On(e.shape,t)}topk(e,t,n){En(e,"topk");const r=this.readSync(e.dataId);return Sn(r,e.shape,e.dtype,t)}min(e,t){En(e,"min"),ke("min",t,e.rank);const[n,r]=Oe(e.shape,t),o=wt(n,e.dtype),a=b(r),s=this.readSync(o.dataId),i=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=e*a;let n=i[t];for(let e=0;e<a;++e){const r=i[t+e];r<n&&(n=r)}s[e]=n}return o}minimum(e,t){return En([e,t],"minimum"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.min(e,t))}mod(e,t){return En([e,t],"mod"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})}maximum(e,t){return En([e,t],"maximum"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.max(e,t))}all(e,t){En(e,"all"),ke("all",t,e.rank);const[n,r]=Oe(e.shape,t),o=wt(n,e.dtype),a=b(r),s=this.readSync(o.dataId),i=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=e*a;let n=i[t];for(let e=0;e<a;++e){const r=i[t+e];n=n&&r}s[e]=n}return o}any(e,t){En(e,"any"),ke("any",t,e.rank);const[n,r]=Oe(e.shape,t),o=wt(n,e.dtype),a=b(r),s=this.readSync(o.dataId),i=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=e*a;let n=i[t];for(let e=0;e<a;++e){const r=i[t+e];n=n||r}s[e]=n}return o}squaredDifference(e,t){return En([e,t],"squaredDifference"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>{const n=e-t;return n*n})}ceil(e){En(e,"ceil");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.ceil(t[e]);return this.makeOutput(n,e.shape,"float32")}floor(e){En(e,"floor");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.floor(t[e]);return this.makeOutput(n,e.shape,"float32")}sign(e){En(e,"x");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)t[e]<0?n[e]=-1:t[e]>0?n[e]=1:n[e]=0;return this.makeOutput(n,e.shape,"float32")}isNaN(e){En(e,"x");const t=this.readSync(e.dataId),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)Number.isNaN(t[e])&&(n[e]=1);return this.makeOutput(n,e.shape,"bool")}isInf(e){En(e,"x");const t=this.readSync(e.dataId),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)Math.abs(t[e])===1/0&&(n[e]=1);return this.makeOutput(n,e.shape,"bool")}isFinite(e){En(e,"x");const t=this.readSync(e.dataId),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)Number.isFinite(t[e])&&(n[e]=1);return this.makeOutput(n,e.shape,"bool")}round(e){En(e,"round");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e){const r=Math.floor(t[e]);t[e]-r<.5?n[e]=Math.floor(t[e]):t[e]-r>.5?n[e]=Math.ceil(t[e]):n[e]=r%2==0?r:r+1}return this.makeOutput(n,e.shape,"float32")}exp(e){En(e,"exp");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.exp(t[e]);return this.makeOutput(n,e.shape,"float32")}expm1(e){En(e,"expm1");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.expm1(t[e]);return this.makeOutput(n,e.shape,"float32")}log(e){En(e,"log");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e){const r=t[e];n[e]=Math.log(r)}return this.makeOutput(n,e.shape,"float32")}log1p(e){En(e,"log1p");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e){const r=t[e];n[e]=Math.log1p(r)}return this.makeOutput(n,e.shape,"float32")}sqrt(e){En(e,"sqrt");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e){const r=t[e];n[e]=Math.sqrt(r)}return this.makeOutput(n,e.shape,"float32")}rsqrt(e){En(e,"rsqrt");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e){const r=t[e];n[e]=1/Math.sqrt(r)}return this.makeOutput(n,e.shape,"float32")}reciprocal(e){En(e,"reciprocal");const t=this.readSync(e.dataId),n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=1/t[e];return this.makeOutput(n,e.shape,"float32")}linear(e){return e}relu(e){En(e,"relu");const t=wt(e.shape,e.dtype),n=this.readSync(t.dataId),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e)n[e]=Math.max(0,r[e]);return t}relu6(e){En(e,"relu");const t=wt(e.shape,e.dtype),n=this.readSync(t.dataId),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e)n[e]=Math.min(Math.max(0,r[e]),6);return t}prelu(e,t){return En([e,t],"prelu"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>e<0?t*e:e)}elu(e){En(e,"elu");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e){const r=n[e];t[e]=r>=0?r:Math.exp(r)-1}return this.makeOutput(t,e.shape,"float32")}eluDer(e,t){En([e,t],"eluDer");const n=new Float32Array(t.size),r=this.readSync(t.dataId),o=this.readSync(e.dataId);for(let e=0;e<r.length;++e){const t=r[e];n[e]=t>=1?o[e]:o[e]*(t+1)}return this.makeOutput(n,t.shape,"float32")}selu(e){En(e,"selu");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e){const r=n[e];t[e]=r>=0?1.0507009873554805*r:1.7580993408473768*(Math.exp(r)-1)}return this.makeOutput(t,e.shape,"float32")}clip(e,t,n){En(e,"clip");const r=new Float32Array(e.size),o=this.readSync(e.dataId);for(let e=0;e<o.length;++e){const a=o[e];r[e]=a>n?n:a<t?t:a}return this.makeOutput(r,e.shape,"float32")}abs(e){const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return this.makeOutput(t,e.shape,"float32")}complexAbs(e){const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let r=0;r<e.size;++r){const e=n[2*r],o=n[2*r+1];t[r]=Math.hypot(e,o)}return this.makeOutput(t,e.shape,"float32")}int(e){En(e,"int");const t=new Int32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=n[e];return this.makeOutput(t,e.shape,"int32")}sigmoid(e){En(e,"sigmoid");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=1/(1+Math.exp(-n[e]));return this.makeOutput(t,e.shape,"float32")}softplus(e){En(e,"softplus");const t=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(e.size),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e){const o=r[e]>-t,a=r[e]<t,s=Math.exp(r[e]);let i;i=a?s:o?r[e]:Math.log(1+s),n[e]=i}return this.makeOutput(n,e.shape,"float32")}sin(e){En(e,"sin");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.sin(n[e]);return this.makeOutput(t,e.shape,"float32")}cos(e){En(e,"cos");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.cos(n[e]);return this.makeOutput(t,e.shape,"float32")}tan(e){En(e,"tan");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.tan(n[e]);return this.makeOutput(t,e.shape,"float32")}asin(e){En(e,"asin");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.asin(n[e]);return this.makeOutput(t,e.shape,"float32")}acos(e){En(e,"acos");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.acos(n[e]);return this.makeOutput(t,e.shape,"float32")}atan(e){En(e,"atan");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.atan(n[e]);return this.makeOutput(t,e.shape,"float32")}atan2(e,t){return En([e,t],"atan2"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.atan2(e,t))}sinh(e){En(e,"sinh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.sinh(n[e]);return this.makeOutput(t,e.shape,"float32")}cosh(e){En(e,"cosh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.cosh(n[e]);return this.makeOutput(t,e.shape,"float32")}tanh(e){En(e,"tanh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=E(n[e]);return this.makeOutput(t,e.shape,"float32")}asinh(e){En(e,"asinh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.asinh(n[e]);return this.makeOutput(t,e.shape,"float32")}acosh(e){En(e,"acosh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.acosh(n[e]);return this.makeOutput(t,e.shape,"float32")}atanh(e){En(e,"atanh");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e)t[e]=Math.atanh(n[e]);return this.makeOutput(t,e.shape,"float32")}erf(e){En(e,"erf");const t=new Float32Array(e.size),n=this.readSync(e.dataId);for(let e=0;e<n.length;++e){const r=Math.sign(n[e]),o=Math.abs(n[e]),a=1/(1+.3275911*o);t[e]=r*(1-((((1.061405429*a-1.453152027)*a+1.421413741)*a-.284496736)*a+.254829592)*a*Math.exp(-o*o))}return this.makeOutput(t,e.shape,"float32")}step(e,t=0){En(e,"step");const n=new Float32Array(e.size),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e){const o=r[e];isNaN(o)?n[e]=NaN:n[e]=o>0?1:t}return this.makeOutput(n,e.shape,"float32")}fusedConv2d({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){let s=this.conv2d(e,t,n);return r&&(s=this.add(s,r)),o&&(s=Nn(this,s,o,a)),s}conv2d(e,t,n){En([e,t],"conv2d");const r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,s=n.dilationWidth,i=n.padInfo.left,u=n.padInfo.top,l="channelsLast"===n.dataFormat,c=ut(n.outShape,e.dtype),d=e.strides[0],h=l?e.strides[1]:e.strides[2],f=l?e.strides[2]:1,p=l?1:e.strides[1],m=c.strides[0],g=l?c.strides[1]:c.strides[2],x=l?c.strides[2]:1,y=l?1:c.strides[1],v=this.readSync(e.dataId),C=this.readSync(t.dataId),w=c.values;for(let e=0;e<n.batchSize;++e){const l=e*d,c=e*m;for(let e=0;e<n.outHeight;++e){const d=c+e*g,m=e*n.strideHeight-u;for(let e=0;e<r;e++){const r=m+e*a;if(r<0||r>=n.inHeight)continue;const u=e*t.strides[0],c=l+r*h;for(let e=0;e<n.outWidth;++e){const r=d+e*x,a=e*n.strideWidth-i;for(let e=0;e<o;e++){const o=a+e*s;if(o<0||o>=n.inWidth)continue;const i=c+o*f;let l=u+e*t.strides[1];for(let e=0;e<n.inChannels;++e){const t=v[i+e*p];for(let e=0;e<n.outChannels;++e)w[r+e*y]+=t*C[l+e];l+=n.outChannels}}}}}}return c.toTensor()}conv3d(e,t,n){const r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,s=n.dilationDepth,i=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.front,c=n.padInfo.left,d=n.padInfo.top,h=ut(n.outShape,e.dtype),f=this.readSync(e.dataId),p=this.readSync(t.dataId),m=h.values;for(let g=0;g<n.batchSize;++g){const x=g*e.strides[0],y=g*h.strides[0];for(let g=0;g<n.outDepth;++g){const v=y+g*h.strides[1],C=g*n.strideDepth-l;for(let l=0;l<r;l++){const r=C+l*s;if(r<0||r>=n.inDepth)continue;const g=l*t.strides[0],y=x+r*e.strides[1];for(let r=0;r<n.outHeight;++r){const s=v+r*h.strides[2],l=r*n.strideHeight-d;for(let r=0;r<o;r++){const o=l+r*i;if(o<0||o>=n.inHeight)continue;const d=g+r*t.strides[1],h=y+o*e.strides[2];for(let e=0;e<n.outWidth;++e){const r=s+e*n.outChannels,o=e*n.strideWidth-c;for(let e=0;e<a;e++){const a=o+e*u;if(a<0||a>=n.inWidth)continue;const s=d+e*t.strides[2],i=h+a*n.inChannels;let l=s;for(let e=0;e<n.inChannels;++e){const t=f[i+e];for(let e=0;e<n.outChannels;++e)m[r+e]+=t*p[l+e];l+=n.outChannels}}}}}}}}return h.toTensor()}conv2dDerInput(e,t,n){En([e,t],"conv2dDerInput");const r=ut(n.inShape,"float32"),o=r.values,a=this.readSync(e.dataId),s=this.readSync(t.dataId),[i,u,l]=t.strides,{batchSize:c,filterHeight:d,filterWidth:h,inChannels:f,inHeight:p,inWidth:m,outChannels:g,outHeight:x,outWidth:y,strideHeight:v,strideWidth:C,dataFormat:w}=n,b=d-1-n.padInfo.top,_=h-1-n.padInfo.left,R="channelsLast"===w,E=r.strides[0],$=R?r.strides[1]:r.strides[2],I=R?r.strides[2]:1,A=R?1:r.strides[1],T=e.strides[0],S=R?e.strides[1]:e.strides[2],O=R?e.strides[2]:1,N=R?1:e.strides[1];for(let e=0;e<c;++e)for(let t=0;t<f;++t)for(let n=0;n<p;++n){const r=n-b,c=Math.max(0,Math.ceil(r/v)),f=Math.min(x,(d+r)/v);for(let p=0;p<m;++p){const m=p-_,x=Math.max(0,Math.ceil(m/C)),w=Math.min(y,(h+m)/C);let b=0;for(let n=c;n<f;++n){const o=n*v-r;for(let r=x;r<w;++r){const c=T*e+S*n+O*r,f=i*(d-1-o)+u*(h-1-(r*C-m))+l*t;for(let e=0;e<g;++e){b+=a[c+N*e]*s[f+e]}}}o[E*e+$*n+I*p+A*t]=b}}return r.toTensor()}conv3dDerInput(e,t,n){const r=ut(n.inShape,"float32"),o=r.values,[a,s,i,u]=r.strides,l=this.readSync(e.dataId),[c,d,h,f]=e.strides,p=this.readSync(t.dataId),[m,g,x,y]=t.strides,{batchSize:v,filterDepth:C,filterHeight:w,filterWidth:b,inChannels:_,inDepth:R,inHeight:E,inWidth:$,outChannels:I,outDepth:A,outHeight:T,outWidth:S,strideDepth:O,strideHeight:N,strideWidth:k}=n,D=C-1-n.padInfo.front,F=w-1-n.padInfo.top,M=b-1-n.padInfo.left;for(let e=0;e<v;++e)for(let t=0;t<_;++t)for(let n=0;n<R;++n){const r=n-D,v=Math.max(0,Math.ceil(r/O)),_=Math.min(A,(C+r)/O);for(let R=0;R<E;++R){const E=R-F,A=Math.max(0,Math.ceil(E/N)),D=Math.min(T,(w+E)/N);for(let T=0;T<$;++T){const $=T-M,F=Math.max(0,Math.ceil($/k)),B=Math.min(S,(b+$)/k);let P=0;for(let n=v;n<_;++n){const o=n*O-r;for(let r=A;r<D;++r){const a=r*N-E;for(let s=F;s<B;++s){const i=c*e+d*n+h*r+f*s,u=m*(C-1-o)+g*(w-1-a)+x*(b-1-(s*k-$))+y*t;for(let e=0;e<I;++e){P+=l[i+e]*p[u+e]}}}}o[a*e+s*n+i*R+u*T+t]=P}}}return r.toTensor()}conv2dDerFilter(e,t,n){En([e,t],"conv2dDerFilter");const r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,s=n.filterWidth,i="channelsLast"===n.dataFormat,u=ut(n.filterShape,"float32"),l=n.padInfo.left,c=n.padInfo.top,d=this.bufferSync(e),h=this.bufferSync(t);for(let e=0;e<a;++e){const t=Math.max(0,Math.ceil((c-e)/r)),a=Math.min(n.outHeight,(n.inHeight+c-e)/r);for(let f=0;f<s;++f){const s=Math.max(0,Math.ceil((l-f)/o)),p=Math.min(n.outWidth,(n.inWidth+l-f)/o);for(let m=0;m<n.inChannels;++m)for(let g=0;g<n.outChannels;++g){let x=0;for(let u=0;u<n.batchSize;++u)for(let n=t;n<a;++n){const t=e+n*r-c;for(let e=s;e<p;++e){const r=f+e*o-l;x+=i?d.get(u,t,r,m)*h.get(u,n,e,g):d.get(u,m,t,r)*h.get(u,g,n,e)}}u.set(x,e,f,m,g)}}}return u.toTensor()}conv3dDerFilter(e,t,n){const r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,s=n.filterDepth,i=n.filterHeight,u=n.filterWidth,l=ut(n.filterShape,"float32"),c=l.values,[d,h,f,p]=l.strides,m=this.readSync(t.dataId),[g,x,y,v]=t.strides,C=this.readSync(e.dataId),[w,b,_,R]=e.strides,E=n.padInfo.front,$=n.padInfo.left,I=n.padInfo.top;for(let e=0;e<s;++e){const t=Math.max(0,Math.ceil((E-e)/r)),s=Math.min(n.outDepth,(n.inDepth+E-e)/r),l=e*d;for(let d=0;d<i;++d){const i=Math.max(0,Math.ceil((I-d)/o)),A=Math.min(n.outHeight,(n.inHeight+I-d)/o),T=d*h+l;for(let l=0;l<u;++l){const u=Math.max(0,Math.ceil(($-l)/a)),h=Math.min(n.outWidth,(n.inWidth+$-l)/a),S=l*f+T;for(let f=0;f<n.inChannels;++f){const T=f*p+S;for(let p=0;p<n.outChannels;++p){let S=0;for(let c=0;c<n.batchSize;++c){const n=c*w,T=c*g;for(let c=t;c<s;++c){const t=(e+c*r-E)*b+n,s=c*x+T;for(let e=i;e<A;++e){const n=(d+e*o-I)*_+t,r=e*y+s;for(let e=u;e<h;++e){const t=e*v+r;S+=C[(l+e*a-$)*R+n+f]*m[t+p]}}}}c[T+p]=S}}}}}return l.toTensor()}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){let s=this.depthwiseConv2D(e,t,n);return r&&(s=this.add(s,r)),o&&(s=Nn(this,s,o,a)),s}depthwiseConv2D(e,t,n){En([e,t],"depthwiseConv2D");const r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,s=n.dilationWidth,i=n.padInfo.left,u=n.padInfo.top,l=n.outChannels/n.inChannels,c=ut(n.outShape,e.dtype),d=this.readSync(e.dataId),h=this.readSync(t.dataId),f=c.values;for(let p=0;p<n.batchSize;++p){const m=p*e.strides[0],g=p*c.strides[0];for(let p=0;p<n.outHeight;++p){const x=g+p*c.strides[1],y=p*n.strideHeight-i;for(let i=0;i<r;++i){const r=y+i*a;if(r<0||r>=n.inHeight)continue;const p=i*t.strides[0],g=m+r*e.strides[1];for(let e=0;e<n.outWidth;++e){const r=x+e*c.strides[2],a=e*n.strideWidth-u;for(let e=0;e<o;++e){const o=a+e*s;if(o<0||o>=n.inWidth)continue;const i=p+e*t.strides[1],u=g+o*n.inChannels;let c=r,m=i;for(let e=0;e<n.inChannels;++e){const t=d[u+e];for(let e=0;e<l;++e)f[c+e]+=t*h[m+e];c+=l,m+=l}}}}}}return c.toTensor()}depthwiseConv2DDerInput(e,t,n){En([e,t],"depthwiseConv2DDerInput");const r=ut(n.inShape,"float32"),o=r.values,[a,s,i]=r.strides,u=this.readSync(e.dataId),[l,c,d]=e.strides,h=this.readSync(t.dataId),[f,p,m]=t.strides,{batchSize:g,filterHeight:x,filterWidth:y,inChannels:v,inHeight:C,inWidth:w,outChannels:b,outHeight:_,outWidth:R,strideHeight:E,strideWidth:$}=n,I=x-1-n.padInfo.top,A=y-1-n.padInfo.left,T=b/v;for(let e=0;e<g;++e)for(let t=0;t<v;++t)for(let n=0;n<C;++n){const r=n-I,g=Math.max(0,Math.ceil(r/E)),v=Math.min(_,(x+r)/E);for(let C=0;C<w;++C){const w=C-A,b=Math.max(0,Math.ceil(w/$)),_=Math.min(R,(y+w)/$);let I=0;for(let n=g;n<v;++n){const o=n*E-r;for(let r=b;r<_;++r){const a=l*e+c*n+d*r,s=f*(x-1-o)+p*(y-1-(r*$-w))+m*t;for(let e=0;e<T;++e){I+=u[a+(t*T+e)]*h[s+e]}}}o[a*e+s*n+i*C+t]=I}}return r.toTensor()}depthwiseConv2DDerFilter(e,t,n){En([e,t],"depthwiseConv2DDerFilter");const r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,s=n.filterWidth,i=ut(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,d=this.bufferSync(e),h=this.bufferSync(t);for(let e=0;e<a;++e){const t=Math.max(0,Math.ceil((l-e)/r)),a=Math.min(n.outHeight,(n.inHeight+l-e)/r);for(let f=0;f<s;++f){const s=Math.max(0,Math.ceil((u-f)/o)),p=Math.min(n.outWidth,(n.inWidth+u-f)/o);for(let m=0;m<n.outChannels;++m){const g=Math.trunc(m/c),x=m%c;let y=0;for(let i=0;i<n.batchSize;++i)for(let n=t;n<a;++n){const t=e+n*r-l;for(let e=s;e<p;++e){const r=f+e*o-u;y+=d.get(i,t,r,g)*h.get(i,n,e,m)}}i.set(y,e,f,g,x)}}}return i.toTensor()}tile(e,t){return En(e,"tile"),Tn(this.bufferSync(e),t)}pad(e,t,n){En(e,"pad");const r=t.map((t,n)=>t[0]+e.shape[n]+t[1]),o=t.map(e=>e[0]),a=this.bufferSync(e),s=ut(r,e.dtype);0!==n&&s.values.fill(n);for(let t=0;t<e.size;t++){const e=a.indexToLoc(t),n=e.map((e,t)=>e+o[t]);s.set(a.get(...e),...n)}return s.toTensor()}gather(e,t,n){En([e,t],"gather");const r=e.shape.slice(),o=this.readSync(t.dataId);r[n]=o.length;const a=ut(r,e.dtype),s=this.bufferSync(e);for(let e=0;e<a.size;++e){const t=a.indexToLoc(e),r=t.slice();r[n]=o[t[n]];const i=s.locToIndex(r);a.values[e]=s.values[i]}return a.toTensor()}batchToSpaceND(e,t,n){En([e],"batchToSpaceND");const r=t.reduce((e,t)=>e*t),o=Ht(e.shape,t,r),a=Xt(o.length,t.length),s=jt(e.shape,t,r),i=qt(n,t.length),u=Kt(s,n,t.length);return Ae(e.reshape(o),a).reshape(s).slice(i,u)}spaceToBatchND(e,t,n){En([e],"spaceToBatchND");const r=t.reduce((e,t)=>e*t),o=[[0,0]];o.push(...n);for(let n=1+t.length;n<e.shape.length;++n)o.push([0,0]);const a=e.pad(o),s=Ht(a.shape,t,r,!1),i=Xt(s.length,t.length,!1),u=jt(a.shape,t,r,!1),l=Ae(a.reshape(s),i);return Ie(l,u)}maxPool(e,t){En(e,"maxPool");return $n(this.readSync(e.dataId),e.shape,e.dtype,e.strides,t,"max").toTensor()}maxPoolBackprop(e,t,n,r){En([t,n],"maxPoolBackprop");const o=this.readSync(t.dataId),a=ut(r.outShape,t.dtype,function(e,t,n,r,o=!1,a=!1){const s=ut(r.outShape,"int32"),i=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=ut(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*i-f;let x=g;for(;x<0;)x+=l;const y=Math.min(r.inHeight,d+g);for(let i=0;i<r.outWidth;++i){const d=i*u-p;let f=d;for(;f<0;)f+=c;const v=Math.min(r.inWidth,h+d);let C=Number.NEGATIVE_INFINITY,w=-1;for(let n=x;n<y;n+=l){const s=n-g;for(let i=f;i<v;i+=c){const u=i-d,l=m.get(e,n,i,t);l>C&&(C=l,w=o?a?((e*r.inHeight+n)*r.inWidth+i)*r.inChannels+t:(n*r.inWidth+i)*r.inChannels+t:s*h+u)}}s.set(w,e,n,i,t)}}return s}(o,t.shape,t.dtype,r).values),s=r.strideHeight,i=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=d-1-r.padInfo.left,f=c-1-r.padInfo.top,p=ut(t.shape,"float32"),m=this.bufferSync(e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.inHeight;++n)for(let o=0;o<r.inWidth;++o){const g=n-f,x=o-h;let y=0;for(let n=0;n<c;n+=u){const o=(g+n)/s;if(!(o<0||o>=r.outHeight||Math.floor(o)!==o))for(let s=0;s<d;s+=l){const u=(x+s)/i;if(u<0||u>=r.outWidth||Math.floor(u)!==u)continue;const l=c*d-1-a.get(e,o,u,t)===n*d+s?1:0;if(0===l)continue;y+=m.get(e,o,u,t)*l}}p.set(y,e,n,o,t)}return p.toTensor()}avgPoolBackprop(e,t,n){En([e,t],"avgPoolBackprop");const r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,s=n.filterWidth,i=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,d=c-1-n.padInfo.left,h=l-1-n.padInfo.top,f=ut(t.shape,"float32"),p=1/(a*s),m=this.bufferSync(e);for(let e=0;e<n.batchSize;++e)for(let t=0;t<n.inChannels;++t)for(let a=0;a<n.inHeight;++a)for(let s=0;s<n.inWidth;++s){const g=a-h,x=s-d;let y=0;for(let a=0;a<l;a+=i){const s=(g+a)/r;if(!(s<0||s>=n.outHeight||Math.floor(s)!==s))for(let r=0;r<c;r+=u){const a=(x+r)/o;if(a<0||a>=n.outWidth||Math.floor(a)!==a)continue;y+=m.get(e,s,a,t)}}f.set(y*p,e,a,s,t)}return f.toTensor()}pool3d(e,t,n){En(e,"pool3d");const r=t.strideDepth,o=t.strideHeight,a=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left,m="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=this.readSync(e.dataId),x=ut(t.outShape,e.dtype),y=x.values,v=t.outShape[1]*t.outShape[2]*t.outShape[3]*t.outShape[4],C=t.outShape[2]*t.outShape[3]*t.outShape[4],w=t.outShape[3]*t.outShape[4],b=t.outShape[4];for(let x=0;x<t.batchSize;++x){const _=x*v,R=x*e.strides[0];for(let x=0;x<t.inChannels;++x)for(let v=0;v<t.outDepth;++v){const E=v*r-h;let $=E;for(;$<0;)$+=s;const I=Math.min(t.inDepth,l+E),A=_+v*C;for(let r=0;r<t.outHeight;++r){const l=r*o-f;let h=l;for(;h<0;)h+=i;const v=Math.min(t.inHeight,c+l),C=A+r*w;for(let r=0;r<t.outWidth;++r){const o=r*a-p;let l=o;for(;l<0;)l+=u;const c=Math.min(t.inWidth,d+o),f=C+r*b;let w=m,_=0,E=0;for(let t=$;t<I;t+=s){const r=R+t*e.strides[1];for(let t=h;t<v;t+=i){const o=r+t*e.strides[2];for(let t=l;t<c;t+=u){const r=g[o+t*e.strides[3]+x];if("max"===n&&r>w?w=r:"avg"===n&&(_+=r,E++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}y[f+x]="avg"===n?_/E:w}}}}return x.toTensor()}avgPool3d(e,t){return En(e,"avgPool3d"),this.pool3d(e,t,"avg").toFloat()}avgPool3dBackprop(e,t,n){En([e,t],"avgPool3dBackprop");const r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,s=n.filterDepth,i=n.filterHeight,u=n.filterWidth,l=n.dilationDepth,c=n.dilationHeight,d=n.dilationWidth,h=n.effectiveFilterDepth,f=n.effectiveFilterHeight,p=n.effectiveFilterWidth,m=h-1-n.padInfo.front,g=p-1-n.padInfo.left,x=f-1-n.padInfo.top,y=ut(t.shape,"float32"),v=1/(s*i*u),C=this.bufferSync(e);for(let e=0;e<n.batchSize;++e)for(let t=0;t<n.inChannels;++t)for(let s=0;s<n.inDepth;++s)for(let i=0;i<n.inHeight;++i)for(let u=0;u<n.inWidth;++u){const w=s-m,b=i-x,_=u-g;let R=0;for(let s=0;s<h;s+=l){const i=(w+s)/r;if(!(i<0||i>=n.outDepth||Math.floor(i)!==i))for(let r=0;r<f;r+=c){const s=(b+r)/o;if(!(s<0||s>=n.outHeight||Math.floor(s)!==s))for(let r=0;r<p;r+=d){const o=(_+r)/a;if(o<0||o>=n.outWidth||Math.floor(o)!==o)continue;R+=C.get(e,i,s,o,t)}}}y.set(R*v,e,s,i,u,t)}return y.toTensor()}maxPool3d(e,t){return En(e,"maxPool3d"),this.pool3d(e,t,"max").toFloat()}maxPool3dPositions(e,t){const n=ut(t.outShape,"int32"),r=t.strideDepth,o=t.strideHeight,a=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left,m=this.bufferSync(e);for(let e=0;e<t.batchSize;++e)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){const y=x*r-h;let v=y;for(;v<0;)v+=s;const C=Math.min(t.inDepth,l+y);for(let r=0;r<t.outHeight;++r){const l=r*o-f;let h=l;for(;h<0;)h+=i;const w=Math.min(t.inHeight,c+l);for(let o=0;o<t.outWidth;++o){const f=o*a-p;let b=f;for(;b<0;)b+=u;const _=Math.min(t.inWidth,d+f);let R=Number.NEGATIVE_INFINITY,E=-1;for(let t=v;t<C;t+=s){const n=t-y;for(let r=h;r<w;r+=i){const o=r-l;for(let a=b;a<_;a+=u){const s=a-f,i=m.get(e,t,r,a,g);i>=R&&(R=i,E=n*c*d+o*c+s)}}}n.set(E,e,x,r,o,g)}}}return n.toTensor()}maxPool3dBackprop(e,t,n,r){En([t,n],"maxPool3dBackprop");const o=this.maxPool3dPositions(t,r),a=r.strideDepth,s=r.strideHeight,i=r.strideWidth,u=r.dilationDepth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterDepth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,p=d-1-r.padInfo.front,m=f-1-r.padInfo.left,g=h-1-r.padInfo.top,x=ut(t.shape,"float32"),y=this.bufferSync(o),v=this.bufferSync(e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.inDepth;++n)for(let o=0;o<r.inHeight;++o)for(let C=0;C<r.inWidth;++C){const w=n-p,b=o-g,_=C-m;let R=0;for(let n=0;n<d;n+=u){const o=(w+n)/a;if(!(o<0||o>=r.outDepth||Math.floor(o)!==o))for(let a=0;a<h;a+=l){const u=(b+a)/s;if(!(u<0||u>=r.outHeight||Math.floor(u)!==u))for(let s=0;s<f;s+=c){const l=(_+s)/i;if(l<0||l>=r.outWidth||Math.floor(l)!==l)continue;const c=d*h*f-1-y.get(e,o,u,l,t)===n*h*f+a*f+s?1:0;if(0===c)continue;R+=v.get(e,o,u,l,t)*c}}}x.set(R,e,n,o,C,t)}return x.toTensor()}cast(e,t){return an(e,t,this)}reshape(e,t){return sn(e,t)}avgPool(e,t){En(e,"avgPool"),En(e,"maxPool");return $n(this.readSync(e.dataId),e.shape,e.dtype,e.strides,t,"avg").toTensor().toFloat()}resizeBilinear(e,t,n,r){En(e,"resizeBilinear");const[o,a,s,i]=e.shape,u=this.readSync(e.dataId),l=new Float32Array(b([o,t,n,i])),c=[r&&t>1?a-1:a,r&&n>1?s-1:s],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h=0;const f=c[0]/d[0],p=c[1]/d[1];for(let r=0;r<o;r++)for(let o=0;o<t;o++){const t=f*o,c=Math.floor(t),d=t-c,m=Math.min(a-1,Math.ceil(t)),g=r*e.strides[0]+c*e.strides[1],x=r*e.strides[0]+m*e.strides[1];for(let t=0;t<n;t++){const n=p*t,r=Math.floor(n),o=n-r,a=Math.min(s-1,Math.ceil(n)),c=g+r*e.strides[2],f=x+r*e.strides[2],m=g+a*e.strides[2],y=x+a*e.strides[2];for(let e=0;e<i;e++){const t=u[c+e],n=u[f+e],r=t+(u[m+e]-t)*o,a=r+(n+(u[y+e]-n)*o-r)*d;l[h++]=a}}}return Ee(l,[o,t,n,i])}resizeBilinearBackprop(e,t,n){En([e,t],"resizeBilinearBackprop");const[r,o,a,s]=t.shape,[,i,u]=e.shape,l=new Float32Array(r*o*a*s),c=[n&&i>1?o-1:o,n&&u>1?a-1:a],d=[n&&i>1?i-1:i,n&&u>1?u-1:u],h=c[0]/d[0],f=c[1]/d[1],p=this.readSync(e.dataId);let m=0;for(let e=0;e<r;e++){const n=e*t.strides[0];for(let e=0;e<i;e++){const r=e*h,i=Math.floor(r),c=Math.min(Math.ceil(r),o-1),d=n+i*t.strides[1],g=n+c*t.strides[1],x=r-i,y=1-x;for(let e=0;e<u;e++){const n=e*f,r=Math.floor(n),o=Math.min(Math.ceil(n),a-1),i=n-r,u=1-i,c=d+r*t.strides[2],h=d+o*t.strides[2],v=g+r*t.strides[2],C=g+o*t.strides[2],w=y*u,b=y*i,_=x*u,R=x*i;for(let e=0;e<s;e++){const t=p[m++];l[c+e]+=t*w,l[h+e]+=t*b,l[v+e]+=t*_,l[C+e]+=t*R}}}}return Pt(l,[r,a,o,s],t.dtype)}resizeNearestNeighbor(e,t,n,r){En(e,"resizeNearestNeighbor");const[o,a,s,i]=e.shape,u=this.readSync(e.dataId),l=new Float32Array(o*t*n*i),c=[r&&t>1?a-1:a,r&&n>1?s-1:s],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=c[0]/d[0],f=c[1]/d[1];let p=0;for(let c=0;c<o;c++){const o=c*e.strides[0];for(let c=0;c<t;c++){const t=h*c,d=o+Math.min(a-1,r?Math.round(t):Math.floor(t))*e.strides[1];for(let t=0;t<n;t++){const n=f*t,o=d+Math.min(s-1,r?Math.round(n):Math.floor(n))*e.strides[2];for(let e=0;e<i;e++){const t=u[o+e];l[p++]=t}}}}return Ee(l,[o,t,n,i],e.dtype)}resizeNearestNeighborBackprop(e,t,n){En([e,t],"resizeNearestNeighborBackprop");const[r,o,a,s]=t.shape,[,i,u]=e.shape,l=new Float32Array(r*o*a*s),c=this.readSync(e.dataId),d=[n&&i>1?o-1:o,n&&u>1?a-1:a],h=[n&&i>1?i-1:i,n&&u>1?u-1:u],f=d[0]/h[0],p=d[1]/h[1],m=1/f,g=1/p,x=2*Math.ceil(m)+2,y=2*Math.ceil(g)+2;for(let d=0;d<r;d++){const r=d*t.strides[0];for(let d=0;d<o;d++){const h=r+d*t.strides[1],v=Math.floor(d*m),C=Math.floor(v-x/2);for(let m=0;m<a;m++){const v=h+m*t.strides[2],w=Math.floor(m*g),b=Math.floor(w-y/2);for(let t=0;t<s;t++){let s=0;for(let l=0;l<x;l++){const h=l+C;if(h<0||h>=i)continue;const g=r+h*e.strides[1],x=h*f;if(d===Math.min(o-1,n?Math.round(x):Math.floor(x)))for(let r=0;r<y;r++){const o=r+b;if(o<0||o>=u)continue;const i=g+o*e.strides[2],l=o*p;m===Math.min(a-1,n?Math.round(l):Math.floor(l))&&(s+=c[i+t])}}l[v+t]=s}}}}return Pt(l,t.shape,t.dtype)}batchNorm(e,t,n,r,o,a){En([e,t,n,o,r],"batchNorm");const s=this.readSync(e.dataId),i=this.readSync(t.dataId),u=this.readSync(n.dataId),l=o?this.readSync(o.dataId):new Float32Array([1]),c=r?this.readSync(r.dataId):new Float32Array([0]),d=new Float32Array(s.length),h=c.length,f=l.length,p=u.length,m=i.length;let g=0,x=0,y=0,v=0;for(let e=0;e<s.length;++e)d[e]=c[g++]+(s[e]-i[x++])*l[y++]/Math.sqrt(u[v++]+a),g>=h&&(g=0),x>=m&&(x=0),y>=f&&(y=0),v>=p&&(v=0);return Pt(d,e.shape)}localResponseNormalization4D(e,t,n,r,o){En(e,"localResponseNormalization4D");const a=e.shape[3],s=a-1,i=this.readSync(e.dataId),u=e.size,l=new Float32Array(u);function c(e){const n=e%a;let r=e-n+Math.max(0,n-t);const o=e-n+Math.min(n+t,s);let u=0;for(;r<=o;r++){const e=i[r];u+=e*e}return u}for(let e=0;e<u;e++){const t=c(e),a=i[e]*Math.pow(n+r*t,-o);l[e]=a}return Pt(l,e.shape)}LRNGrad(e,t,n,r,o,a,s){En(e,"LRNGrad");const i=e.shape[3],u=this.readSync(e.dataId),l=this.readSync(t.dataId),c=this.readSync(n.dataId),d=new Float32Array(e.size),h=e.size;for(let e=0;e<h;e++){const t=e%i,n=e-t+Math.max(0,t-r),h=e-t+Math.min(i,t+r+1);let f=0;for(let e=n;e<h;e++)f+=Math.pow(l[e],2);f=a*f+o;for(let t=n;t<h;t++){let n=-2*a*s*l[t]*c[e]/f;e===t&&(n+=Math.pow(f,-s)),n*=u[e],d[t]+=n}}return Pt(d,e.shape)}multinomial(e,t,n,r){En(e,"multinomial");const o=t?e:Ft(e),a=o.shape[0],s=o.shape[1],i=wt([a,n],"int32"),u=this.readSync(i.dataId),l=this.readSync(o.dataId);for(let e=0;e<a;++e){const t=e*s,o=new Float32Array(s-1);o[0]=l[t];for(let e=1;e<o.length;++e)o[e]=o[e-1]+l[t+e];const a=Ot.alea(r.toString()),i=e*n;for(let e=0;e<n;++e){const t=a();u[i+e]=o.length;for(let n=0;n<o.length;n++)if(t<o[n]){u[i+e]=n;break}}}return i}oneHot(e,t,n,r){En(e,"oneHot");const o=new Float32Array(e.size*t);o.fill(r);const a=this.readSync(e.dataId);for(let r=0;r<e.size;++r)a[r]>=0&&a[r]<t&&(o[r*t+a[r]]=n);return function(e,t,n){if(C(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=ye(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Re(e,t,r,n)}(o,[e.size,t],"int32")}nonMaxSuppression(e,t,n,r,o){En(e,"nonMaxSuppression");const a=this.readSync(e.dataId),s=this.readSync(t.dataId);return In(a,s,n,r,o)}fft(e){return this.fftBatch(e,!1)}ifft(e){return this.fftBatch(e,!0)}fftBatch(e,t){const n=e.shape[0],r=e.shape[1],o=ut(e.shape,"float32"),a=ut(e.shape,"float32"),s=yt(e).as2D(n,r),i=xt(e).as2D(n,r);for(let e=0;e<n;e++){const n=s.slice([e,0],[1,r]),u=i.slice([e,0],[1,r]),l=_e(n,u),c=this.readSync(this.fftImpl(l,t).dataId);for(let t=0;t<r;t++){const n=tn(c,t);o.values[e*r+t]=n.real,a.values[e*r+t]=n.imag}}return _e(o.toTensor(),a.toTensor()).as2D(n,r)}fftImpl(e,t){const n=e.as1D(),r=n.size;if(this.isExponentOf2(r)){let o=this.fftRadix2(n,r,t).as2D(e.shape[0],e.shape[1]);return t&&(o=_e(yt(o).div(vt(r)),xt(o).div(vt(r)))),o}{const n=this.readSync(e.dataId),o=Zt(this.fourierTransformByMatmul(n,r,t));return _e(o.real,o.imag).as2D(e.shape[0],e.shape[1])}}isExponentOf2(e){return 0==(e&e-1)}fftRadix2(e,t,n){if(1===t)return e;const r=this.readSync(e.dataId),o=t/2,a=Jt(r);let s=_e(a.real,a.imag).as1D();const i=en(r);let u=_e(i.real,i.imag).as1D();s=this.fftRadix2(s,o,n),u=this.fftRadix2(u,o,n);const l=rn(t,n),c=_e(l.real,l.imag).mul(u),d=s.add(c),h=s.sub(c),f=yt(d).concat(yt(h)),p=xt(d).concat(xt(h));return _e(f,p).as1D()}fourierTransformByMatmul(e,t,n){const r=new Float32Array(2*t);for(let o=0;o<t;o++){let a=0,s=0;for(let r=0;r<t;r++){const i=on(o*r,t,n),u=tn(e,r);a+=u.real*i.real-u.imag*i.imag,s+=u.real*i.imag+u.imag*i.real}n&&(a/=t,s/=t),nn(r,a,s,o)}return r}depthToSpace(e,t,n){y("NHWC"===n,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n),y(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+t);const r=e.shape[0],o=e.shape[1],a=e.shape[2],s=e.shape[3],i=o*t,u=a*t,l=s/(t*t),c=this.readSync(e.dataId),d=new Float32Array(r*i*u*l);let h=0;for(let e=0;e<r;++e)for(let n=0;n<i;++n){const r=Math.floor(n/t),i=n%t;for(let n=0;n<u;++n){const u=Math.floor(n/t),f=(i*t+n%t)*l;for(let t=0;t<l;++t){const n=t+f+s*(u+a*(r+o*e));d[h++]=c[n]}}}return Pt(d,[r,i,u,l])}broadcastedBinaryOp(e,t,n,r){const o=dt(e.shape,t.shape),a=ut(o,n),s=this.readSync(e.dataId),i=this.readSync(t.dataId),u=lt(e.shape,o),l=lt(t.shape,o),c=a.values;if(u.length+l.length===0)for(let e=0;e<c.length;++e)c[e]=r(s[e%s.length],i[e%i.length]);else{const n=this.bufferSync(e),o=this.bufferSync(t);for(let d=0;d<c.length;++d){const h=a.indexToLoc(d),f=h.slice(-e.rank);u.forEach(e=>f[e]=0);const p=n.locToIndex(f),m=h.slice(-t.rank);l.forEach(e=>m[e]=0);const g=o.locToIndex(m);c[d]=r(s[p],i[g])}}return a.toTensor()}broadcastedBinaryComplexOp(e,t,n){const r=dt(e.shape,t.shape),o=ut(r,"float32"),a=ut(r,"float32"),s=this.readSync(e.dataId),i=this.readSync(t.dataId),u=lt(e.shape,r),l=lt(t.shape,r),c=o.values,d=a.values;if(u.length+l.length===0)for(let e=0;e<c.length;e++){const t=e%s.length,r=e%i.length,o=n(s[2*t],s[2*t+1],i[2*r],i[2*r+1]);c[e]=o.real,d[e]=o.imag}else{const r=this.bufferSync(this.data.get(e.dataId).complexTensors.real),a=this.bufferSync(this.data.get(t.dataId).complexTensors.real);for(let h=0;h<c.length;h++){const f=o.indexToLoc(h),p=f.slice(-e.rank);u.forEach(e=>p[e]=0);const m=r.locToIndex(p),g=f.slice(-t.rank);l.forEach(e=>g[e]=0);const x=a.locToIndex(g),y=n(s[2*m],s[2*m+1],i[2*x],i[2*x+1]);c[h]=y.real,d[h]=y.imag}}return this.complex(o.toTensor(),a.toTensor())}split(e,t,n){return An(e,t,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(e,t,n,r,o,a){const[s,i,u,l]=e.shape,c=t.shape[0],[d,h]=r,f=ut([c,d,h,l],"float32"),p=this.readSync(t.dataId),m=this.readSync(n.dataId),g=this.readSync(e.dataId),x=e.strides,y=f.strides;for(let e=0;e<c;e++){const t=4*e,n=p[t],r=p[t+1],c=p[t+2],v=p[t+3],C=m[e];if(C>=s)continue;const w=d>1?(c-n)*(i-1)/(d-1):0,b=h>1?(v-r)*(u-1)/(h-1):0;for(let t=0;t<d;t++){const s=d>1?n*(i-1)+t*w:.5*(n+c)*(i-1);if(s<0||s>i-1)for(let n=0;n<h;n++)for(let r=0;r<l;r++){const o=r+n*y[2]+t*y[1]+e*y[0];f.values[o]=a}else if("bilinear"===o){const n=Math.floor(s),o=Math.ceil(s),i=s-n;for(let s=0;s<h;s++){const c=h>1?r*(u-1)+s*b:.5*(r+v)*(u-1);if(c<0||c>u-1){for(let n=0;n<l;n++){const r=n+s*y[2]+t*y[1]+e*y[0];f.values[r]=a}continue}const d=Math.floor(c),p=Math.ceil(c),m=c-d;for(let r=0;r<l;r++){let a=r+d*x[2]+n*x[1]+C*x[0];const u=g[a];a=r+p*x[2]+n*x[1]+C*x[0];const l=g[a];a=r+d*x[2]+o*x[1]+C*x[0];const c=g[a];a=r+p*x[2]+o*x[1]+C*x[0];const h=u+(l-u)*m,v=c+(g[a]-c)*m;a=r+s*y[2]+t*y[1]+e*y[0],f.values[a]=h+(v-h)*i}}}else for(let n=0;n<h;++n){const o=h>1?r*(u-1)+n*b:.5*(r+v)*(u-1);if(o<0||o>u-1){for(let r=0;r<l;r++){const o=r+n*y[2]+t*y[1]+e*y[0];f.values[o]=a}continue}const i=Math.round(o),c=Math.round(s);for(let r=0;r<l;r++){const o=r+i*x[2]+c*x[1]+C*x[0],a=r+n*y[2]+t*y[1]+e*y[0];f.values[a]=g[o]}}}}return f.toTensor()}sparseToDense(e,t,n,r){const{sliceRank:o,numUpdates:a,sliceSize:s,strides:i,outputSize:u}=We(0,e,n);return this.scatter(e,t,n,u,s,a,o,i,r,!1)}gatherND(e,t){const n=t.shape,r=n[n.length-1],[o,a,s,i]=Pe(e,t);if(0===a)return Ee([],o,e.dtype);const u=new ee([a,s],e.dtype),l=this.readSync(t.dataId),c=this.readSync(e.dataId);for(let t=0;t<a;t++){const n=[];let o=0;for(let e=0;e<r;e++){const a=l[t*r+e];o+=a*i[e],n.push(a)}if(o<0||o>=e.size/s)throw new Error(`Invalid indices: ${n} does not index into ${e.shape}`);for(let e=0;e<s;e++)u.values[t*s+e]=c[o*s+e]}return u.toTensor().reshape(o)}scatterND(e,t,n){const{sliceRank:r,numUpdates:o,sliceSize:a,strides:s,outputSize:i}=We(0,e,n),u=vt(0);return this.scatter(e,t,n,i,a,o,r,s,u,!0)}fill(e,t,n){const r=N(n=n||M(t),b(e));return r.fill(t),ze().makeTensor(r,e,n,this)}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(e.shape,1,e.dtype)}zerosLike(e){const t=N(e.dtype,b(e.shape));return this.makeOutput(t,e.shape,e.dtype)}linspace(e,t,n){return un(e,t,n)}scatter(e,t,n,r,o,a,s,i,u,l){const c=[r/o,o],d=this.readSync(e.dataId),h=this.readSync(t.dataId);if(0===r)return Ee([],n,t.dtype);const f=new ee(c,t.dtype);f.values.fill(this.readSync(u.dataId)[0]);for(let e=0;e<a;e++){const a=[];let u=0;for(let t=0;t<s;t++){const n=d[e*s+t];a.push(n),u+=n*i[t]}if(u<0||u>=r/o)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<o;n++)l?f.values[u*o+n]+=h[e*o+n]:f.values[u*o+n]=0===t.rank?h[0]:h[e*o+n]}return f.toTensor().reshape(n)}}function Dn(e,t,n,r){const o=O(r,b(n));for(let n=0;n<o.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];t>a&&(a=t)}o[n]=a}return o}function Fn(e,t,n,r,o){const a=t.length,s=b(t),i=L(t),u=L(o),l=O(n,b(o));for(let t=0;t<s;++t){const n=j(t,a,i),o=new Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[r[e]];l[X(o,a,u)]=e[t]}return l}var Mn=Object.freeze({__proto__:null,maxImpl:Dn,transposeImpl:Fn});He("cpu",()=>new kn,1);const Bn={kernelName:"Max",backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{reductionIndices:o,keepDims:a}=t,s=n;let i=r.shape;const u=i.length,l=T(o,i);let c=l;const d=De(c,u);let h=s.data.get(r.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=i[d[t]];h=Fn(h,i,r.dtype,d,e),c=Me(c.length,u),i=e}En(r,"max"),ke("max",c,u);const[f,p]=Oe(i,c),m=Dn(h,b(p),f,r.dtype),g=s.write(m,f,r.dtype);let x=f;if(a){x=Ne(f,l)}return{dataId:g,shape:x,dtype:r.dtype}}},Pn={},Ln={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Wn(e){e in Pn||(Pn[e]=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Pn[e]},!1),1===e)return t.getContext("webgl",Ln)||t.getContext("experimental-webgl",Ln);return t.getContext("webgl2",Ln)}(e));const t=Pn[e];return t.isContextLost()?(delete Pn[e],Wn(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Pn[e])}var Un,Vn,Gn;function zn(e,t){return[t,e]}function Hn(e){const t=b(e);return $(Math.ceil(t/4))}function Xn(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function jn(e,t){const n=e;let r,o,a,i,u,l,c,d,h,f;return 2===s().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,a=n.RGBA16F,i=n.RGBA32F,u=n.RED,c=4,d=1,h=n.HALF_FLOAT,f=n.FLOAT):(r=e.RGBA,o=e.RGBA,a=e.RGBA,i=n.RGBA,u=e.RGBA,c=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,f=e.FLOAT),l=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:f}}function qn(e,t){const n=t();return s().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Un||(Un={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(Vn||(Vn={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Gn||(Gn={}));function Kn(e){return!!(s().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function Yn(e,t){return ar(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Qn(e,t){const n=ar(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(qn(e,()=>e.shaderSource(n,t)),qn(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=Zn.exec(t);if(null==n)return console.log("Couldn't parse line number in error: "+t),void console.log(e);const r=+n[1],o=e.split("\n"),a=o.length.toString().length+2,s=o.map((e,t)=>I((t+1).toString(),a)+e);let i=0;for(let e=0;e<s.length;e++)i=Math.max(s[e].length,i);const u=s.slice(0,r-1),l=s.slice(r-1,r),c=s.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+I(l[0],i),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Zn=/ERROR: [0-9]+:([0-9]+):/g;function Jn(e,t){if(qn(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function er(e,t,n,r,o,a,s){const i=e.getAttribLocation(t,n);return-1!==i&&(qn(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),qn(e,()=>e.vertexAttribPointer(i,o,e.FLOAT,!1,a,s)),qn(e,()=>e.enableVertexAttribArray(i)),!0)}function tr(e,t,n){!function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}(e,n),qn(e,()=>e.activeTexture(e.TEXTURE0+n)),qn(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function nr(e,t,n){qn(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),qn(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function rr(e,t){qn(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),qn(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function or(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}(e,t))}function ar(e,t,n){const r=qn(e,()=>t());if(null==r)throw new Error(n);return r}function sr(e,t=2){return b(e.slice(0,e.length-t))}function ir(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function ur(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[sr(e),...ir(e)]),t}function lr(e){return e%2==0}function cr(e,t){if(_(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(lr(n)&&lr(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&lr(e[0])&&lr(t[0])}let dr,hr;function fr(e,t){return null!=e.getExtension(t)}function pr(e){try{if(null!=Wn(e))return!0}catch(e){return!1}return!1}function mr(e){if(0===e)return!1;const t=Wn(e);if(1!==e){if(fr(t,"EXT_color_buffer_float"))return gr(t);const e="EXT_color_buffer_half_float";if(fr(t,e)){const n=t.getExtension(e);return function(e,t){const n=jn(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),a}(t,n)}return!1}if(!fr(t,"OES_texture_float"))return!1;if(!fr(t,"WEBGL_color_buffer_float"))return!1;return gr(t)}function gr(e){const t=jn(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}const xr=s();xr.registerFlag("HAS_WEBGL",()=>xr.getNumber("WEBGL_VERSION")>0),xr.registerFlag("WEBGL_VERSION",()=>pr(2)?2:pr(1)?1:0),xr.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),xr.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===xr.get("WEBGL_VERSION")),xr.registerFlag("WEBGL_CPU_FORWARD",()=>!0),xr.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),xr.registerFlag("WEBGL_PACK",()=>xr.getBool("HAS_WEBGL")),xr.registerFlag("WEBGL_PACK_NORMALIZATION",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_CLIP",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),xr.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_PACK_REDUCE",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_LAZILY_UNPACK",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_CONV_IM2COL",()=>xr.getBool("WEBGL_PACK")),xr.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==dr){const t=Wn(e);dr=t.getParameter(t.MAX_TEXTURE_SIZE)}return dr}(xr.getNumber("WEBGL_VERSION"))),xr.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==hr){const t=Wn(e);hr=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,hr)}(xr.getNumber("WEBGL_VERSION"))),xr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=xr.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=Wn(e);return t=fr(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:fr(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),xr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>xr.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!cn()),xr.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=Wn(e);if(1===e){if(!fr(t,"OES_texture_float"))return!1}else if(!fr(t,"EXT_color_buffer_float"))return!1;return gr(t)}(xr.getNumber("WEBGL_VERSION"))),xr.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!xr.getBool("WEBGL_FORCE_F16_TEXTURES")&&xr.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),xr.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>mr(xr.getNumber("WEBGL_VERSION"))),xr.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=xr.getNumber("WEBGL_VERSION"))&&null!=Wn(e).fenceSync;var e}),xr.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>xr.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),xr.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});class yr{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class vr{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class Cr{constructor(e,t,n){this.variableNames=["A"];const r=e.windowSize,o=e.batchSize,a=e.inSize,s=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,s];const i="max"===t?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${u};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function wr(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function br(e,t){return 1===t?[e]:wr(e,t)}function _r(){let e,t,n,r,o,a,i,u,l,c;return 2===s().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",o="texture",a="outputColor",i="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",o="texture2D",a="gl_FragColor",i="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:o,output:a,defineOutput:i,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function Rr(e,t,n="index"){const r=L(t);return r.map((t,o)=>`${`int ${e[o]} = ${n} / ${t}`}; ${o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${t}`:`index -= ${e[o]} * ${t}`};`).join("")}function Er(e){const t=L(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}const $r="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Ir}=ln;function Ar(e,t,n,r){const o=[];e.forEach(e=>{const t=b(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?o.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(o.push(`uniform sampler2D ${e.name};`),o.push(`uniform int offset${e.name};`))});const a=o.join("\n"),s=e.map(e=>function(e,t,n=!1){let r="";r+=n?Sr(e):Tr(e);const o=e.shapeInfo.logicalShape,a=t.logicalShape;o.length<=a.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,i=Ir(e.shapeInfo.logicalShape,t.logicalShape),u=Pr(s),l=s-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":s<2&&i.length>=1?"coords = 0;":i.map(e=>`coords.${d[e+l]} = 0;`).join("\n");let h="";h=s<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords."+d[t+l]).join(", ");let f="return outputValue;";const p=1===b(e.shapeInfo.logicalShape),m=1===b(t.logicalShape);if(1!==a||p||m){if(p&&!m)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=a-2,t=a-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?f="return vec4(outputValue.x);":i.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=t.texShape,s=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&null==e.shapeInfo.flatOffset&&_(s,a))return`\n      float ${o}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=Pr(u),c=Ir(e.shapeInfo.logicalShape,t.logicalShape),d=u-i;let h;const f=["x","y","z","w","u","v"];h=0===i?"":u<2&&c.length>=1?"coords = 0;":c.map(e=>`coords.${f[e+d]} = 0;`).join("\n");let p="";p=u<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords."+f[t+d]).join(", ");return`\n    float ${o}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(e,t));return r}(e,t,r)).join("\n"),i=t.texShape,u=_r(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Or}\n    ${Nr}\n    ${kr}\n  `}(u);t.isPacked?(c=function(e,t){switch(e.length){case 0:return Fr();case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===n[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(_(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let a=o,s="",i="b, r, c";for(let t=2;t<e.length-1;t++)a*=e[e.length-t-1],s=`\n      int b${t} = index / ${a};\n      index -= b${t} * ${a};\n    `+s,i=`b${t}, `+i;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${i});\n    }\n  `}(e,t)}}(t.logicalShape,i),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return Fr();case 1:return function(e,t){if(1===t[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t);case 2:return function(e,t){if(_(e,t))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=Rr(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=Rr(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=Rr(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=Rr(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(e.length+"-D output sampling is not yet supported")}}(t.logicalShape,i),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(h+=Dr);return[h,l,d,a,c,s,n].join("\n")}function Tr(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[a,s]=e.shapeInfo.texShape,i=Mr(t);return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${s}, ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Br(e)}\n      }\n    `;const r=e.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const s=Mr(t);if(1===a)return`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===o)return`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${a}, index + ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape;if(null!=o&&_(t,o)){const e=o[0],t=o[1];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:a,keptDims:s}=S(t),i=a;if(i.length<t.length){const t=Lr(e,i),n=["row","col"];return`\n      ${Tr(t)}\n      float ${r}(int row, int col) {\n        return ${r}(${Wr(n,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${Br(e)}\n      }\n    `;const u=o[0],l=o[1],c=Mr(n);if(1===l)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;if(1===u)return`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[1]*t[2],a=t[2],{newShape:s,keptDims:i}=S(t),u=s;if(u.length<t.length){const t=Lr(e,u),n=["row","col","depth"];return`\n        ${Tr(t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Wr(n,i)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${a}, 1)));\n        ${Br(e)}\n      }\n    `;const l=e.shapeInfo.texShape,c=l[0],d=l[1],h=e.shapeInfo.flatOffset;if(d===o&&null==h)return`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(d===a&&null==h)return`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const f=Mr(n);return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[3],a=t[2]*o,s=t[1]*a,{newShape:i,keptDims:u}=S(t);if(i.length<t.length){const t=Lr(e,i),n=["row","col","depth","depth2"];return`\n      ${Tr(t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Wr(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${s}, ${a}, ${o}, 1)));\n        ${Br(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],h=c[1];if(h===s&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===o&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=Mr(n);return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${a} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${f});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[4],a=t[3]*o,s=t[2]*a,i=t[1]*s,{newShape:u,keptDims:l}=S(t);if(u.length<t.length){const t=Lr(e,u),n=["row","col","depth","depth2","depth3"];return`\n      ${Tr(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Wr(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${s}, ${a}, ${o})) +\n          depth3;\n        ${Br(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const p=Mr(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${s} + depth * ${a} +\n          depth2 * ${o} + depth3 + ${p};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:o,keptDims:a}=S(t);if(o.length<t.length){const t=Lr(e,o),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Tr(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Wr(n,a)});\n      }\n    `}const s=t[5],i=t[4]*s,u=t[3]*i,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${Br(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${i}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=Mr(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${i} + depth3 * ${s} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function Sr(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=_r();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=_r();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,a=o[0],s=o[1],i=_r();if(null!=o&&_(t,o))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${a}.0);\n\n        return ${i.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(t[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){const n=t.slice(1),o=[1,2],a=Lr(e,n),s=["b","row","col"];return`\n        ${Sr(a)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Wr(s,o)});\n        }\n      `}const s=a[0],i=a[1],u=Math.ceil(t[2]/2),l=u*Math.ceil(t[1]/2),c=_r();return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${s}, ${i}, ${l}, ${u}, b, row, col);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],i=s[0],u=s[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",h=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let e=2;e<n-1;e++)d=`int b${e}, `+d,c*=t[n-e-1],h=`b${e} * ${c} + `+h;const f=_r();return`\n    vec4 ${o}(${d}) {\n      int index = ${h};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${i});\n      return ${f.texture2D}(${r}, uv);\n    }\n  `}(e)}}const Or="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Nr="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",kr="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Dr="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Fr(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Mr(e){return"offset"+e}function Br(e){const t=e.name,n=b(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Pr(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Lr(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Wr(e,t){return t.map(t=>e[t]).join(", ")}class Ur{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const s=this.outputShape,i=s.length,u=Pr(i),l=br("coords",i);let c,d;if(1===a){d=i+1;const e=Pr(d);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[i-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[i-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[i-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[i-2]};`}else d=i,c=`\n        ${u} sourceLocR = coords;\n        ++${l[i-1]};\n        ${u} sourceLocG = coords;\n        ++${l[i-2]};\n        ${u} sourceLocA = coords;\n        --${l[i-1]};\n        ${u} sourceLocB = coords;\n        --${l[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),f="."+h[d-1],p=h.map(e=>"int "+e),m=br("sourceLocR",d-1).concat("inIdx.r"),g=br("sourceLocG",d-1).concat("inIdx.g"),x=br("sourceLocB",d-1).concat("inIdx.b"),v=br("sourceLocA",d-1).concat("inIdx.a"),C="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,b=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,_=r?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[i-1]} < ${s[i-1]-1};\n        bool hasNextRow = ${l[i-2]} < ${s[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${b};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${b};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class Vr{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Gr{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=c-1-e.padInfo.front,p=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${f}, ${p}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zr{constructor(e,t,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],dt(e,t),dt(e,n);let s="0.0";null!=r&&(dt(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="1.0";null!=o&&(dt(e,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${s};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Hr{constructor(e,t,n,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],dt(e,t),dt(e,n);let s="vec4(0.0)";null!=r&&(dt(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=o&&(dt(e,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${s};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Xr="return areal * breal - aimag * bimag;",jr="return areal * bimag + aimag * breal;";class qr{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=dt(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Kr="return a + b;",Yr="return a - b;",Qr="return a * b;",Zr="return (a < 0.) ? b * a : a;";class Jr{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=dt(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const eo="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class to{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=dt(t,n);const o=this.outputShape.length;let a="";if(r)if(0===o||1===b(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${Pr(o)} coords = getOutputCoords();\n        `,1===o)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=br("coords",o);a+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}class no{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class ro{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class oo{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class ao{constructor(e){this.outputShape=[],this.outputShape=at(e,1),this.variableNames=e.map((e,t)=>"T"+t);const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,o=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class so{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=at(e,t);const n=this.outputShape,r=n.length,o=Pr(r),a=br("coords",r),s=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>"T"+t);const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++)i[n]=i[n-1]+e[n][t];const u=s[t],l=s.slice(-2),c=s.join();let d=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];d+=`\n        if (${u} < ${i[e]}  && ${u} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${io(s,u,t)}),\n            vec2(${io(l,u,t)}));\n        }`}const h=i.length,f=i[i.length-1];d+=`\n        return getChannel(\n          getT${h}(${io(s,u,f)}),\n          vec2(${io(l,u,f)}));`,this.userCode=`\n      float getValue(${s.map(e=>"int "+e)}) {\n        ${d}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function io(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}class uo{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${a}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lo{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a="channelsLast"===e.dataFormat,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class co{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,s=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${o};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${s};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ho{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fo{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class po{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,s=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mo{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,s=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,p="channelsLast"===e.dataFormat,m=p?1:2,g=p?2:3,x=p?3:1;let y="",v="";n&&(y=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${p}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${p}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${p}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${p}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${v}\n        setOutput(result);\n      }\n    `}}class go{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,f=4*Math.floor(e.inChannels/4),p=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${a}, ${s});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===p}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===p}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===p}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xo{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.inHeight,a=e.inWidth,s=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,p=e.outChannels/e.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${u}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${p};\n        int q = d2 - d1 * ${p};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${g}\n        setOutput(result);\n      }\n    `}}class yo{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const o=e.inHeight,a=e.inWidth,s=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,p=f;let m="int xR; int xC; int xCOffset;";for(let e=0;e<h;e++)for(let t=0;t<f;t++)m+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<h;e++)for(let t=0;t<p;t++){const n=2*t;if(m+=`\n          xR = xRCorner + ${e*c};\n          xC = xCCorner + ${n*d};\n        `,1===l){if(n<f&&(m+=i%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${o} && xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    xTexelR${e}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${o} && xCOffset >= 0 && xCOffset < ${a}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${a}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${n} = vec4(previous.zw, xTexelR${e}C${n}.xy);\n                } else {\n                  xR${e}C${n} = vec4(0, 0, xTexelR${e}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${o} && xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xR${e}C${n} = xTexelR${e}C${n};\n              `,n+1<f)){const t=i%2==0?x(d):d;d%2==0&&i%2==1||d%2!=0&&i%2!=1?(m+=`\n                  xCOffset = xC + ${i%2} + ${t};\n\n                  if(xR >= 0 && xR < ${o} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,d>1&&(m+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${o} &&\n                      xCOffset >= 0 && xCOffset < ${a}) {\n                      xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${n} = vec4(0.);\n                    }\n                  `),m+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.xy);\n                `):m+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${o} &&\n                    xCOffset >= 0 && xCOffset < ${a}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${n+1} = xTexelR${e}C${n+2};\n                `}}else n<f&&(m+=`\n              if(xR >= 0 && xR < ${o}) {\n            `,i%2==1?(m+=`\n                xCOffset = xC + 1 - ${l};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n              `,n+1<f&&(m+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${l};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${n+1} = vec4(xTexelR${e}C${n+2}.xy, final.xy);\n                `)):(m+=`\n                if(xC >= 0 && xC < ${a}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${l};\n                if(xCOffset >= 0 && xCOffset < ${a}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.xy, xTexelR${e}C${n+2}.xy);\n              `,n+1<f&&(m+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n                `)),m+="}");n<f&&(m+=`\n            vec4 wTexelR${e}C${n} = getW(${e}, ${n}, d1, q);\n            wR${e}C${n} = vec4(wTexelR${e}C${n}.xz, wTexelR${e}C${n}.xz);\n          `,n+1<f&&(m+=`\n              vec4 wTexelR${e}C${n+1} = getW(${e}, ${n+1}, d1, q);\n              wR${e}C${n+1} =\n                vec4(wTexelR${e}C${n+1}.xz, wTexelR${e}C${n+1}.xz);`))}for(let e=0;e<h;e++)for(let t=0;t<f;t++)m+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let g="",y="";n&&(g=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,y="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${m}\n\n        vec4 result = dotProd;\n        ${v}\n        ${y}\n        setOutput(result);\n      }\n    `}}class vo{constructor(e,t,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,s,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const h="bilinear"===r?1:0,[f,p]=[s-1+".0",i-1+".0"],[m,g,x]=c>1?[""+(s-1)/(c-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+f],[y,v,C]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${p} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+p];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${C};\n        if( in_x < 0.0 || in_x > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class Co{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,o=t?"0.0":`getX(${wo(r,"coords")})`,a=e[e.length-1];let s="",i="";t?(s=n?"end != "+(a-1):"end != 0",i=n?"end + 1":"end - 1"):(s=n?"end + pow2 < "+a:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Pr(r)} coords = getOutputCoords();\n        int end = ${bo(r,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${s}) {\n          int idx = ${i};\n          ${bo(r,"coords")} = idx;\n          val += getX(${wo(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function wo(e,t){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function bo(e,t){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative sum for rank ${e} is not yet supported`)}class _o{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Un.DENSE;const t=Hn(e),n=_r();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Rr(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Ro{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Un.DENSE;const t=Hn(e),n=_r();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Rr(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Eo{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class $o{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class Io{constructor(e){this.variableNames=["A"],this.outTexUsage=Vn.DOWNLOAD;const t=_r();this.outputShape=e,this.userCode=`\n      ${$r}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Ao{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vn.DOWNLOAD;const t=_r();this.outputShape=e,this.userCode=`\n      ${$r}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class To{constructor(e,t,n=!1){this.variableNames=["A"];const r=_r(),[o,a]=t;this.outputShape=e;let s="result";n&&(s="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Er(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class So{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=_r(),[o,a]=t;this.outputShape=e;let s="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const i=2*t+n;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Er(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${s}\n\n        ${r.output} = ${i};\n      }\n    `}}const Oo="return real * expR - imag * expI;",No="return real * expI + imag * expR;";class ko{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${e}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class Do{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class Fo{constructor(e,t,n){this.variableNames=["A","indices"];const r=e.slice();r[n]=t,this.outputShape=r,this.rank=r.length;const o=Pr(this.rank),a=function(e,t){const n=e.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let n=0;n<e.length;n++)n===t?o.push(`int(getIndices(${r[n]}))`):o.push(""+r[n]);return o.join()}(e,n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}class Mo{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=Pr(t.length),o=Pr(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${a};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function Bo(e){const t=_r();return function(e,t){const n=ar(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(qn(e,()=>e.shaderSource(n,t)),qn(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Po(e){return function(e,t){const n=ar(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return qn(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),qn(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Lo(e){return function(e,t){const n=ar(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return qn(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),qn(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}function Wo(e,t,n,r,o,a){!function(e,t){const n=s().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}(t,n);const i=function(e){return ar(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),u=e.TEXTURE_2D;return qn(e,()=>e.bindTexture(u,i)),qn(e,()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),qn(e,()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),qn(e,()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST)),qn(e,()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST)),qn(e,()=>e.texImage2D(u,0,r,t,n,0,o,a,null)),qn(e,()=>e.bindTexture(e.TEXTURE_2D,null)),i}function Uo(e){return e.internalFormatFloat}function Vo(e){return e.internalFormatHalfFloat}function Go(e){return e.downloadTextureFormat}function zo(e){return e.internalFormatPackedFloat}function Ho(e){return e.internalFormatPackedHalfFloat}function Xo(e,t,n,r,o,a,s,i){const u=e,l=new Float32Array(function(e,t){const[n,r]=Xn(e,t);return n*r*4}(a,s));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}class jo{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=s().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){Pn[e]=t}(t,e)):this.gl=Wn(t);let n="WEBGL_color_buffer_float";if(1===s().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Yn(this.gl,e),fr(this.gl,t))this.textureHalfFloatExtension=Yn(this.gl,t);else if(s().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),fr(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=Yn(this.gl,"EXT_color_buffer_half_float");else if(s().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",fr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!fr(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=Po(this.gl),this.indexBuffer=Lo(this.gl),this.framebuffer=function(e){return ar(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=jn(this.gl,this.textureHalfFloatExtension)}get debug(){return s().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;qn(e,()=>e.finish()),qn(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),qn(e,()=>e.deleteFramebuffer(this.framebuffer)),qn(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),qn(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),qn(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,a]=zn(t,n);return Wo(e,o,a,Uo(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,a]=zn(t,n);return Wo(e,o,a,Vo(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,a]=zn(t,n);return Wo(e,o,a,Go(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){qn(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?qn(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):qn(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),qn(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,o,a){let s,i,u;qn(e,()=>e.bindTexture(e.TEXTURE_2D,t)),o instanceof Uint8Array?(s=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(s=new Float32Array(n*r*4),i=e.FLOAT,u=a.internalFormatPackedFloat),s.set(o),qn(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,s)),qn(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,a]=Xn(t,n);return Wo(e,o,a,Ho(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,a]=Xn(t,n);return Wo(e,o,a,zo(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(rr(this.gl,this.framebuffer),this.outputTexture=null),qn(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[o,a]=zn(t,n),s=new Uint8Array(t*n*4);return qn(e,()=>e.readPixels(0,0,o,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,s)),new Float32Array(s.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,o,a){return Xo(this.gl,e,0,0,0,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const o=e.createBuffer();qn(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o));const a=16*t*n;return qn(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),qn(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),qn(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),o}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(s().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(o,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=o}else s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return qn(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=Qn(t,e),r=Bo(t),o=function(e){return ar(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return qn(t,()=>t.attachShader(o,r)),qn(t,()=>t.attachShader(o,n)),function(e,t){if(qn(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,o),this.debug&&Jn(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=function(e,t,n){return qn(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),er(e,t,"clipSpacePos",n,3,20,0)&&er(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&qn(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&Jn(this.gl,this.program),qn(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return ar(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),qn(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){qn(e,()=>tr(e,t,r)),qn(e,()=>e.uniform1i(n,r))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,o]=Xn(t,n);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Jn(this.gl,this.program),or(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),qn(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),qn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Yn(this.gl,2===s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await A(()=>this.disposed||this.isQueryAvailable(e,s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||A(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),nr(this.gl,e,this.framebuffer),this.debug&&or(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(nr(this.gl,this.outputTexture,this.framebuffer),this.debug&&or(this.gl)):rr(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;nr(r,e,this.framebuffer),this.debug&&or(r),this.outputTexture=e,qn(r,()=>r.viewport(0,0,t,n)),qn(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),qn(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function qo(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,o=t[n],a=o.shape;if(!_(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&o.isUniform)return;const s=e.texShape,i=o.isUniform?null:o.texData.texShape;if(!_(s,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${s} and ${i} must match`)})}class Ko{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:o,strideWidth:a,strideHeight:s,padInfo:i,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:d}=n,{left:h,top:f}=i,p=o*r,m=_r(),g="channelsLast"===d,x=g?0:1,y=g?1:2;let v="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)v+=`\n          blockIndex = rc.y + ${r};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${s} - ${f};\n            d0 = offsetY + ${c} * (pos / ${p});\n\n            if(d0 < ${t[x]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${a}. - ${h}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${p}.) / ${o}.));\n\n              if(d1 < ${t[y]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${o}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+r}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+r}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}class Yo{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[];const a=t,s=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class Qo{constructor(e,t,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class Zo{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,s=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;i=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}class Jo{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,s=o-1-e.padInfo.top,i=a-1-e.padInfo.left,u=o*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ea{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,h=l-1-e.padInfo.left,f=i*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${s}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${f} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ta{constructor(e,t,n=!1,r=!1,o=!1,a=null,s=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const i=n?e[1]:e[2],u=Math.ceil(i/2),l=n?"i * 2, rc.y":"rc.y, i * 2",c=r?"rc.z, i * 2":"i * 2, rc.z",d=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",p="";a&&(f=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,p="result = activation(result);");const m=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${h[0]});\n          result += (${d[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${m}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `}}class na{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}class ra{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class oa{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=br("rc",t),r=Pr(t),o=function(e,t,n){if(1===e)return"rc > "+t[0];let r="";for(let o=e-2;o<e;o++)r+=`${n[o]} >= ${t[o]}`,o<e-1&&(r+="||");return r}(t,e,n),a=function(e,t,n,r){if(1===e)return"";const o=r.slice(-2);return`\n    int r = ${o[0]};\n    int c = ${o[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),s=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let a=`${0===r?"r":"rp1"}, ${0===o?"c":"cp1"}`;for(let n=2;n<e;n++)a=t[t.length-1-n]+","+a;n.push(a)}return n}(n,t);if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}}class aa{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,o=Pr(r),a=t.map(e=>e[0]).join(","),s=t.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${o} start = ${o}(${a});\n      ${o} end = ${o}(${s});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class sa{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,o=Pr(r),a=t.map(e=>e[0]).join(","),s=t.map((t,n)=>t[0]+e[n]).join(","),i=br("rc",r),u=br("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,d=[o+" rc = outputLoc;",`${i[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${l}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let e=0,t=1===r?2:4;e<t;e++)f+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(${n});\n        } else {\n          ${o} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;f+=1===r?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${a});\n      const ${o} end = ${o}(${s});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}class ia{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,s=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const p="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(p||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${i});\n        const ivec2 pads = ivec2(${h}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?o?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / count");const v=4*Math.floor(a/4),C=a%4,w=`\n      if (${p}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${h}, ${f});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class ua{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,s=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${p};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${p} +\n                      wR * ${p} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(C="avgValue / count");const w=4*Math.floor(a/4),b=a%4,_=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===b}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}class la{constructor(e,t){this.variableNames=["x"];const n=e.windowSize,r=e.batchSize,o=e.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];let s="0.0",i="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",i="min"):"max"===t&&(s="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,h="vec4";"all"===t?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let f="";o%n>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}class ca{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${Rr(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Er(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class da{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,o]=t.shape,[,a,s]=e.shape,i=[n&&a>1?r-1:r,n&&s>1?o-1:o],u=[n&&a>1?a-1:a,n&&s>1?s-1:s],l=i[0]/u[0],c=i[1]/u[1],d=1/l,h=1/c,f=2*Math.ceil(d)+2,p=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class ha{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[o,a,s,i]=e;this.outputShape=[o,t,n,i];const u=[r&&t>1?a-1:a,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class fa{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,s,i]=e;this.outputShape=[o,t,n,i];const u=[r&&t>1?a-1:a,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${i-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class pa{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;const[,r,o]=t.shape,[,a,s]=e.shape,i=[n&&a>1?r-1:r,n&&s>1?o-1:o],u=[n&&a>1?a-1:a,n&&s>1?s-1:s],l=i[0]/u[0],c=i[1]/u[1],d=1/l,h=1/c,f=2*Math.ceil(d)+2,p=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class ma{constructor(e,t,n,r){this.variableNames=["A"],this.outputShape=[];const[o,a,s,i]=e;this.outputShape=[o,t,n,i];const u=[r&&t>1?a-1:a,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class ga{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),o=Pr(n);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class xa{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=br("rc",n),o=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,s=Pr(n);function i(n){const r=e.map((r,o)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:""+r[n]}(o,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(r.slice())};\n          if(${o}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            if(${o}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class ya{constructor(e,t,n,r,o,a,s=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const i=Pr(o.length),u=Pr(a.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`,f=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${f};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class va{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,s=a*Math.ceil(o/n);this.outputShape=[r,s];const i=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";o%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let d="";o%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Ca{constructor(e,t,n){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)o="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],s=[];for(let r=0;r<t.length;r++)s.push(""+n[r]),r<e&&a.push(""+n[r]);r=a.join(),o=s.join()}const a=Pr(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}class wa{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Pr(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return ba.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let o;o=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${ba[t]} = start[${t}] + coords.${ba[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${o}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const ba=["x","y","z","w","u","v"];class _a{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=Pr(this.rank),n=br("coords",this.rank),r=br("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,s=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${s}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}class Ra{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,o=Pr(n.length),a=Pr(n.length);let s="";if(1===r)s="coords * strides + begin";else{let e=0;s=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${e});\n      ${o} strides = ${o}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class Ea{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=Ia(t,n),o=Aa(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=$a(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[o].shift();return this.usedTextures[o].push(e),e}let s;return r===Gn.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Gn.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Gn.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Gn.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Gn.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(s),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const o=Ia(n,r),a=Aa(t,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=$a(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=s().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $a(e,t,n,r,o){const a=function(e,t){switch(e){case Gn.PACKED_2X2_FLOAT32:return zo(t);case Gn.PACKED_2X2_FLOAT16:return Ho(t);case Gn.UNPACKED_FLOAT32:return Uo(t);case Gn.UNPACKED_FLOAT16:return Vo(t);case Gn.PACKED_4X1_UNSIGNED_BYTE:return Go(t);default:throw new Error("Unknown physical texture type "+e)}}(t,r);let s;if(o){const[t,n]=Xn(e[0],e[1]);s=t*n}else{const[t,n]=zn(e[0],e[1]);s=t*n}return s*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error("Unknown internal format "+t)}(n,a)}function Ia(e,t){if(e===Vn.UPLOAD)return Gn.PACKED_2X2_FLOAT32;if(e===Vn.RENDER||null==e)return function(e){return s().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Gn.PACKED_2X2_FLOAT32:Gn.UNPACKED_FLOAT32:e?Gn.PACKED_2X2_FLOAT16:Gn.UNPACKED_FLOAT16}(t);if(e===Vn.DOWNLOAD||e===Vn.PIXELS)return Gn.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function Aa(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Ta{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=Pr(this.rank),o=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}class Sa{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Oa="if (isnan(x)) return x;",Na="return abs(x);",ka=Oa+"\n  return (x < 0.0) ? 0.0 : x;\n",Da=Oa+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Fa="return (x >= 0.0) ? x : (exp(x) - 1.0);";const Ma="return -x;",Ba="return ceil(x);",Pa="return floor(x);",La="return exp(x);",Wa="return exp(x) - 1.0;",Ua="return x;",Va="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Ga="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",za="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class Ha{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Xa{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=br("rc",t),r=Pr(t),o=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),s=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}}const{segment_util:ja}=ln,qa=hn,Ka=fn,Ya=pn,Qa=Lt,Za={};function Ja(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?Va:ka;if("elu"===e)return t?za:Fa;if("relu6"===e)return t?Ga:Da;if("prelu"===e)return t?eo:Zr;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class es extends gn{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!s().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=Wn(s().getNumber("WEBGL_VERSION"));this.binaryCache=((t=s().getNumber("WEBGL_VERSION"))in Za||(Za[t]={}),Za[t]),this.gpgpu=new jo(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new Ea(this.gpgpu),this.numMBBeforeWarning=null==s().global.screen?1024:s().global.screen.height*s().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new mn(this,ze())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,t,n){if((s().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||s().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:Vn.UPLOAD}),r}move(e,t,n,r){if(s().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:Vn.UPLOAD})}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensors:o,slice:a,shape:s,isPacked:i}=t;if(null!=a){let t;t=i?new Ha(s,Ua):new Sa(s,Ua);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:r}],r),o=this.readSync(n.dataId);return this.disposeData(n.dataId),o}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;if(u&&(l=G()),"complex64"===r){c=Qt(o.real.dataSync(),o.imag.dataSync())}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=G()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:r,slice:o,dtype:a,complexTensors:i,isPacked:u}=t;if(null!=o){let t;t=u?new Ha(r,Ua):new Sa(r,Ua);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),o=this.read(n.dataId);return this.disposeData(n.dataId),o}if(null!=n)return this.convertAndCacheOnCPU(e);if(!s().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===s().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if("complex64"!==a&&s().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture,...Hn(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([i.real.data(),i.imag.data()]);c=Qt(e[0],e[1])}else if(null==d)c=this.getValuesFromTexture(e);else{const e=b(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}null!=l&&this.disposeData(l.dataId);const h=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),h}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!Kn(n)){if(s().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),o=b(t);if(s().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...Hn(t)).subarray(0,o);return this.disposeData(n.dataId),a}const a=s().getBool("WEBGL_PACK")&&!0===r,i=a?ur(t):t,u=a?new Ao(i):new Io(i),l=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeData(l.dataId),d}async time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=w(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),a=w(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:G(),endMs:null}}endTimer(e){return s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=G(),e)}async getQueryTime(e){if(s().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){if(this.pendingDisposal.has(e))return;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(!this.texData.has(e))return;this.releaseGPUData(e);const{complexTensors:t}=this.texData.get(e);null!=t&&(t.real.dispose(),t.imag.dispose()),this.texData.delete(e)}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:o,isPacked:a,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,o,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return s().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=ze().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,t=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||s().getBool("IS_TEST")||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&e.every(e=>null==this.texData.get(e.dataId).texture&&b(e.shape)<t)}getGPGPUContext(){return this.gpgpu}complex(e,t){const n=this.makeOutput(e.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:ze().keep(e.clone()),imag:ze().keep(t.clone())},n}real(e){return this.texData.get(e.dataId).complexTensors.real.clone()}imag(e){return this.texData.get(e.dataId).complexTensors.imag.clone()}slice(e,t,n){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.slice(e,t,n);if(0===b(n))return Ee([],n,e.dtype);const{isPacked:r}=this.texData.get(e.dataId),o=Ve(e.shape,t,n);if(r||!o){const r=s().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _a(n):new wa(n),o=r.getCustomSetupFunc(t);return this.compileAndRun(r,[e],null,o)}return this.uploadToGPU(e.dataId),this.shallowSlice(e,t,n)}shallowSlice(e,t,n){const r=this.texData.get(e.dataId),o=this.makeOutput(n,e.dtype),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=e.dtype;let s=Ge(t,e.strides);r.slice&&(s+=r.slice.flatOffset),a.slice={flatOffset:s,origDataId:r.slice&&r.slice.origDataId||e.dataId};const i=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,i+1),o}stridedSlice(e,t,n,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.stridedSlice(e,t,n,r);const o=Ue(t,n,r);if(o.some(e=>0===e))return Ee([],o);const a=new Ra(t,r,o);return this.compileAndRun(a,[e])}reverse(e,t){const n=s().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xa(e.shape,t):new ga(e.shape,t);return this.compileAndRun(n,[e])}concat(e,t){if("complex64"===e[0].dtype){const n=e.map(e=>yt(e)),r=e.map(e=>xt(e));return _e(this.concat(n,t),this.concat(r,t))}if(this.shouldExecuteOnCPU(e))return this.cpuBackend.concat(e,t);if(1===e.length)return e[0];if(e.length>s().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(e.length/2),r=this.concat(e.slice(0,n),t),o=this.concat(e.slice(n),t);return this.concat([r,o],t)}if(s().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].rank>1){const n=new so(e.map(e=>e.shape),t);return this.compileAndRun(n,e)}const n=at(e.map(e=>e.shape),t),r=e.map(e=>e.as2D(-1,b(e.shape.slice(t)))),o=new ao(r.map(e=>e.shape));return this.compileAndRun(o,r).reshape(n)}neg(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.neg(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Ma,e.dtype);const t=new Sa(e.shape,Ma);return this.compileAndRun(t,[e])}batchMatMul(e,t,n,r){const o=n?e.shape[2]:e.shape[1],a=r?t.shape[1]:t.shape[2],s=n?e.shape[1]:e.shape[2],[i,,]=e.shape;if((1===o||1===a)&&s>1e3){n&&(e=Ae(e,[0,2,1])),r&&(t=Ae(t,[0,2,1]));const o=1===a?e:e.as3D(i,s,1),u=1===a?2:1,l=1===a?t.as3D(i,1,s):t;return this.multiply(o,l).sum(u,!0)}const u=ce(e.dtype,t.dtype),l=new ta(e.shape,[i,o,a],n,r);return this.compileAndRun(l,[e,t],u)}fusedBatchMatMul({a:e,b:t,transposeA:n,transposeB:r,bias:o,activation:a,preluActivationWeights:s}){const i=n?e.shape[2]:e.shape[1],u=r?t.shape[1]:t.shape[2],[l,,]=e.shape,c=ce(e.dtype,t.dtype),d=null!=o,h=null!=s,f=a?Ja(a,!0):null,p=new ta(e.shape,[l,i,u],n,r,d,f,h),m=[e,t];return o&&m.push(o),s&&m.push(s),this.compileAndRun(p,m,c)}multiply(e,t){if("complex64"===e.dtype){const n=this.texData.get(e.dataId),r=this.texData.get(t.dataId),o=new qr(Xr,e.shape,t.shape),a=new qr(jr,e.shape,t.shape),s=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag),this.makeComplexComponentTensorInfo(t,r.complexTensors.real),this.makeComplexComponentTensorInfo(t,r.complexTensors.imag)],i=this.compileAndRun(o,s),u=this.compileAndRun(a,s),l=this.complex(i,u);return i.dispose(),u.dispose(),l}if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.multiply(e,t);if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,Qr,e.dtype);const n=new Jr(Qr,e.shape,t.shape);return this.compileAndRun(n,[e,t],e.dtype)}batchNorm(e,t,n,r,o,a){const i=[e,t,n];let u=null;null!=r&&(u=r.shape,i.push(r));let l=null;if(null!=o&&(l=o.shape,i.push(o)),s().getBool("WEBGL_PACK_NORMALIZATION")){const r=new Hr(e.shape,t.shape,n.shape,u,l,a);return this.compileAndRun(r,i)}const c=new zr(e.shape,t.shape,n.shape,u,l,a);return this.compileAndRun(c,i)}localResponseNormalization4D(e,t,n,r,o){const a=s().getBool("WEBGL_PACK_NORMALIZATION")?new Zo(e.shape,t,n,r,o):new Yo(e.shape,t,n,r,o);return this.compileAndRun(a,[e])}LRNGrad(e,t,n,r,o,a,s){const i=new Qo(t.shape,r,o,a,s);return this.compileAndRun(i,[t,n,e])}tile(e,t){if("string"===e.dtype){const n=this.readSync(e.dataId).map(e=>H(e)),r=ut(e.shape,e.dtype,n);return Ka(r,t)}const n=new Ta(e.shape,t);return this.compileAndRun(n,[e])}pad(e,t,n){const r=s().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sa(e.shape,t,n):new aa(e.shape,t,n);return this.compileAndRun(r,[e])}gather(e,t,n){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.gather(e,t,n);const r=new Fo(e.shape,t.size,n);return this.compileAndRun(r,[e,t])}batchToSpaceND(e,t,n){y(e.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const r=t.reduce((e,t)=>e*t),o=Ht(e.shape,t,r),a=Xt(o.length,t.length),s=jt(e.shape,t,r),i=qt(n,t.length),u=Kt(s,n,t.length);return Ae(e.reshape(o),a).reshape(s).slice(i,u)}spaceToBatchND(e,t,n){y(e.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const r=t.reduce((e,t)=>e*t),o=[[0,0]];o.push(...n);for(let n=1+t.length;n<e.shape.length;++n)o.push([0,0]);const a=e.pad(o),s=Ht(a.shape,t,r,!1),i=Xt(s.length,t.length,!1),u=jt(a.shape,t,r,!1),l=Ae(a.reshape(s),i);return Ie(l,u)}reduce(e,t,n){const r=e.shape[0],o=e.shape[1],a=mt(o),s=new la({windowSize:a,inSize:o,batchSize:r},t),i=this.compileAndRun(s,[e],n);return 1===i.shape[1]?i:this.reduce(i,t,n)}argReduce(e,t,n=null){let r=e.shape[0],o=e.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);const a=mt(o),s=new Cr({windowSize:a,inSize:o,batchSize:r},t,null==n),i=[e];null!=n&&i.push(n);const u=this.compileAndRun(s,i,"int32");return 1===u.shape[1]?u:this.argReduce(e,t,u)}argReducePacked(e,t,n=null){const r=null!=n?n.shape:e.shape,o=mt(r[r.length-1]),a=new Ur(r,o,t,null==n),s=null==n?[e]:[e,n],i=this.compileAndRun(a,s,"int32");return i.rank===e.rank?this.argReducePacked(e,t,i):i}sum(e,t){ke("sum",t,e.rank);const[n,r]=Oe(e.shape,t),o=b(r),a=e.as2D(-1,o),s=de(e.dtype);return this.reduce(a,"sum",s).reshape(n)}prod(e,t){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.prod(e,t);const[n,r]=Oe(e.shape,t),o=b(r),a=e.as2D(-1,o),s=de(e.dtype);return this.reduce(a,"prod",s).reshape(n)}unsortedSegmentSum(e,t,n){let r=0;const o=De([r],e.rank);let a=e;null!=o&&(a=Ae(e,o),r=Me(1,e.rank)[0]);const s=ja.computeOutShape(a.shape,r,n),i=b([a.shape[r]]),u=a.as2D(-1,i),l=de(e.dtype);let c=this.segOpCompute(u,"unsortedSegmentSum",t,l,n).reshape(s);return null!=o&&(c=Ae(c,Fe(o))),c}segOpCompute(e,t,n,r,o){const a=e.shape[0],s=e.shape[1],i=ja.segOpComputeOptimalWindowSize(s,o),u=new va({windowSize:i,inSize:s,batchSize:a,numSegments:o},t),l=this.compileAndRun(u,[e,n],r);return l.shape[1]===o?l:(n=function(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:e,stop:t,step:n,dtype:r};return ge.runKernelFunc(()=>{if(e===t||e<t&&n<0||t<e&&n>1)return wt([0],r);const o=V(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+n;return Nt(o,r)},{},null,"Range",o)}(0,o).tile([s/i]),this.segOpCompute(l,t,n,r,o))}argMinMaxReduce(e,t,n){const r=[t];if(ke("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,e.rank),!s().getBool("WEBGL_PACK_REDUCE")||e.rank<=2){const[t,o]=Oe(e.shape,r),a=b(o),s=e.as2D(-1,a);return this.argReduce(s,n).reshape(t)}return this.argReducePacked(e,n)}argMin(e,t){return this.argMinMaxReduce(e,t,"min")}argMax(e,t){return this.argMinMaxReduce(e,t,"max")}cumsum(e,t,n,r){if(t!==e.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${e.rank-1} but got axis=`+t);const o=e.shape[t];let a=e;for(let t=0;t<=Math.ceil(Math.log2(o))-1;t++){const n=new Co(e.shape,!1,r),o=n.getCustomSetupFunc(t),s=a;a=this.compileAndRun(n,[a],a.dtype,o),s.dispose()}if(n){const t=new Co(e.shape,n,r),o=a;a=this.compileAndRun(t,[a]),o.dispose()}return a}equal(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(equal(a, b));\n","bool");const n=new Jr("return float(a == b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}notEqual(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(notEqual(a, b));\n","bool");const n=new Jr("return float(a != b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}less(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.less(e,t);if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(lessThan(a, b));\n","bool");const n=new Jr("return float(a < b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}lessEqual(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new Jr("return float(a <= b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}greater(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.greater(e,t);if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(greaterThan(a, b));\n","bool");const n=new Jr("return float(a > b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}greaterEqual(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new Jr("return float(a >= b);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}logicalNot(e){const t=new Sa(e.shape,"return float(!(x >= 1.0));");return this.compileAndRun(t,[e])}logicalAnd(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new Jr("return float(a >= 1.0 && b >= 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}logicalOr(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new Jr("return float(a >= 1.0 || b >= 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t],"bool")}select(e,t,n){const r=new Ca(e.rank,t.shape,t.rank);return this.compileAndRun(r,[e,t,n],ce(t.dtype,n.dtype))}where(e){Yt("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Qa(e.shape,t)}topk(e,t,n){const r=e.dataSync();return Ya(r,e.shape,e.dtype,t)}min(e,t){ke("min",t,e.rank);const[n,r]=Oe(e.shape,t),o=b(r),a=e.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(n)}minimum(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.minimum(e,t);const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new Jr("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",e.shape,t.shape);return this.compileAndRun(n,[e,t])}mod(e,t){const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new Jr("if (b == 0.0) return NAN;\n  return mod(a, b);",e.shape,t.shape);return this.compileAndRun(n,[e,t])}maximum(e,t){if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.maximum(e,t);const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new Jr("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",e.shape,t.shape);return this.compileAndRun(n,[e,t])}all(e,t){ke("all",t,e.rank);const[n,r]=Oe(e.shape,t),o=b(r),a=e.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(n)}any(e,t){ke("any",t,e.rank);const[n,r]=Oe(e.shape,t),o=b(r),a=e.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(n)}floorDiv(e,t){if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");const n=new Jr("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",e.shape,t.shape);return this.compileAndRun(n,[e,t],"int32")}add(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,Kr);if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.add(e,t);const n=ce(e.dtype,t.dtype);if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,Kr,n);const r=new Jr(Kr,e.shape,t.shape);return this.compileAndRun(r,[e,t],n)}packedUnaryOp(e,t,n){const r=new Ha(e.shape,t);return this.compileAndRun(r,[e],n)}packedBinaryOp(e,t,n,r,o=!1){const a=new to(n,e.shape,t.shape,o);return this.compileAndRun(a,[e,t],r)}complexSeparableBinaryOp(e,t,n){const r=this.texData.get(e.dataId),o=this.texData.get(t.dataId),[a,s]=[[r.complexTensors.real,o.complexTensors.real],[r.complexTensors.imag,o.complexTensors.imag]].map(r=>{const[o,a]=r,s=this.makeComplexComponentTensorInfo(e,o),i=this.makeComplexComponentTensorInfo(t,a),u=new Jr(n,e.shape,t.shape);return this.compileAndRun(u,[s,i],ce(o.dtype,a.dtype))}),i=this.complex(a,s);return a.dispose(),s.dispose(),i}makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}addN(e){if(1===e.length)return e[0];if(e.length>s().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(e.length/2),n=this.addN(e.slice(0,t)),r=this.addN(e.slice(t));return this.addN([n,r])}const t=e.map(e=>e.dtype).reduce((e,t)=>ce(e,t)),n=e.map(e=>e.shape),r=s().getBool("WEBGL_PACK")?new vr(e[0].shape,n):new yr(e[0].shape,n);return this.compileAndRun(r,e,t)}subtract(e,t){if("complex64"===e.dtype&&"complex64"===t.dtype)return this.complexSeparableBinaryOp(e,t,Yr);if(this.shouldExecuteOnCPU([e,t]))return this.cpuBackend.subtract(e,t);const n=ce(e.dtype,t.dtype);if(s().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,t,Yr,e.dtype);const r=new Jr(Yr,e.shape,t.shape);return this.compileAndRun(r,[e,t],n)}pow(e,t){const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new Jr("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",e.shape,t.shape),r=ce(e.dtype,t.dtype);return this.compileAndRun(n,[e,t],r)}ceil(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.ceil(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Ba,e.dtype);const t=new Sa(e.shape,Ba);return this.compileAndRun(t,[e])}floor(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.floor(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Pa,e.dtype);const t=new Sa(e.shape,Pa);return this.compileAndRun(t,[e])}sign(e){const t=new Sa(e.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(t,[e])}isNaN(e){const t=new Sa(e.shape,"return float(isnan(x));");return this.compileAndRun(t,[e],"bool")}isInf(e){const t=new Sa(e.shape,"return float(isinf(x));");return this.compileAndRun(t,[e],"bool")}isFinite(e){const t=new Sa(e.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(t,[e],"bool")}round(e){const t=new Sa(e.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(t,[e])}exp(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.exp(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,La,e.dtype);const t=new Sa(e.shape,La);return this.compileAndRun(t,[e])}expm1(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.expm1(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Wa,e.dtype);const t=new Sa(e.shape,Wa);return this.compileAndRun(t,[e])}softmax(e,t){const n=T([t],e.shape),r=Be(e,n),o=Ne(r.shape,n),a=this.subtract(e,r.reshape(o)),s=this.exp(a),i=this.sum(s,n).reshape(o);return je(s,i)}log(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.log(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",e.dtype);const t=new Sa(e.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(t,[e])}log1p(e){const t=new Sa(e.shape,"return log(1.0 + x);");return this.compileAndRun(t,[e])}sqrt(e){const t=new Sa(e.shape,"return sqrt(x);");return this.compileAndRun(t,[e])}rsqrt(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.rsqrt(e);const t=new Sa(e.shape,"return inversesqrt(x);");return this.compileAndRun(t,[e])}reciprocal(e){const t=new Sa(e.shape,"return 1.0 / x;");return this.compileAndRun(t,[e])}relu(e){let t;return t=s().getBool("WEBGL_PACK")?new Ha(e.shape,Va):new Sa(e.shape,ka),this.compileAndRun(t,[e])}relu6(e){let t;return t=s().getBool("WEBGL_PACK")?new Ha(e.shape,Ga):new Sa(e.shape,Da),this.compileAndRun(t,[e])}prelu(e,t){const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to(eo,e.shape,t.shape):new Jr(Zr,e.shape,t.shape);return this.compileAndRun(n,[e,t])}elu(e){if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,za,e.dtype);const t=new Sa(e.shape,Fa);return this.compileAndRun(t,[e])}eluDer(e,t){const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",e.shape,t.shape):new Jr("return (b >= 1.0) ? a : a * (b + 1.0);",e.shape,t.shape);return this.compileAndRun(n,[e,t])}selu(e){const t=new Sa(e.shape,"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n");return this.compileAndRun(t,[e])}int(e){const t=new Sa(e.shape,"return float(int(x));");return this.compileAndRun(t,[e],"int32")}clip(e,t,n){let r;r=s().getBool("WEBGL_PACK_CLIP")?new ro(e.shape):new no(e.shape);const o=r.getCustomSetupFunc(t,n);return this.compileAndRun(r,[e],null,o)}abs(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.abs(e);if(s().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Na,e.dtype);const t=new Sa(e.shape,Na);return this.compileAndRun(t,[e])}complexAbs(e){const t=this.texData.get(e.dataId),n=new oo(e.shape),r=[this.makeComplexComponentTensorInfo(e,t.complexTensors.real),this.makeComplexComponentTensorInfo(e,t.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(e){const t=new Sa(e.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(t,[e])}softplus(e){const t=new Sa(e.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(t,[e])}sin(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(t,[e])}cos(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(t,[e])}tan(e){const t=new Sa(e.shape,"return tan(x);");return this.compileAndRun(t,[e])}asin(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(t,[e])}acos(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(t,[e])}atan(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(t,[e])}atan2(e,t){const n=s().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new to("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",e.shape,t.shape):new Jr("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",e.shape,t.shape);return this.compileAndRun(n,[e,t])}sinh(e){const t=new Sa(e.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}cosh(e){const t=new Sa(e.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(t,[e])}tanh(e){const t=new Sa(e.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(t,[e])}asinh(e){const t=new Sa(e.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(t,[e])}acosh(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(t,[e])}atanh(e){const t=new Sa(e.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(t,[e])}erf(e){const t=new Sa(e.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');return this.compileAndRun(t,[e])}step(e,t){const n=new Sa(e.shape,function(e=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e});\n  `}(t));return this.compileAndRun(n,[e])}conv2dByMatMul(e,t,n,r,o,a){const i=e.shape,u=this.texData.get(e.dataId),l=n.inChannels,c=i[0]*i[1]*i[2],d=n.outChannels,h="channelsLast"===n.dataFormat,f=(1===c||1===d)&&l>1e3,p=i[2]%2!=0&&!!u.isPacked;if(f||!s().getBool("WEBGL_LAZILY_UNPACK")||!s().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!p){const s=h?i[0]*i[1]*i[2]:i[0]*i[2]*i[3],u=this.reshape(e,[1,s,n.inChannels]),l=this.reshape(t,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:u,b:l,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),n.outShape)}const m=h?i[0]*i[1]*(i[2]+1):i[0]*i[2]*(i[3]+1),g={dataId:e.dataId,shape:[1,m,n.inChannels],dtype:e.dtype},x=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,y(cr(u.shape,g.shape),()=>`packed reshape ${u.shape} to ${g.shape} isn't free`);const v=this.reshape(t,[1,n.inChannels,n.outChannels]),C=this.fusedBatchMatMul({a:g,b:v,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a}),w=this.texData.get(C.dataId);return y(w.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=x,w.shape=n.outShape,ze().makeTensorFromDataId(C.dataId,n.outShape,C.dtype)}conv2dWithIm2Row(e,t,n,r,o,a){const{filterWidth:s,filterHeight:i,inChannels:u,outWidth:l,outHeight:c,dataFormat:d}=n,h="channelsLast"===d,f=s*i*u,p=c*l,m=[f,p],g=e.squeeze([0]),x=t.reshape([1,f,-1]),y=new Ko(m,g.shape,n),v=this.compileAndRun(y,[g]).reshape([1,m[0],m[1]]),C=null!=r,w=null!=a,b=o?Ja(o,!0):null,_=new ta(v.shape,[1,p,n.outChannels],!0,!1,C,b,w),R=[v,x];r&&R.push(r),w&&R.push(a);const E=this.compileAndRun(_,R);return h?E.reshape([1,c,l,n.outChannels]):E.reshape([1,n.outChannels,c,l])}fusedConv2d({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(e,t,n,r,o,a);if(s().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,n,r,o,a);const i=null!=r,u=null!=a,l=o?Ja(o,!1):null,c=new mo(n,i,l,u),d=[e,t];return r&&d.push(r),a&&d.push(a),this.compileAndRun(c,d)}conv2d(e,t,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(e,t,n);if(s().getBool("WEBGL_CONV_IM2COL")&&1===e.shape[0])return this.conv2dWithIm2Row(e,t,n);const r=new mo(n);return this.compileAndRun(r,[e,t])}conv2dDerInput(e,t,n){const r=new lo(n);return this.compileAndRun(r,[e,t])}conv2dDerFilter(e,t,n){const r=new uo(n);return this.compileAndRun(r,[e,t])}fusedDepthwiseConv2D({input:e,filter:t,convInfo:n,bias:r,activation:o,preluActivationWeights:a}){const i=s().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,u=o?Ja(o,i):null,l=[e,t],c=null!=r,d=null!=a;let h;return c&&l.push(r),d&&l.push(a),i?(h=new yo(n,c,u,d),this.compileAndRun(h,l)):(h=new xo(n,c,u,d),this.compileAndRun(h,l))}depthwiseConv2D(e,t,n){let r;return s().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new yo(n),this.compileAndRun(r,[e,t])):(r=new xo(n),this.compileAndRun(r,[e,t]))}depthwiseConv2DDerInput(e,t,n){const r=new po(n);return this.compileAndRun(r,[e,t])}depthwiseConv2DDerFilter(e,t,n){const r=new fo(n);return this.compileAndRun(r,[e,t])}conv3d(e,t,n){const r=new go(n);return this.compileAndRun(r,[e,t])}conv3dDerInput(e,t,n){const r=new ho(n);return this.compileAndRun(r,[e,t])}conv3dDerFilter(e,t,n){const r=new co(n);return this.compileAndRun(r,[e,t])}maxPool(e,t){const n=new ia(t,"max",!1);return this.compileAndRun(n,[e])}avgPool(e,t){const n=new ia(t,"avg",!1);return this.compileAndRun(n,[e],"float32")}maxPoolBackprop(e,t,n,r){const o=new ia(r,"max",!0),a=this.compileAndRun(o,[t]),s=new Jo(r),i=this.compileAndRun(s,[e,a],t.dtype);return a.dispose(),i}avgPoolBackprop(e,t,n){const r=new Vr(n);return this.compileAndRun(r,[e],t.dtype)}cast(e,t){return an(e,t,this)}unstack(e,t){const n=e.shape[t],r=new Array(e.rank-1);let o=0;for(let n=0;n<e.rank;n++)n!==t&&(r[o++]=e.shape[n]);const a=new Array(e.rank).fill(0),s=e.shape.slice();s[t]=1;const i=new Array(n);for(let n=0;n<i.length;n++)a[t]=n,i[n]=this.slice(e,a,s).reshape(r);return i}avgPool3d(e,t){const n=new ua(t,"avg",!1);return this.compileAndRun(n,[e],"float32")}avgPool3dBackprop(e,t,n){const r=new Gr(n);return this.compileAndRun(r,[e],t.dtype)}maxPool3d(e,t){const n=new ua(t,"max",!1);return this.compileAndRun(n,[e],"float32")}maxPool3dBackprop(e,t,n,r){const o=new ua(r,"max",!0),a=this.compileAndRun(o,[t]),s=new ea(r),i=this.compileAndRun(s,[e,a],t.dtype);return a.dispose(),i}reshape(e,t){const n=this.texData.get(e.dataId);if(n.isPacked&&!cr(e.shape,t)&&(null===n.texture||!cr(n.shape,t))){const n=this.packedReshape(e,t);return ze().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}return sn(e,t)}resizeBilinear(e,t,n,r){const o=s().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fa(e.shape,t,n,r):new ha(e.shape,t,n,r);return this.compileAndRun(o,[e],"float32")}resizeBilinearBackprop(e,t,n){const r=new da(e,t,n);return this.compileAndRun(r,[e])}resizeNearestNeighbor(e,t,n,r){const o=new ma(e.shape,t,n,r);return this.compileAndRun(o,[e])}resizeNearestNeighborBackprop(e,t,n){const r=new pa(e,t,n);return this.compileAndRun(r,[e])}multinomial(e,t,n,r){const o=t?e:Ft(e),a=o.shape[0],s=o.shape[1],i=new na(a,s,n),u=i.getCustomSetupFunc(r);return this.compileAndRun(i,[o],"int32",u)}oneHot(e,t,n,r){const o=new ra(e.size,t,n,r);return this.compileAndRun(o,[e])}diag(e){const t=new $o(e.size);return this.compileAndRun(t,[e])}cropAndResize(e,t,n,r,o,a){const s=new vo(e.shape,t.shape,r,o,a);return this.compileAndRun(s,[e,t,n],"float32")}depthToSpace(e,t,n){y(t>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+t);const r=e.shape[0],o="NHWC"===n?e.shape[1]:e.shape[2],a="NHWC"===n?e.shape[2]:e.shape[3],s="NHWC"===n?e.shape[3]:e.shape[1],i=o*t,u=a*t,l=s/(t*t),c=new Eo("NHWC"===n?[r,i,u,l]:[r,l,i,u],t,n);return this.compileAndRun(c,[e])}split(e,t,n){return qa(e,t,n)}scatterND(e,t,n){const{sliceRank:r,numUpdates:o,sliceSize:a,strides:s,outputSize:i}=We(0,e,n),u=[i/a,a],l=e.reshape([o,r]),c=t.reshape([o,a]);if(0===i)return sn(Ee([]),n);const d=vt(0),h=new ya(o,r,l.rank,c.rank,s,u);return this.compileAndRun(h,[c,l,d]).reshape(n)}sparseToDense(e,t,n,r){const{sliceRank:o,numUpdates:a,strides:s,outputSize:i}=We(0,e,n),u=new ya(a,o,e.rank,t.rank,s,[i,1],!1);return this.compileAndRun(u,[t,e,r]).reshape(n)}fft(e){return this.fftImpl(e,!1)}ifft(e){return this.fftImpl(e,!0)}fftImpl(e,t){const n=this.texData.get(e.dataId),r=new ko(Oo,e.shape,t),o=new ko(No,e.shape,t),a=[this.makeComplexComponentTensorInfo(e,n.complexTensors.real),this.makeComplexComponentTensorInfo(e,n.complexTensors.imag)],s=this.compileAndRun(r,a),i=this.compileAndRun(o,a),u=this.complex(s,i).as2D(e.shape[0],e.shape[1]);return s.dispose(),i.dispose(),u}gatherND(e,t){const n=t.shape,r=n[n.length-1],[o,a,s,i]=Pe(e,t),u=t.reshape([a,r]),l=e.reshape([e.size/s,s]),c=new Mo(r,i,[a,s]);return this.compileAndRun(c,[l,u]).reshape(o)}fill(e,t,n){if("string"===(n=n||M(t))){const r=N(n,b(e));return r.fill(t),ze().makeTensor(r,e,n,this)}{const r=new Do(e,t),o=r.getCustomSetupFunc(t);return this.compileAndRun(r,[],n,o)}}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(e.shape,1,e.dtype)}zerosLike(e){return this.fill(e.shape,"string"===e.dtype?"":0,e.dtype)}linspace(e,t,n){return un(e,t,n)}makeTensorInfo(e,t){const n=this.write(null,e,t);return this.texData.get(n).usage=null,{dataId:n,shape:e,dtype:t}}makeOutput(e,t){const{dataId:n}=this.makeTensorInfo(e,t);return ze().makeTensorFromDataId(n,e,t,this)}unpackTensor(e){const t=new Xa(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new oa(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[sr(e.shape),...ir(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},o=[sr(t),...ir(t)],a=new ca(o,n),s=this.runWebGLProgram(a,[r],e.dtype,null,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:o}=t,a=ur(r);let s;s=n?new Ro(a):new _o(a);return{dtype:o,shape:r,dataId:this.runWebGLProgram(s,[{shape:a,dtype:o,dataId:e}],o,null,!0).dataId}}runWebGLProgram(e,t,n,r,o=!1){const a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===Un.DENSE){const t=Hn(e.outputShape);i.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===b(a.shape))return i.values=O(a.dtype,0),a;const u=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&b(t.shape)<=s().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!cr(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:i,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach(e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${n}_${t}`});const o=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+o,a}(e,l,c),h=this.getAndSaveBinary(d,()=>function(e,t,n,r){const o=t.userCode,a=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),i=a.map(e=>e.shapeInfo),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=Ar(a,u,o,t.packedInputs),c=e.createProgram(l);let d=null;const h=e.getUniformLocation(c,"NAN",!1);1===s().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(c,"INFINITY",!1));const f={};for(let n=0;n<t.variableNames.length;n++){const r=t.variableNames[n],o=!1;f[r]=e.getUniformLocation(c,r,o),f["offset"+r]=e.getUniformLocation(c,"offset"+r,o)}return{program:t,source:l,webGLProgram:c,uniformLocations:f,inShapeInfos:i,outShapeInfo:u,infLoc:d,nanLoc:h}}(this.gpgpu,e,l,c)),f=null!=this.activeTimers;let p;if(f&&(p=this.startTimer()),function(e,t,n,r,o){qo(t.inShapeInfos,n),qo([t.outShapeInfo],[r]);const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a,i[0],i[1]):e.setOutputMatrixTexture(a,i[0],i[1]),e.setProgram(t.webGLProgram),1===s().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const o=t.program.variableNames[r],a=t.uniformLocations[o],s=t.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(b(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=s&&e.gl.uniform1i(s,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,r)}),null!=o&&o(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,l,c,r),u.forEach(e=>this.disposeData(e.dataId)),f&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)})),!s().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===o){const e=this.unpackTensor(a);return this.disposeData(a.dataId),e}return a}compileAndRun(e,t,n,r,o=!1){n=n||t[0].dtype;const a=this.runWebGLProgram(e,t,n,r,o);return ze().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!s().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){var e,t;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(e=()=>{if(!s().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=s().getBool("DEBUG");s().set("DEBUG",!1);const t=this.abs(vt(1e-8)).dataSync()[0];if(s().set("DEBUG",e),t>0)return 32}return 16},ge.tidy(e,t))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:o,texture:a,usage:i,isPacked:u}=t;if(null!=a)return;const l=null!=this.activeTimers;let c;l&&(c=G());let d=t.texShape;if(null==d&&(d=function(e,t=!1){let n=s().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?x(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=S(e);e=t.newShape}let r=b(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=sr(e);let n=2,o=2;return e.length&&([n,o]=ir(e)),r=t*(n/2)*(o/2),$(r).map(e=>2*e)}return $(r)}(n,u),t.texShape=d),null!=o){const e=ur(n);let a,s=d[1],i=d[0];const h=o instanceof Uint8Array;u?([s,i]=Xn(d[0],d[1]),a=new So(e,[i,s],h)):a=new To(e,[i,s],h);const f=this.makeTensorInfo([i,s],r);this.texData.get(f.dataId).usage=h?Vn.PIXELS:Vn.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),s,i,o);const p=!0,m=this.runWebGLProgram(a,[f],r,null,p),g=this.texData.get(m.dataId);t.texture=g.texture,t.texShape=g.texShape,t.isPacked=g.isPacked,t.usage=g.usage,this.disposeData(f.dataId),this.texData.delete(m.dataId),t.values=null,l&&(this.uploadWaitMs+=G()-c)}else{const e=this.acquireTexture(d,i,r,u);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype "+t)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*D(t)}}dn()&&He("webgl",()=>new es,2);const{maxImpl:ts,transposeImpl:ns}=Mn;function rs(e,t,n){const r=n.texData.get(e.dataId);return!r.isPacked||cr(e.shape,t)||null!==r.texture&&cr(r.shape,t)?{dataId:e.dataId,shape:t,dtype:e.dtype}:function(e,t,n){const r=[sr(e.shape),...ir(e.shape)],o={dtype:e.dtype,shape:r,dataId:e.dataId},a=[sr(t),...ir(t)],s=new ca(a,r),i=n.runWebGLProgram(s,[o],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}(e,t,n)}function os(e,t,n,r){const o=b(t),a=rs(e,[b(e.shape)/o,o],r),s=function e(t,n,r,o){const[a,s]=t.shape,i=mt(s),u=new la({windowSize:i,inSize:s,batchSize:a},r),l=o.runWebGLProgram(u,[t],n);return 1===l.shape[1]?l:e(l,n,r,o)}(a,e.dtype,"max",r);return a.dataId!==e.dataId&&r.disposeData(a.dataId),rs(s,n,r)}class as{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=Pr(this.rank),o=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class ss{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Pr(this.rank),o=wr("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=o[e];const s=`vec2(${a.slice(-2).join()})`,i=`++${o[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}const is={kernelName:"Max",backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{reductionIndices:o,keepDims:a}=t,i=n,u=r.shape.length,l=T(o,r.shape);let c=l;const d=De(c,u),h=null!=d,f=i.shouldExecuteOnCPU([r]);let p=r;if(h){if(f){const e=i.texData.get(p.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=r.shape[d[e]];const n=ns(e,r.shape,r.dtype,d,t);p=i.makeTensorInfo(t,r.dtype);i.texData.get(p.dataId).values=n}else p=function(e,t,n){const r=s().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ss(e.shape,t):new as(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}(r,d,i);c=Me(c.length,u)}ke("max",c,u);const[m,g]=Oe(p.shape,c);let x,y=m;if(a&&(y=Ne(m,l)),f){const e=i.texData.get(p.dataId).values,t=ts(e,b(g),y,r.dtype);x=i.makeTensorInfo(y,r.dtype);i.texData.get(x.dataId).values=t}else x=os(p,g,y,i);return h&&i.disposeData(p.dataId),x}},us=s();us.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))),us.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var ls=_t((function(e,a){var s,i=(s="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(s=s||__filename),function(e){function a(){return A.buffer!=H&&J(A.buffer),X}function i(){return A.buffer!=H&&J(A.buffer),j}function u(){return A.buffer!=H&&J(A.buffer),q}function l(){return A.buffer!=H&&J(A.buffer),K}function c(){return A.buffer!=H&&J(A.buffer),Y}var d,h=void 0!==(e=e||{})?e:{},f={};for(d in h)h.hasOwnProperty(d)&&(f[d]=h[d]);var p=!1,m=!1,g=!1,x=!1;p="object"==typeof window,m="function"==typeof importScripts,g="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=!p&&!g&&!m;var y=h.ENVIRONMENT_IS_PTHREAD||!1;y&&(H=h.buffer,ee=h.DYNAMIC_BASE,te=h.DYNAMICTOP_PTR);var v,C,w,b,_="";function R(e){return h.locateFile?h.locateFile(e,_):_+e}if(g){var E;_=m?t.dirname(_)+"/":__dirname+"/",v=function(e,r){return w||(w=n),b||(b=t),e=b.normalize(e),w.readFileSync(e,r?null:"utf8")},C=function(e){var t=v(e,!0);return t.buffer||(t=new Uint8Array(t)),F(t.buffer),t},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof dn))throw e})),process.on("unhandledRejection",Ce),h.inspect=function(){return"[Emscripten Module object]"};try{E=r}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}Worker=E.Worker}else x?("undefined"!=typeof read&&(v=function(e){return read(e)}),C=function(e){var t;return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(F("object"==typeof(t=read(e,"binary"))),t)},"undefined"!=typeof scriptArgs&&scriptArgs,"undefined"!=typeof print&&("undefined"==typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(p||m)&&(m?_=self.location.href:document.currentScript&&(_=document.currentScript.src),s&&(_=s),_=0!==_.indexOf("blob:")?_.substr(0,_.lastIndexOf("/")+1):"",g?(v=function(e,r){return w||(w=n),b||(b=t),e=b.normalize(e),w.readFileSync(e,r?null:"utf8")},C=function(e){var t=v(e,!0);return t.buffer||(t=new Uint8Array(t)),F(t.buffer),t}):(v=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},m&&(C=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)})));g&&"undefined"==typeof performance&&(performance=o.performance);var $,I,A,T=h.print||console.log.bind(console),S=h.printErr||console.warn.bind(console);for(d in f)f.hasOwnProperty(d)&&(h[d]=f[d]);f=null,h.arguments&&h.arguments,h.thisProgram&&h.thisProgram,h.quit&&h.quit,h.wasmBinary&&($=h.wasmBinary),h.noExitRuntime&&(I=h.noExitRuntime),"object"!=typeof WebAssembly&&S("no native wasm support detected");var O,N=new WebAssembly.Table({initial:165,maximum:165,element:"anyfunc"}),k=0,D=!1;function F(e,t){e||Ce("Assertion failed: "+t)}function M(e){var t=h["_"+e];return F(t,"Cannot call unknown function "+e+", make sure it is exported"),t}function B(e,t,n,r,o){var a={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);V(e,t=un(n),n)}return t},array:function(e){var t=un(e.length);return z(e,t),t}},s=M(e),i=[],u=0;if(r)for(var l=0;l<r.length;l++){var c=a[n[l]];c?(0===u&&(u=sn()),i[l]=c(r[l])):i[l]=r[l]}var d=s.apply(null,i);return d=function(e){return"string"===t?W(e):"boolean"===t?Boolean(e):e}(d),0!==u&&ln(u),d}function P(e,t,n,r){var o=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&o&&!r?M(e):function(){return B(e,t,n,arguments)}}function L(e,t,n){for(var r=t+n,o="";!(t>=r);){var a=e[t++];if(!a)return o;if(128&a){var s=63&e[t++];if(192!=(224&a)){var i=63&e[t++];if((a=224==(240&a)?(15&a)<<12|s<<6|i:(7&a)<<18|s<<12|i<<6|63&e[t++])<65536)o+=String.fromCharCode(a);else{var u=a-65536;o+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else o+=String.fromCharCode((31&a)<<6|s)}else o+=String.fromCharCode(a)}return o}function W(e,t){return e?L(i(),e,t):""}function U(e,t,n,r){if(!(r>0))return 0;for(var o=n,a=n+r-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=a)break;t[n++]=i}else if(i<=2047){if(n+1>=a)break;t[n++]=192|i>>6,t[n++]=128|63&i}else if(i<=65535){if(n+2>=a)break;t[n++]=224|i>>12,t[n++]=128|i>>6&63,t[n++]=128|63&i}else{if(n+3>=a)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63,t[n++]=128|i>>6&63,t[n++]=128|63&i}}return t[n]=0,n-o}function V(e,t,n){return U(e,i(),t,n)}function G(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),r<=127?++t:t+=r<=2047?2:r<=65535?3:4}return t}function z(e,t){a().set(e,t)}var H,X,j,q,K,Y,Q=65536;function Z(e,t){return e%t>0&&(e+=t-e%t),e}function J(e){H=e,h.HEAP8=X=new Int8Array(e),h.HEAP16=new Int16Array(e),h.HEAP32=q=new Int32Array(e),h.HEAPU8=j=new Uint8Array(e),h.HEAPU16=new Uint16Array(e),h.HEAPU32=K=new Uint32Array(e),h.HEAPF32=new Float32Array(e),h.HEAPF64=Y=new Float64Array(e)}var ee=5256288,te=12480,ne=h.INITIAL_MEMORY||16777216;if(y)A=h.wasmMemory,H=h.buffer;else if(h.wasmMemory)A=h.wasmMemory;else if(!((A=new WebAssembly.Memory({initial:ne/Q,maximum:2147483648/Q,shared:!0})).buffer instanceof SharedArrayBuffer))throw S("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),g&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");function re(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?h.dynCall_v(n):h.dynCall_vi(n,t.arg):n(void 0===t.arg?null:t.arg)}else t(h)}}A&&(H=A.buffer),ne=H.byteLength,J(H),y||(u()[te>>2]=ee);var oe=[],ae=[],se=[],ie=[];function ue(){if(!y){if(h.preRun)for("function"==typeof h.preRun&&(h.preRun=[h.preRun]);h.preRun.length;)he(h.preRun.shift());re(oe)}}function le(){re(ae)}function ce(){y||re(se)}function de(){if(!y){if(h.postRun)for("function"==typeof h.postRun&&(h.postRun=[h.postRun]);h.postRun.length;)fe(h.postRun.shift());re(ie)}}function he(e){oe.unshift(e)}function fe(e){ie.unshift(e)}var pe=Math.ceil,me=Math.floor,ge=0,xe=null;function ye(e){F(!y,"addRunDependency cannot be used in a pthread worker"),ge++,h.monitorRunDependencies&&h.monitorRunDependencies(ge)}function ve(e){if(ge--,h.monitorRunDependencies&&h.monitorRunDependencies(ge),0==ge&&xe){var t=xe;xe=null,t()}}function Ce(e){throw h.onAbort&&h.onAbort(e),y&&console.error("Pthread aborting at "+(new Error).stack),T(e+=""),S(e),D=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(e)}function we(e,t){return String.prototype.startsWith?e.startsWith(t):0===e.indexOf(t)}h.preloadedImages={},h.preloadedAudios={};var be="data:application/octet-stream;base64,";function _e(e){return we(e,be)}var Re="file://";function Ee(e){return we(e,Re)}var $e="tfjs-backend-wasm-threaded-simd.wasm";function Ie(){try{if($)return new Uint8Array($);if(C)return C($e);throw"both async and sync fetching of the wasm failed"}catch(e){Ce(e)}}function Ae(){return $||!p&&!m||"function"!=typeof fetch||Ee($e)?new Promise((function(e,t){e(Ie())})):fetch($e,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+$e+"'";return e.arrayBuffer()})).catch((function(){return Ie()}))}function Te(){var e={a:Ht};function t(e,t){var n=e.exports;if(h.asm=n,O=t,!y){var r=Ge.unusedWorkers.length;Ge.unusedWorkers.forEach((function(e){Ge.loadWasmModuleToWorker(e,(function(){--r||ve()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return Ae().then((function(t){return WebAssembly.instantiate(t,e)})).then(t,(function(e){S("failed to asynchronously prepare wasm: "+e),Ce(e)}))}if(y||ye(),h.instantiateWasm)try{return h.instantiateWasm(e,t)}catch(e){return S("Module.instantiateWasm callback failed with error: "+e),!1}return function(){if($||"function"!=typeof WebAssembly.instantiateStreaming||_e($e)||Ee($e)||"function"!=typeof fetch)return r(n);fetch($e,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){S("wasm streaming compile failed: "+e),S("falling back to ArrayBuffer instantiation"),r(n)}))}))}(),{}}_e($e)||($e=R($e));var Se={};function Oe(){Ge.initRuntime()}y||ae.push({func:function(){qt()}});var Ne=0,ke=0,De=0;function Fe(e,t,n){Ne=e|=0,De=t|=0,ke=n|=0}h.__register_pthread_ptr=Fe;var Me={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135},Be=13392;function Pe(e,t){if(e<=0||e>a().length||!0&e||t<0)return-28;if(0==t)return 0;t>=2147483647&&(t=1/0);var n=Atomics.load(u(),Be>>2),r=0;if(n==e&&Atomics.compareExchange(u(),Be>>2,n,0)==n&&(r=1,--t<=0))return 1;var o=Atomics.notify(u(),e>>2,t);if(o>=0)return o+r;throw"Atomics.notify returned an unexpected value "+o}function Le(e){if(y)throw"Internal Error! _kill_thread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in _kill_thread!";u()[e+12>>2]=0;var t=Ge.pthreads[e];t.worker.terminate(),Ge.freeThreadData(t),Ge.runningWorkers.splice(Ge.runningWorkers.indexOf(t.worker),1),t.worker.pthread=void 0}function We(e){if(y)throw"Internal Error! _cancel_thread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in _cancel_thread!";Ge.pthreads[e].worker.postMessage({cmd:"cancel"})}function Ue(e){if(y)throw"Internal Error! _cleanup_thread() can only ever be called from main application thread!";if(!e)throw"Internal Error! Null pthread_ptr in _cleanup_thread!";u()[e+12>>2]=0;var t=Ge.pthreads[e];if(t){var n=t.worker;Ge.returnWorkerToPool(n)}}h._emscripten_futex_wake=Pe;var Ve,Ge={MAIN_THREAD_ID:1,mainThreadInfo:{schedPolicy:0,schedPrio:0},unusedWorkers:[],runningWorkers:[],initRuntime:function(){Fe(Ge.mainThreadBlock,!m,1),nn(Ge.mainThreadBlock)},initMainThreadBlock:function(){for(var e=0;e<8;++e)Ge.allocateUnusedWorker();for(Ge.mainThreadBlock=12640,e=0;e<58;++e)l()[Ge.mainThreadBlock/4+e]=0;u()[Ge.mainThreadBlock+12>>2]=Ge.mainThreadBlock;var t=Ge.mainThreadBlock+156;for(u()[t>>2]=t,e=0;e<128;++e)l()[3220+e]=0;Atomics.store(l(),Ge.mainThreadBlock+104>>2,12880),Atomics.store(l(),Ge.mainThreadBlock+40>>2,Ge.mainThreadBlock),Atomics.store(l(),Ge.mainThreadBlock+44>>2,42)},initWorker:function(){},pthreads:{},exitHandlers:null,setThreadStatus:function(){},runExitHandlers:function(){if(null!==Ge.exitHandlers){for(;Ge.exitHandlers.length>0;)Ge.exitHandlers.pop()();Ge.exitHandlers=null}y&&k&&en()},threadExit:function(e){var t=Wt();t&&(Atomics.store(l(),t+4>>2,e),Atomics.store(l(),t+0>>2,1),Atomics.store(l(),t+60>>2,1),Atomics.store(l(),t+64>>2,0),Ge.runExitHandlers(),Pe(t+0,2147483647),Fe(0,0,0),k=0,y&&postMessage({cmd:"exit"}))},threadCancel:function(){Ge.runExitHandlers(),Atomics.store(l(),k+4>>2,-1),Atomics.store(l(),k+0>>2,1),Pe(k+0,2147483647),k=0,Fe(0,0,0),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var e in Ge.pthreads)(r=Ge.pthreads[e])&&r.worker&&Ge.returnWorkerToPool(r.worker);Ge.pthreads={};for(var t=0;t<Ge.unusedWorkers.length;++t)(n=Ge.unusedWorkers[t]).terminate();for(Ge.unusedWorkers=[],t=0;t<Ge.runningWorkers.length;++t){var n,r=(n=Ge.runningWorkers[t]).pthread;Ge.freeThreadData(r),n.terminate()}Ge.runningWorkers=[]},freeThreadData:function(e){if(e){if(e.threadInfoStruct){var t=u()[e.threadInfoStruct+104>>2];u()[e.threadInfoStruct+104>>2]=0,Yt(t),Yt(e.threadInfoStruct)}e.threadInfoStruct=0,e.allocatedOwnStack&&e.stackBase&&Yt(e.stackBase),e.stackBase=0,e.worker&&(e.worker.pthread=null)}},returnWorkerToPool:function(e){delete Ge.pthreads[e.pthread.thread],Ge.unusedWorkers.push(e),Ge.runningWorkers.splice(Ge.runningWorkers.indexOf(e),1),Ge.freeThreadData(e.pthread),e.pthread=void 0},receiveObjectTransfer:function(e){},loadWasmModuleToWorker:function(e,t){e.onmessage=function(n){var r=n.data,o=r.cmd;if(e.pthread&&(Ge.currentProxiedOperationCallerThread=e.pthread.threadInfoStruct),r.targetThread&&r.targetThread!=Wt()){var a=Ge.pthreads[r.targetThread];return a?a.worker.postMessage(n.data,r.transferList):console.error('Internal error! Worker sent a message "'+o+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(Ge.currentProxiedOperationCallerThread=void 0)}"processQueuedMainThreadWork"===o?tn():"spawnThread"===o?Pt(n.data):"cleanupThread"===o?Ue(r.thread):"killThread"===o?Le(r.thread):"cancelThread"===o?We(r.thread):"loaded"===o?(e.loaded=!0,t&&t(e),e.runPthread&&(e.runPthread(),delete e.runPthread)):"print"===o?T("Thread "+r.threadId+": "+r.text):"printErr"===o?S("Thread "+r.threadId+": "+r.text):"alert"===o?alert("Thread "+r.threadId+": "+r.text):"exit"===o?e.pthread&&Atomics.load(l(),e.pthread.thread+68>>2)&&Ge.returnWorkerToPool(e):"cancelDone"===o?Ge.returnWorkerToPool(e):"objectTransfer"===o?Ge.receiveObjectTransfer(n.data):"setimmediate"===n.data.target?e.postMessage(n.data):S("worker sent an unknown command "+o),Ge.currentProxiedOperationCallerThread=void 0},e.onerror=function(e){S("pthread sent an error! "+e.filename+":"+e.lineno+": "+e.message)},g&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("exit",(function(e){console.log("worker exited - TODO: update the worker queue?")}))),e.postMessage({cmd:"load",urlOrBlob:h.mainScriptUrlOrBlob||s,wasmMemory:A,wasmModule:O,DYNAMIC_BASE:ee,DYNAMICTOP_PTR:te})},allocateUnusedWorker:function(){var e=R("tfjs-backend-wasm-threaded-simd.worker.js");Ge.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==Ge.unusedWorkers.length&&(Ge.allocateUnusedWorker(),Ge.loadWasmModuleToWorker(Ge.unusedWorkers[0])),Ge.unusedWorkers.length>0?Ge.unusedWorkers.pop():null},busySpinWait:function(e){for(var t=performance.now()+e;performance.now()<t;);}};function ze(e,t){ln(e)}function He(){return I}function Xe(e,t,n,r){Ce("Assertion failed: "+W(e)+", at: "+[t?W(t):"unknown filename",n,r?W(r):"unknown function"])}function je(e,t){_main(e,t)}function qe(e){return u()[Qt()>>2]=e,e}function Ke(e,t){if(y)return ot(1,1,e,t)}function Ye(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(y)postMessage({targetThread:e,cmd:"processThreadQueue"});else{var n=Ge.pthreads[e],r=n&&n.worker;if(!r)return;r.postMessage({cmd:"processThreadQueue"})}return 1}function Qe(){Ce()}function Ze(e,t){}function Je(e,t,n){if(e<=0||e>a().length||!0&e)return-28;if(m){var r=Atomics.wait(u(),e>>2,t,n);if("timed-out"===r)return-73;if("not-equal"===r)return-6;if("ok"===r)return 0;throw"Atomics.wait returned an unexpected value "+r}if(t!=Atomics.load(u(),e>>2))return-6;var o=performance.now(),s=o+n;Atomics.store(u(),Be>>2,e);for(var i=e;e==i;){if((o=performance.now())>s)return-73;tn(),e=Atomics.load(u(),Be>>2)}return 0}function et(){return 0|De}function tt(){return 0|ke}function nt(e,t,n){i().copyWithin(e,t,t+n)}function rt(){return navigator.hardwareConcurrency}function ot(e,t){for(var n=arguments.length-2,r=sn(),o=un(8*n),a=o>>3,s=0;s<n;s++)c()[a+s]=arguments[2+s];var i=on(e,n,o,t);return ln(r),i}h.establishStackSpace=ze,h.getNoExitRuntime=He,Ve=g?function(){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:y?function(){return performance.now()-h.__performance_now_clock_drift}:"undefined"!=typeof dateNow?dateNow:function(){return performance.now()};var at=[];function st(e,t){st.array||(st.array=[]);var n,r=st.array;for(r.length=0;n=i()[e++];)100===n||102===n?(t=t+7&-8,r.push(c()[t>>3]),t+=8):(t=t+3&-4,r.push(u()[t>>2]),t+=4);return r}function it(e,t,n){at.length=t;for(var r=n>>3,o=0;o<t;o++)at[o]=c()[r+o];var a=e<0,s=a?Se[-e-1]:zt[e];if(a){var i=st(at[1],at[2]);return s.apply(null,i)}return s.apply(null,at)}function ut(){return i().length}function lt(e){try{return A.grow(e-H.byteLength+65535>>>16),J(A.buffer),1}catch(e){}}function ct(e){e>>>=0;var t=ut();if(e<=t)return!1;if(e>2147483648)return!1;for(var n=1;n<=4;n*=2){var r=t*(1+.2/n);if(r=Math.min(r,e+100663296),lt(Math.min(2147483648,Z(Math.max(16777216,e,r),65536))))return!0}return!1}var dt={keyEvent:0,mouseEvent:0,wheelEvent:0,uiEvent:0,focusEvent:0,deviceOrientationEvent:0,deviceMotionEvent:0,fullscreenChangeEvent:0,pointerlockChangeEvent:0,visibilityChangeEvent:0,touchEvent:0,previousFullscreenElement:null,previousScreenX:null,previousScreenY:null,removeEventListenersRegistered:!1,removeAllEventListeners:function(){for(var e=dt.eventHandlers.length-1;e>=0;--e)dt._removeHandler(e);dt.eventHandlers=[],dt.deferredCalls=[]},registerRemoveEventListeners:function(){dt.removeEventListenersRegistered||(dt.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(e,t,n){function r(e,t){if(e.length!=t.length)return!1;for(var n in e)if(e[n]!=t[n])return!1;return!0}for(var o in dt.deferredCalls){var a=dt.deferredCalls[o];if(a.targetFunction==e&&r(a.argsList,n))return}dt.deferredCalls.push({targetFunction:e,precedence:t,argsList:n}),dt.deferredCalls.sort((function(e,t){return e.precedence<t.precedence}))},removeDeferredCalls:function(e){for(var t=0;t<dt.deferredCalls.length;++t)dt.deferredCalls[t].targetFunction==e&&(dt.deferredCalls.splice(t,1),--t)},canPerformEventHandlerRequests:function(){return dt.inEventHandler&&dt.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(dt.canPerformEventHandlerRequests())for(var e=0;e<dt.deferredCalls.length;++e){var t=dt.deferredCalls[e];dt.deferredCalls.splice(e,1),--e,t.targetFunction.apply(null,t.argsList)}},inEventHandler:0,currentEventHandler:null,eventHandlers:[],removeAllHandlersOnTarget:function(e,t){for(var n=0;n<dt.eventHandlers.length;++n)dt.eventHandlers[n].target!=e||t&&t!=dt.eventHandlers[n].eventTypeString||dt._removeHandler(n--)},_removeHandler:function(e){var t=dt.eventHandlers[e];t.target.removeEventListener(t.eventTypeString,t.eventListenerFunc,t.useCapture),dt.eventHandlers.splice(e,1)},registerOrRemoveHandler:function(e){var t=function(t){++dt.inEventHandler,dt.currentEventHandler=e,dt.runDeferredCalls(),e.handlerFunc(t),dt.runDeferredCalls(),--dt.inEventHandler};if(e.callbackfunc)e.eventListenerFunc=t,e.target.addEventListener(e.eventTypeString,t,e.useCapture),dt.eventHandlers.push(e),dt.registerRemoveEventListeners();else for(var n=0;n<dt.eventHandlers.length;++n)dt.eventHandlers[n].target==e.target&&dt.eventHandlers[n].eventTypeString==e.eventTypeString&&dt._removeHandler(n--)},queueEventHandlerOnThread_iiii:function(e,t,n,r,o){var a=sn(),s=un(12);u()[s>>2]=n,u()[s+4>>2]=r,u()[s+8>>2]=o,an(e,637534208,t,r,s),ln(a)},getTargetThreadForEventCallback:function(e){switch(e){case 1:return 0;case 2:return Ge.currentProxiedOperationCallerThread;default:return e}},getNodeNameForTarget:function(e){return e?e==window?"#window":e==screen?"#screen":e&&e.nodeName?e.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function ht(e){var t=G(e)+1,n=Kt(t);return V(e,n,t),n}function ft(e,t,n,r){var o=sn(),a=un(12),s=0;t&&(s=ht(t)),u()[a>>2]=s,u()[a+4>>2]=n,u()[a+8>>2]=r,an(e,657457152,0,s,a),ln(o)}function pt(e,t,n,r){ft(e,t=t?W(t):"",n,r)}function mt(e){return e>2?W(e):e}var gt=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function xt(e){return e=mt(e),gt[e]||("undefined"!=typeof document?document.querySelector(e):void 0)}function yt(e){return xt(e)}function vt(e,t,n){var r=yt(e);if(!r)return-4;if(r.canvasSharedPtr&&(u()[r.canvasSharedPtr>>2]=t,u()[r.canvasSharedPtr+4>>2]=n),!r.offscreenCanvas&&r.controlTransferredOffscreen)return r.canvasSharedPtr?(pt(u()[r.canvasSharedPtr+8>>2],e,t,n),1):-4;r.offscreenCanvas&&(r=r.offscreenCanvas);var o=!1;if(r.GLctxObject&&r.GLctxObject.GLctx){var a=r.GLctxObject.GLctx.getParameter(2978);o=0===a[0]&&0===a[1]&&a[2]===r.width&&a[3]===r.height}return r.width=t,r.height=n,o&&r.GLctxObject.GLctx.viewport(0,0,t,n),0}function Ct(e,t,n){return y?ot(2,1,e,t,n):vt(e,t,n)}function wt(e,t,n){return yt(e)?vt(e,t,n):Ct(e,t,n)}function bt(e){}function _t(e,t){}function Rt(e){var t=e.getExtension("ANGLE_instanced_arrays");if(t)return e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,r,o){t.drawArraysInstancedANGLE(e,n,r,o)},e.drawElementsInstanced=function(e,n,r,o,a){t.drawElementsInstancedANGLE(e,n,r,o,a)},1}function Et(e){var t=e.getExtension("OES_vertex_array_object");if(t)return e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)},1}function $t(e){var t=e.getExtension("WEBGL_draw_buffers");if(t)return e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)},1}var It={counter:1,lastError:0,buffers:[],mappedBuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},currentContext:null,offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,init:function(){for(var e=new Float32Array(It.MINI_TEMP_BUFFER_SIZE),t=0;t<It.MINI_TEMP_BUFFER_SIZE;t++)It.miniTempBufferFloatViews[t]=e.subarray(0,t+1);var n=new Int32Array(It.MINI_TEMP_BUFFER_SIZE);for(t=0;t<It.MINI_TEMP_BUFFER_SIZE;t++)It.miniTempBufferIntViews[t]=n.subarray(0,t+1)},recordError:function(e){It.lastError||(It.lastError=e)},getNewId:function(e){for(var t=It.counter++,n=e.length;n<t;n++)e[n]=null;return t},MINI_TEMP_BUFFER_SIZE:256,miniTempBufferFloatViews:[0],miniTempBufferIntViews:[0],getSource:function(e,t,n,r){for(var o="",a=0;a<t;++a){var s=r?u()[r+4*a>>2]:-1;o+=W(u()[n+4*a>>2],s<0?void 0:s)}return o},createContext:function(e,t){var n=e.getContext("webgl",t);return n?It.registerContext(n,t):0},registerContext:function(e,t){var n=Kt(8);u()[n+4>>2]=Wt();var r={handle:n,attributes:t,version:t.majorVersion,GLctx:e};return e.canvas&&(e.canvas.GLctxObject=r),It.contexts[n]=r,(void 0===t.enableExtensionsByDefault||t.enableExtensionsByDefault)&&It.initExtensions(r),n},makeContextCurrent:function(e){return It.currentContext=It.contexts[e],h.ctx=Ot=It.currentContext&&It.currentContext.GLctx,!(e&&!Ot)},getContext:function(e){return It.contexts[e]},deleteContext:function(e){It.currentContext===It.contexts[e]&&(It.currentContext=null),"object"==typeof dt&&dt.removeAllHandlersOnTarget(It.contexts[e].GLctx.canvas),It.contexts[e]&&It.contexts[e].GLctx.canvas&&(It.contexts[e].GLctx.canvas.GLctxObject=void 0),Yt(It.contexts[e].handle),It.contexts[e]=null},initExtensions:function(e){if(e||(e=It.currentContext),!e.initExtensionsDone){e.initExtensionsDone=!0;var t=e.GLctx;Rt(t),Et(t),$t(t),t.disjointTimerQueryExt=t.getExtension("EXT_disjoint_timer_query");var n=["OES_texture_float","OES_texture_half_float","OES_standard_derivatives","OES_vertex_array_object","WEBGL_compressed_texture_s3tc","WEBGL_depth_texture","OES_element_index_uint","EXT_texture_filter_anisotropic","EXT_frag_depth","WEBGL_draw_buffers","ANGLE_instanced_arrays","OES_texture_float_linear","OES_texture_half_float_linear","EXT_blend_minmax","EXT_shader_texture_lod","EXT_texture_norm16","WEBGL_compressed_texture_pvrtc","EXT_color_buffer_half_float","WEBGL_color_buffer_float","EXT_sRGB","WEBGL_compressed_texture_etc1","EXT_disjoint_timer_query","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_astc","EXT_color_buffer_float","WEBGL_compressed_texture_s3tc_srgb","EXT_disjoint_timer_query_webgl2","WEBKIT_WEBGL_compressed_texture_pvrtc"];(t.getSupportedExtensions()||[]).forEach((function(e){-1!=n.indexOf(e)&&t.getExtension(e)}))}},populateUniformTable:function(e){for(var t=It.programs[e],n=It.programInfos[e]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},r=n.uniforms,o=Ot.getProgramParameter(t,35718),a=0;a<o;++a){var s=Ot.getActiveUniform(t,a),i=s.name;n.maxUniformLength=Math.max(n.maxUniformLength,i.length+1),"]"==i.slice(-1)&&(i=i.slice(0,i.lastIndexOf("[")));var u=Ot.getUniformLocation(t,i);if(u){var l=It.getNewId(It.uniforms);r[i]=[s.size,l],It.uniforms[l]=u;for(var c=1;c<s.size;++c){var d=i+"["+c+"]";u=Ot.getUniformLocation(t,d),l=It.getNewId(It.uniforms),It.uniforms[l]=u}}}}},At=["default","low-power","high-performance"];function Tt(e,t){var n={},r=t>>2;n.alpha=!!u()[r+0],n.depth=!!u()[r+1],n.stencil=!!u()[r+2],n.antialias=!!u()[r+3],n.premultipliedAlpha=!!u()[r+4],n.preserveDrawingBuffer=!!u()[r+5];var o=u()[r+6];n.powerPreference=At[o],n.failIfMajorPerformanceCaveat=!!u()[r+7],n.majorVersion=u()[r+8],n.minorVersion=u()[r+9],n.enableExtensionsByDefault=u()[r+10],n.explicitSwapControl=u()[r+11],n.proxyContextToMainThread=u()[r+12],n.renderViaOffscreenBackBuffer=u()[r+13];var a=yt(e);return a?n.explicitSwapControl?-1:It.createContext(a,n):-4}function St(e,t){return Tt(e,t)}var Ot,Nt={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=Nt.buffers[e];0===t||10===t?((1===e?T:S)(L(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return Nt.varargs+=4,u()[Nt.varargs-4>>2]},getStr:function(e){return W(e)},get64:function(e,t){return e}};function kt(e){return y?ot(3,1,e):0}function Dt(e,t,n,r,o){if(y)return ot(4,1,e,t,n,r,o)}function Ft(e,t,n,r){if(y)return ot(5,1,e,t,n,r);for(var o=0,a=0;a<n;a++){for(var s=u()[t+8*a>>2],l=u()[t+(8*a+4)>>2],c=0;c<l;c++)Nt.printChar(e,i()[s+c]);o+=l}return u()[r>>2]=o,0}function Mt(e){var t=Ge.exitHandlers.pop();e&&t()}function Bt(e,t){null===Ge.exitHandlers&&(Ge.exitHandlers=[]),Ge.exitHandlers.push((function(){cn(e,t)}))}function Pt(e){if(y)throw"Internal Error! _spawn_thread() can only ever be called from main application thread!";var t=Ge.getNewWorker();if(void 0!==t.pthread)throw"Internal error!";if(!e.pthread_ptr)throw"Internal error, no pthread ptr!";Ge.runningWorkers.push(t);for(var n=Kt(512),r=0;r<128;++r)u()[n+4*r>>2]=0;var o=e.stackBase+e.stackSize,a=Ge.pthreads[e.pthread_ptr]={worker:t,stackBase:e.stackBase,stackSize:e.stackSize,allocatedOwnStack:e.allocatedOwnStack,thread:e.pthread_ptr,threadInfoStruct:e.pthread_ptr},s=a.threadInfoStruct>>2;Atomics.store(l(),s+0,0),Atomics.store(l(),s+1,0),Atomics.store(l(),s+2,0),Atomics.store(l(),s+17,e.detached),Atomics.store(l(),s+26,n),Atomics.store(l(),s+12,0),Atomics.store(l(),s+10,a.threadInfoStruct),Atomics.store(l(),s+11,42),Atomics.store(l(),s+27,e.stackSize),Atomics.store(l(),s+21,e.stackSize),Atomics.store(l(),s+20,o),Atomics.store(l(),s+29,o),Atomics.store(l(),s+30,e.detached),Atomics.store(l(),s+32,e.schedPolicy),Atomics.store(l(),s+33,e.schedPrio);var i=Zt()+40;Atomics.store(l(),s+44,i),t.pthread=a;var c={cmd:"run",start_routine:e.startRoutine,arg:e.arg,threadInfoStruct:e.pthread_ptr,selfThreadId:e.pthread_ptr,parentThreadId:e.parent_pthread_ptr,stackBase:e.stackBase,stackSize:e.stackSize};t.runPthread=function(){c.time=performance.now(),t.postMessage(c,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread)}function Lt(e,t,n){if(!t&&!n)return Me.EINVAL;if(!e)return S("pthread_getschedparam called with a null thread pointer!"),Me.ESRCH;if(u()[e+12>>2]!==e)return S("pthread_getschedparam attempted on thread "+e+", which does not point to a valid thread, or does not exist anymore!"),Me.ESRCH;var r=Atomics.load(l(),e+108+20>>2),o=Atomics.load(l(),e+108+24>>2);return t&&(u()[t>>2]=r),n&&(u()[n>>2]=o),0}function Wt(){return 0|Ne}function Ut(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return S("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!e)return S("pthread_create called with a null thread pointer!"),28;var o=[];if(y&&0===o.length)return rn(687865856,e,t,n,r);var a=0,s=0,i=0,c=0,d=0;if(t)if(a=u()[t>>2],a+=81920,s=u()[t+8>>2],i=0!==u()[t+12>>2],0===u()[t+16>>2]){var h=u()[t+20>>2],f=u()[t+24>>2];Lt(Ge.currentProxiedOperationCallerThread?Ge.currentProxiedOperationCallerThread:Wt(),t+20,t+24),c=u()[t+20>>2],d=u()[t+24>>2],u()[t+20>>2]=h,u()[t+24>>2]=f}else c=u()[t+20>>2],d=u()[t+24>>2];else a=2097152;var p=0==s;p?s=Jt(16,a):F((s-=a)>0);for(var m=Kt(232),g=0;g<58;++g)l()[(m>>2)+g]=0;u()[e>>2]=m,u()[m+12>>2]=m;var x=m+156;u()[x>>2]=x;var v={stackBase:s,stackSize:a,allocatedOwnStack:p,schedPolicy:c,schedPrio:d,detached:i,startRoutine:n,pthread_ptr:m,parent_pthread_ptr:Wt(),arg:r,transferList:o};return y?(v.cmd="spawnThread",postMessage(v,o)):Pt(v),0}function Vt(e){return(e=+e)>=0?+me(e+.5):+pe(e-.5)}function Gt(e){if(y)return ot(6,1,e);switch(e){case 30:return 16384;case 85:return 131072;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:case 79:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return"object"==typeof navigator&&navigator.hardwareConcurrency||1}return qe(28),-1}h._pthread_self=Wt,y?Ge.initWorker():Ge.initMainThreadBlock(),It.init();var zt=[null,Ke,Ct,kt,Dt,Ft,Gt],Ht={e:Xe,r:je,w:Ye,a:Qe,l:Ze,d:Je,c:Pe,h:Ve,g:et,x:tt,q:nt,B:rt,t:it,A:ct,u:wt,k:bt,s:_t,v:St,m:kt,o:Dt,i:Ft,p:Oe,memory:A||h.wasmMemory,y:Mt,z:Bt,j:Ut,b:Wt,f:Vt,n:Gt,table:N},Xt=Te();h.asm=Xt;var jt,qt=h.___wasm_call_ctors=function(){return(qt=h.___wasm_call_ctors=h.asm.C).apply(null,arguments)},Kt=(h._init=function(){return(h._init=h.asm.D).apply(null,arguments)},h._register_tensor=function(){return(h._register_tensor=h.asm.E).apply(null,arguments)},h._dispose_data=function(){return(h._dispose_data=h.asm.F).apply(null,arguments)},h._dispose=function(){return(h._dispose=h.asm.G).apply(null,arguments)},h._Abs=function(){return(h._Abs=h.asm.H).apply(null,arguments)},h._Add=function(){return(h._Add=h.asm.I).apply(null,arguments)},h._AddN=function(){return(h._AddN=h.asm.J).apply(null,arguments)},h._ArgMax=function(){return(h._ArgMax=h.asm.K).apply(null,arguments)},h._AvgPool=function(){return(h._AvgPool=h.asm.L).apply(null,arguments)},h._BatchMatMul=function(){return(h._BatchMatMul=h.asm.M).apply(null,arguments)},h._ClipByValue=function(){return(h._ClipByValue=h.asm.N).apply(null,arguments)},h._Conv2D=function(){return(h._Conv2D=h.asm.O).apply(null,arguments)},h._Conv2DBackpropInput=function(){return(h._Conv2DBackpropInput=h.asm.P).apply(null,arguments)},h._Cos=function(){return(h._Cos=h.asm.Q).apply(null,arguments)},h._CropAndResize=function(){return(h._CropAndResize=h.asm.R).apply(null,arguments)},h._DepthwiseConv2dNative=function(){return(h._DepthwiseConv2dNative=h.asm.S).apply(null,arguments)},h._Div=function(){return(h._Div=h.asm.T).apply(null,arguments)},h._Equal=function(){return(h._Equal=h.asm.U).apply(null,arguments)},h._Exp=function(){return(h._Exp=h.asm.V).apply(null,arguments)},h._FloorDiv=function(){return(h._FloorDiv=h.asm.W).apply(null,arguments)},h._FusedBatchNorm=function(){return(h._FusedBatchNorm=h.asm.X).apply(null,arguments)},h._FusedConv2D=function(){return(h._FusedConv2D=h.asm.Y).apply(null,arguments)},h._FusedDepthwiseConv2D=function(){return(h._FusedDepthwiseConv2D=h.asm.Z).apply(null,arguments)},h._Gather=function(){return(h._Gather=h.asm._).apply(null,arguments)},h._GatherNd=function(){return(h._GatherNd=h.asm.$).apply(null,arguments)},h._Greater=function(){return(h._Greater=h.asm.aa).apply(null,arguments)},h._GreaterEqual=function(){return(h._GreaterEqual=h.asm.ba).apply(null,arguments)},h._Less=function(){return(h._Less=h.asm.ca).apply(null,arguments)},h._LessEqual=function(){return(h._LessEqual=h.asm.da).apply(null,arguments)},h._Log=function(){return(h._Log=h.asm.ea).apply(null,arguments)},h._LogicalAnd=function(){return(h._LogicalAnd=h.asm.fa).apply(null,arguments)},h._Max=function(){return(h._Max=h.asm.ga).apply(null,arguments)},h._MaxPool=function(){return(h._MaxPool=h.asm.ha).apply(null,arguments)},h._Maximum=function(){return(h._Maximum=h.asm.ia).apply(null,arguments)},h._Min=function(){return(h._Min=h.asm.ja).apply(null,arguments)},h._Minimum=function(){return(h._Minimum=h.asm.ka).apply(null,arguments)},h._Multiply=function(){return(h._Multiply=h.asm.la).apply(null,arguments)},h._Negate=function(){return(h._Negate=h.asm.ma).apply(null,arguments)},h._NonMaxSuppressionV3=function(){return(h._NonMaxSuppressionV3=h.asm.na).apply(null,arguments)},h._NonMaxSuppressionV4=function(){return(h._NonMaxSuppressionV4=h.asm.oa).apply(null,arguments)},h._NonMaxSuppressionV5=function(){return(h._NonMaxSuppressionV5=h.asm.pa).apply(null,arguments)},h._NotEqual=function(){return(h._NotEqual=h.asm.qa).apply(null,arguments)},h._OneHot=function(){return(h._OneHot=h.asm.ra).apply(null,arguments)},h._PadV2=function(){return(h._PadV2=h.asm.sa).apply(null,arguments)},h._Pow=function(){return(h._Pow=h.asm.ta).apply(null,arguments)},h._Prelu=function(){return(h._Prelu=h.asm.ua).apply(null,arguments)},h._Relu=function(){return(h._Relu=h.asm.va).apply(null,arguments)},h._Relu6=function(){return(h._Relu6=h.asm.wa).apply(null,arguments)},h._ResizeBilinear=function(){return(h._ResizeBilinear=h.asm.xa).apply(null,arguments)},h._Reverse=function(){return(h._Reverse=h.asm.ya).apply(null,arguments)},h._RotateWithOffset=function(){return(h._RotateWithOffset=h.asm.za).apply(null,arguments)},h._Rsqrt=function(){return(h._Rsqrt=h.asm.Aa).apply(null,arguments)},h._ScatterNd=function(){return(h._ScatterNd=h.asm.Ba).apply(null,arguments)},h._SelectV2=function(){return(h._SelectV2=h.asm.Ca).apply(null,arguments)},h._Sigmoid=function(){return(h._Sigmoid=h.asm.Da).apply(null,arguments)},h._Sin=function(){return(h._Sin=h.asm.Ea).apply(null,arguments)},h._Softmax=function(){return(h._Softmax=h.asm.Fa).apply(null,arguments)},h._Sqrt=function(){return(h._Sqrt=h.asm.Ga).apply(null,arguments)},h._Square=function(){return(h._Square=h.asm.Ha).apply(null,arguments)},h._Sub=function(){return(h._Sub=h.asm.Ia).apply(null,arguments)},h._Sum=function(){return(h._Sum=h.asm.Ja).apply(null,arguments)},h._Tanh=function(){return(h._Tanh=h.asm.Ka).apply(null,arguments)},h._Tile=function(){return(h._Tile=h.asm.La).apply(null,arguments)},h._Transpose=function(){return(h._Transpose=h.asm.Ma).apply(null,arguments)},h.__FusedMatMul=function(){return(h.__FusedMatMul=h.asm.Na).apply(null,arguments)},h._malloc=function(){return(Kt=h._malloc=h.asm.Oa).apply(null,arguments)}),Yt=h._free=function(){return(Yt=h._free=h.asm.Pa).apply(null,arguments)},Qt=(h.___em_js__initPthreadsJS=function(){return(h.___em_js__initPthreadsJS=h.asm.Qa).apply(null,arguments)},h.___errno_location=function(){return(Qt=h.___errno_location=h.asm.Ra).apply(null,arguments)}),Zt=h._emscripten_get_global_libc=function(){return(Zt=h._emscripten_get_global_libc=h.asm.Sa).apply(null,arguments)},Jt=h._memalign=function(){return(Jt=h._memalign=h.asm.Ta).apply(null,arguments)},en=h.___pthread_tsd_run_dtors=function(){return(en=h.___pthread_tsd_run_dtors=h.asm.Ua).apply(null,arguments)},tn=h._emscripten_main_thread_process_queued_calls=function(){return(tn=h._emscripten_main_thread_process_queued_calls=h.asm.Va).apply(null,arguments)},nn=(h._emscripten_current_thread_process_queued_calls=function(){return(h._emscripten_current_thread_process_queued_calls=h.asm.Wa).apply(null,arguments)},h._emscripten_register_main_browser_thread_id=function(){return(nn=h._emscripten_register_main_browser_thread_id=h.asm.Xa).apply(null,arguments)}),rn=(h._emscripten_main_browser_thread_id=function(){return(h._emscripten_main_browser_thread_id=h.asm.Ya).apply(null,arguments)},h._emscripten_async_run_in_main_thread=function(){return(h._emscripten_async_run_in_main_thread=h.asm.Za).apply(null,arguments)},h._emscripten_sync_run_in_main_thread=function(){return(h._emscripten_sync_run_in_main_thread=h.asm._a).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_0=function(){return(h._emscripten_sync_run_in_main_thread_0=h.asm.$a).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_1=function(){return(h._emscripten_sync_run_in_main_thread_1=h.asm.ab).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_2=function(){return(h._emscripten_sync_run_in_main_thread_2=h.asm.bb).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_xprintf_varargs=function(){return(h._emscripten_sync_run_in_main_thread_xprintf_varargs=h.asm.cb).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_3=function(){return(h._emscripten_sync_run_in_main_thread_3=h.asm.db).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_4=function(){return(rn=h._emscripten_sync_run_in_main_thread_4=h.asm.eb).apply(null,arguments)}),on=(h._emscripten_sync_run_in_main_thread_5=function(){return(h._emscripten_sync_run_in_main_thread_5=h.asm.fb).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_6=function(){return(h._emscripten_sync_run_in_main_thread_6=h.asm.gb).apply(null,arguments)},h._emscripten_sync_run_in_main_thread_7=function(){return(h._emscripten_sync_run_in_main_thread_7=h.asm.hb).apply(null,arguments)},h._emscripten_run_in_main_runtime_thread_js=function(){return(on=h._emscripten_run_in_main_runtime_thread_js=h.asm.ib).apply(null,arguments)}),an=h._emscripten_async_queue_on_thread_=function(){return(an=h._emscripten_async_queue_on_thread_=h.asm.jb).apply(null,arguments)},sn=(h._emscripten_tls_init=function(){return(h._emscripten_tls_init=h.asm.kb).apply(null,arguments)},h.stackSave=function(){return(sn=h.stackSave=h.asm.lb).apply(null,arguments)}),un=h.stackAlloc=function(){return(un=h.stackAlloc=h.asm.mb).apply(null,arguments)},ln=h.stackRestore=function(){return(ln=h.stackRestore=h.asm.nb).apply(null,arguments)},cn=h.dynCall_vi=function(){return(cn=h.dynCall_vi=h.asm.ob).apply(null,arguments)};function dn(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function hn(e){function t(){jt||(jt=!0,h.calledRun=!0,D||(le(),ce(),h.onRuntimeInitialized&&h.onRuntimeInitialized(),de()))}ge>0||(ue(),ge>0||(h.setStatus?(h.setStatus("Running..."),setTimeout((function(){setTimeout((function(){h.setStatus("")}),1),t()}),1)):t()))}if(h.dynCall_v=function(){return(h.dynCall_v=h.asm.pb).apply(null,arguments)},h.dynCall_ii=function(){return(h.dynCall_ii=h.asm.qb).apply(null,arguments)},h.asm=Xt,h.cwrap=P,h.PThread=Ge,h.PThread=Ge,h._pthread_self=Wt,h.wasmMemory=A,h.ExitStatus=dn,h.then=function(e){if(jt)e(h);else{var t=h.onRuntimeInitialized;h.onRuntimeInitialized=function(){t&&t(),e(h)}}return h},xe=function e(){jt||hn(),jt||(xe=e)},h.run=hn,h.preInit)for("function"==typeof h.preInit&&(h.preInit=[h.preInit]);h.preInit.length>0;)h.preInit.pop()();return y||(I=!0),y||hn(),e});e.exports=i}));var cs=_t((function(e,r){var o,a=(o="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(o=o||__filename),function(e){var r,a=void 0!==(e=e||{})?e:{},s={};for(r in a)a.hasOwnProperty(r)&&(s[r]=a[r]);var i=function(e,t){throw t},u=!1,l=!1,c=!1,d=!1;u="object"==typeof window,l="function"==typeof importScripts,c="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,d=!u&&!c&&!l;var h,f,p,m,g="";function x(e){return a.locateFile?a.locateFile(e,g):g+e}c?(g=l?t.dirname(g)+"/":__dirname+"/",h=function(e,r){return p||(p=n),m||(m=t),e=m.normalize(e),p.readFileSync(e,r?null:"utf8")},f=function(e){var t=h(e,!0);return t.buffer||(t=new Uint8Array(t)),R(t.buffer),t},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof Ee))throw e})),process.on("unhandledRejection",te),i=function(e){process.exit(e)},a.inspect=function(){return"[Emscripten Module object]"}):d?("undefined"!=typeof read&&(h=function(e){return read(e)}),f=function(e){var t;return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(R("object"==typeof(t=read(e,"binary"))),t)},"undefined"!=typeof scriptArgs&&scriptArgs,"function"==typeof quit&&(i=function(e){quit(e)}),"undefined"!=typeof print&&("undefined"==typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(u||l)&&(l?g=self.location.href:document.currentScript&&(g=document.currentScript.src),o&&(g=o),g=0!==g.indexOf("blob:")?g.substr(0,g.lastIndexOf("/")+1):"",h=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},l&&(f=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}));var y,v,C,w=a.print||console.log.bind(console),b=a.printErr||console.warn.bind(console);for(r in s)s.hasOwnProperty(r)&&(a[r]=s[r]);s=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&(i=a.quit),a.wasmBinary&&(y=a.wasmBinary),a.noExitRuntime&&(v=a.noExitRuntime),"object"!=typeof WebAssembly&&b("no native wasm support detected"),new WebAssembly.Table({initial:147,maximum:147,element:"anyfunc"});var _=!1;function R(e,t){e||te("Assertion failed: "+t)}function E(e){var t=a["_"+e];return R(t,"Cannot call unknown function "+e+", make sure it is exported"),t}function $(e,t,n,r,o){var a={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);F(e,t=_e(n),n)}return t},array:function(e){var t=_e(e.length);return M(e,t),t}},s=E(e),i=[],u=0;if(r)for(var l=0;l<r.length;l++){var c=a[n[l]];c?(0===u&&(u=be()),i[l]=c(r[l])):i[l]=r[l]}var d=s.apply(null,i);return d=function(e){return"string"===t?k(e):"boolean"===t?Boolean(e):e}(d),0!==u&&Re(u),d}function I(e,t,n,r){var o=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&o&&!r?E(e):function(){return $(e,t,n,arguments)}}var A,T,S,O="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function N(e,t,n){for(var r=t+n,o=t;e[o]&&!(o>=r);)++o;if(o-t>16&&e.subarray&&O)return O.decode(e.subarray(t,o));for(var a="";t<o;){var s=e[t++];if(128&s){var i=63&e[t++];if(192!=(224&s)){var u=63&e[t++];if((s=224==(240&s)?(15&s)<<12|i<<6|u:(7&s)<<18|i<<12|u<<6|63&e[t++])<65536)a+=String.fromCharCode(s);else{var l=s-65536;a+=String.fromCharCode(55296|l>>10,56320|1023&l)}}else a+=String.fromCharCode((31&s)<<6|i)}else a+=String.fromCharCode(s)}return a}function k(e,t){return e?N(T,e,t):""}function D(e,t,n,r){if(!(r>0))return 0;for(var o=n,a=n+r-1,s=0;s<e.length;++s){var i=e.charCodeAt(s);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),i<=127){if(n>=a)break;t[n++]=i}else if(i<=2047){if(n+1>=a)break;t[n++]=192|i>>6,t[n++]=128|63&i}else if(i<=65535){if(n+2>=a)break;t[n++]=224|i>>12,t[n++]=128|i>>6&63,t[n++]=128|63&i}else{if(n+3>=a)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63,t[n++]=128|i>>6&63,t[n++]=128|63&i}}return t[n]=0,n-o}function F(e,t,n){return D(e,T,t,n)}function M(e,t){A.set(e,t)}function B(e){a.HEAP8=A=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=S=new Int32Array(e),a.HEAPU8=T=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}function P(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?a.dynCall_v(n):a.dynCall_vi(n,t.arg):n(void 0===t.arg?null:t.arg)}else t(a)}}a.INITIAL_MEMORY;var L=[],W=[],U=[],V=[];function G(){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)j(a.preRun.shift());P(L)}function z(){P(W)}function H(){P(U)}function X(){if(a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;)q(a.postRun.shift());P(V)}function j(e){L.unshift(e)}function q(e){V.unshift(e)}var K=Math.ceil,Y=Math.floor,Q=0,Z=null;function J(e){Q++,a.monitorRunDependencies&&a.monitorRunDependencies(Q)}function ee(e){if(Q--,a.monitorRunDependencies&&a.monitorRunDependencies(Q),0==Q&&Z){var t=Z;Z=null,t()}}function te(e){throw a.onAbort&&a.onAbort(e),w(e+=""),b(e),_=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(e)}function ne(e,t){return String.prototype.startsWith?e.startsWith(t):0===e.indexOf(t)}a.preloadedImages={},a.preloadedAudios={};var re="data:application/octet-stream;base64,";function oe(e){return ne(e,re)}var ae="file://";function se(e){return ne(e,ae)}var ie="tfjs-backend-wasm.wasm";function ue(){try{if(y)return new Uint8Array(y);if(f)return f(ie);throw"both async and sync fetching of the wasm failed"}catch(e){te(e)}}function le(){return y||!u&&!l||"function"!=typeof fetch||se(ie)?new Promise((function(e,t){e(ue())})):fetch(ie,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ie+"'";return e.arrayBuffer()})).catch((function(){return ue()}))}function ce(){var e={env:ve,wasi_snapshot_preview1:ve};function t(e,t){var n=e.exports;a.asm=n,B((C=n.memory).buffer),ee()}function n(e){t(e.instance)}function r(t){return le().then((function(t){return WebAssembly.instantiate(t,e)})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),te(e)}))}if(J(),a.instantiateWasm)try{return a.instantiateWasm(e,t)}catch(e){return b("Module.instantiateWasm callback failed with error: "+e),!1}return function(){if(y||"function"!=typeof WebAssembly.instantiateStreaming||oe(ie)||se(ie)||"function"!=typeof fetch)return r(n);fetch(ie,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),r(n)}))}))}(),{}}function de(e){B(C.buffer)}oe(ie)||(ie=x(ie)),W.push();var he={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=he.buffers[e];0===t||10===t?((1===e?w:b)(N(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return he.varargs+=4,S[he.varargs-4>>2]},getStr:function(e){return k(e)},get64:function(e,t){return e}};function fe(e){return 0}function pe(e,t,n,r,o){}function me(e,t,n,r){for(var o=0,a=0;a<n;a++){for(var s=S[t+8*a>>2],i=S[t+(8*a+4)>>2],u=0;u<i;u++)he.printChar(e,T[s+u]);o+=i}return S[r>>2]=o,0}function ge(e){Ae(e)}function xe(e){ge(e)}function ye(e){return(e=+e)>=0?+Y(e+.5):+K(e-.5)}var ve={emscripten_notify_memory_growth:de,fd_close:fe,fd_seek:pe,fd_write:me,proc_exit:xe,roundf:ye},Ce=ce();a.asm=Ce,a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Div=function(){return(a._Div=a.asm.Div).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Negate=function(){return(a._Negate=a.asm.Negate).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.__start=function(){return(a.__start=a.asm._start).apply(null,arguments)};var we,be=a.stackSave=function(){return(be=a.stackSave=a.asm.stackSave).apply(null,arguments)},_e=a.stackAlloc=function(){return(_e=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)},Re=a.stackRestore=function(){return(Re=a.stackRestore=a.asm.stackRestore).apply(null,arguments)};function Ee(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function $e(e){var t=a.__start;try{t(),Ae(0,!0)}catch(e){if(e instanceof Ee)return;if("unwind"==e)return void(v=!0);var n=e;e&&"object"==typeof e&&e.stack&&(n=[e,e.stack]),b("exception thrown: "+n),i(1,e)}}function Ie(e){function t(){we||(we=!0,a.calledRun=!0,_||(z(),H(),a.onRuntimeInitialized&&a.onRuntimeInitialized(),Te&&$e(),X()))}Q>0||(G(),Q>0||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),t()}),1)):t()))}function Ae(e,t){t&&v&&0===e||(v||(_=!0,a.onExit&&a.onExit(e)),i(e,new Ee(e)))}if(a.asm=Ce,a.cwrap=I,a.then=function(e){if(we)e(a);else{var t=a.onRuntimeInitialized;a.onRuntimeInitialized=function(){t&&t(),e(a)}}return a},Z=function e(){we||Ie(),we||(Z=e)},a.run=Ie,a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();var Te=!0;return a.noInitialRun&&(Te=!1),v=!0,Ie(),e});e.exports=a}));class ds extends gn{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new mn(this,ze())}write(e,t,n){const r={};return this.move(r,e,t,n),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=G();e();return{kernelMs:G()-t}}move(e,t,n,r){const o=this.dataIdNextNumber++;if("string"===r){const a=t;return void this.dataIdMap.set(e,{id:o,stringBytes:a,shape:n,dtype:r,memoryOffset:null})}const a=b(n),s=a*D(r),i=this.wasm._malloc(s);this.dataIdMap.set(e,{id:o,memoryOffset:i,shape:n,dtype:r}),this.wasm.tfjs.registerTensor(o,a,i),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,s),i)}async read(e){return this.readSync(e)}readSync(e){const{memoryOffset:t,dtype:n,shape:r,stringBytes:o}=this.dataIdMap.get(e);if("string"===n)return o;return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error("Unknown dtype "+t)}}(this.wasm.HEAPU8.slice(t,t+b(r)*D(n)).buffer,n)}disposeData(e){const t=this.dataIdMap.get(e);this.wasm._free(t.memoryOffset),this.wasm.tfjs.disposeData(t.id),this.dataIdMap.delete(e)}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(null==n)r=this.write(null,e,t);else{r={};const o=this.dataIdNextNumber++;this.dataIdMap.set(r,{id:o,memoryOffset:n,shape:e,dtype:t});const a=b(e);this.wasm.tfjs.registerTensor(o,a,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const r=this.wasm.HEAPU8.buffer,{memoryOffset:o}=this.dataIdMap.get(n),a=b(e);switch(t){case"float32":return new Float32Array(r,o,a);case"int32":return new Int32Array(r,o,a);case"bool":return new Uint8Array(r,o,a);default:throw new Error("Uknown dtype "+t)}}}He("wasm",async()=>{const{wasm:e}=await async function(){const[e,t]=await Promise.all([s().getAsync("WASM_HAS_SIMD_SUPPORT"),s().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{const o={};let a;o.locateFile=(n,r)=>{if(n.endsWith(".worker.js")){const e=new Blob(['var threadInfoStruct=0;var selfThreadId=0;var parentThreadId=0;var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:selfThreadId})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["DYNAMIC_BASE"]=e.data.DYNAMIC_BASE;Module["DYNAMICTOP_PTR"]=e.data.DYNAMICTOP_PTR;Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}Module=WasmBackendModuleThreadedSimd(Module);postMessage({"cmd":"loaded"})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;threadInfoStruct=e.data.threadInfoStruct;Module["__register_pthread_ptr"](threadInfoStruct,0,0);selfThreadId=e.data.selfThreadId;parentThreadId=e.data.parentThreadId;var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["dynCall_ii"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){Atomics.store(Module["HEAPU32"],threadInfoStruct+4>>2,ex instanceof Module["ExitStatus"]?ex.status:-2);Atomics.store(Module["HEAPU32"],threadInfoStruct+0>>2,1);Module["_emscripten_futex_wake"](threadInfoStruct+0,2147483647);if(!(ex instanceof Module["ExitStatus"]))throw ex}}}else if(e.data.cmd==="cancel"){if(threadInfoStruct){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(threadInfoStruct){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}'],{type:"application/javascript"});return URL.createObjectURL(e)}return n.endsWith(".wasm")?function(e,t,n){let r="tfjs-backend-wasm.wasm";e&&t&&(r="tfjs-backend-wasm-threaded-simd.wasm");e&&(r="tfjs-backend-wasm-simd.wasm");if(null!=fs&&null!=fs[r])return fs[r];return n+r}(e,t,r):r+n},t&&e&&null==hs?(a=ls(o),a.mainScriptUrlOrBlob=new Blob(["var _scriptDir = undefined; var WasmBackendModuleThreadedSimd = "+ls.toString()],{type:"text/javascript"})):a=cs(o);a.tfjs={init:a.cwrap("init",null,[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",null,["number"]),dispose:a.cwrap("dispose",null,[])};let s=!1;a.onRuntimeInitialized=()=>{s=!0,ps=!1,n({wasm:a})},a.onAbort=()=>{if(s)return;if(ps)return;ps=!0;r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})}})}();return new ds(e)},2);let hs=null,fs={},ps=!1;var ms,gs;let xs;function ys(e){const{inputs:t,backend:n,attrs:r}=e,[o,a]=function(e,t){const n=[],r=[];for(let o=0;o<e.length;++o)1!==e[o]&&n.push(e[o]),1!==e[t[o]]&&r.push(t[o]);for(let e=0;e<r.length;++e){let t=-1;for(let n=0;n<r.length;++n)r[n]>=e&&(-1===t||r[t]>r[n])&&(t=n);r[t]=e}return[n,r]}(t.x.shape,r.perm);let s=!0;for(let e=0;e<a.length;e++)a[e]!==e&&(s=!1);const i=function(e,t){const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(s){const e=function(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),o=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(o),r}({inputs:t,backend:n});return e.shape=i,e}const l=n.makeOutput(i,u.dtype);n.dataIdMap.get(u.dataId).id,n.dataIdMap.get(l.dataId).id;return(void 0)(),l}!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(ms||(ms={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu"}(gs||(gs={}));const vs={kernelName:"Max",backendName:"wasm",setupFunc:function(e){xs=e.wasm.cwrap("Max",null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{reductionIndices:o,keepDims:a}=r,{x:s}=n;let i=t.dataIdMap.get(s.dataId).id,u=s;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:h}=function(e,t,n){const r=e.shape,o=e.shape.length,a=T(t,r);let s=a;const i=De(s,o);let u=null,l=!1;if(null!=i){const t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r[i[e]];s=Me(s.length,o),u=ys({inputs:{x:e},attrs:{perm:i},backend:n});const a=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==a&&(l=!0)}return{transposed:u,originalAxes:a,axes:s,inputWasTransposed:l}}(s,o,t);if(h){u=l,i=t.dataIdMap.get(l.dataId).id}ke("max",c,u.shape.length);const[f,p]=Oe(u.shape,c),m=b(p),g=t.makeOutput(f,s.dtype);if(0!==b(u.shape)){const e=t.dataIdMap.get(g.dataId).id;xs(i,m,e)}if(h&&t.disposeData(l.dataId),a){const e=Ne(g.shape,d);g.shape=e}return g}};m(Bn),m(is),m(vs);const Cs=Be([1,2,3,4]);console.log("Max result",Cs.dataSync())}));
